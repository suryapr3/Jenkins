#ifndef _AV2D_CSR_H_
#define _AV2D_CSR_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define V2D0_AV2D_APB_0_CSR_BASE  ( 0x0381a000 )
#define V2D0_AV2D_APB_1_CSR_BASE  ( 0x0383a000 )
#define V2D1_AV2D_APB_0_CSR_BASE  ( 0x0385a000 )
#define V2D1_AV2D_APB_1_CSR_BASE  ( 0x0387a000 )
#define V2D2_AV2D_APB_0_CSR_BASE  ( 0x0389a000 )
#define V2D2_AV2D_APB_1_CSR_BASE  ( 0x038ba000 )
#define V2D3_AV2D_APB_0_CSR_BASE  ( 0x038da000 )
#define V2D3_AV2D_APB_1_CSR_BASE  ( 0x038fa000 )
#define V2D4_AV2D_APB_0_CSR_BASE  ( 0x0391a000 )
#define V2D4_AV2D_APB_1_CSR_BASE  ( 0x0393a000 )
#define V2D5_AV2D_APB_0_CSR_BASE  ( 0x0395a000 )
#define V2D5_AV2D_APB_1_CSR_BASE  ( 0x0397a000 )
#define V2D6_AV2D_APB_0_CSR_BASE  ( 0x0399a000 )
#define V2D6_AV2D_APB_1_CSR_BASE  ( 0x039ba000 )
#define V2D7_AV2D_APB_0_CSR_BASE  ( 0x039da000 )
#define V2D7_AV2D_APB_1_CSR_BASE  ( 0x039fa000 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define AV2D_CSR_AV2D_SCRATCH_OFFSET ( 0x00000000U )
#define AV2D_CSR_APB_BRI_STAT_OFFSET ( 0x00000004U )
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_OFFSET ( 0x00000010U )
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_OFFSET ( 0x00000014U )
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_OFFSET ( 0x00000018U )
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_OFFSET ( 0x0000001cU )
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND0_OFFSET ( 0x00000020U )
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND1_OFFSET ( 0x00000024U )
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND2_OFFSET ( 0x00000028U )
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND3_OFFSET ( 0x0000002cU )
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND0_OFFSET ( 0x00000030U )
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND1_OFFSET ( 0x00000034U )
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND2_OFFSET ( 0x00000038U )
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND3_OFFSET ( 0x0000003cU )
#define AV2D_CSR_TX_CSR_TX_STRM_CNT0_OFFSET ( 0x00000040U )
#define AV2D_CSR_TX_CSR_TX_STRM_CNT1_OFFSET ( 0x00000044U )
#define AV2D_CSR_TX_CSR_TX_STRM_CNT2_OFFSET ( 0x00000048U )
#define AV2D_CSR_TX_CSR_TX_STRM_CNT3_OFFSET ( 0x0000004cU )
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT0_OFFSET ( 0x00000050U )
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT1_OFFSET ( 0x00000054U )
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT2_OFFSET ( 0x00000058U )
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT3_OFFSET ( 0x0000005cU )
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_OFFSET ( 0x00000060U )
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_OFFSET ( 0x00000064U )
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT0_OFFSET ( 0x00000068U )
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT1_OFFSET ( 0x0000006cU )
#define AV2D_CSR_RX_CSR_RX_STRM_CNT0_OFFSET ( 0x00000070U )
#define AV2D_CSR_RX_CSR_RX_STRM_CNT1_OFFSET ( 0x00000074U )
#define AV2D_CSR_RX_CSR_RX_STRM_CNT2_OFFSET ( 0x00000078U )
#define AV2D_CSR_RX_CSR_RX_STRM_CNT3_OFFSET ( 0x0000007cU )
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT0_OFFSET ( 0x00000080U )
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT1_OFFSET ( 0x00000084U )
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT2_OFFSET ( 0x00000088U )
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT3_OFFSET ( 0x0000008cU )
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT4_OFFSET ( 0x00000090U )
#define AV2D_CSR_PIF_CTRL_OFFSET ( 0x00000094U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START0_OFFSET ( 0x000000a0U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START1_OFFSET ( 0x000000a4U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START2_OFFSET ( 0x000000a8U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START3_OFFSET ( 0x000000acU )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO0_OFFSET ( 0x000000b0U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO1_OFFSET ( 0x000000b4U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO2_OFFSET ( 0x000000b8U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO3_OFFSET ( 0x000000bcU )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO4_OFFSET ( 0x000000c0U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO5_OFFSET ( 0x000000c4U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO6_OFFSET ( 0x000000c8U )
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO7_OFFSET ( 0x000000ccU )
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_OFFSET ( 0x000000d0U )
#define AV2D_CSR_INT_CSR_INT_STAT_OFFSET ( 0x000000e0U )
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_OFFSET ( 0x000000e4U )
#define AV2D_CSR_INT_CSR_INT_LOW_EN_OFFSET ( 0x000000e8U )
#define AV2D_CSR_INT_CSR_INT_CLR_OFFSET ( 0x000000ecU )
#define AV2D_CSR_INT_CSR_INT_FORCE_OFFSET ( 0x000000f0U )
#define AV2D_CSR_SMON_CSR_SMON_R0_OFFSET ( 0x00000100U )
#define AV2D_CSR_SMON_CSR_SMON_R1_OFFSET ( 0x00000104U )
#define AV2D_CSR_SMON_CSR_SMON_R2_OFFSET ( 0x00000108U )
#define AV2D_CSR_SMON_CSR_SMON_R3_OFFSET ( 0x0000010cU )
#define AV2D_CSR_SMON_CSR_SMON_R4_OFFSET ( 0x00000110U )
#define AV2D_CSR_SMON_CSR_SMON_R5_OFFSET ( 0x00000114U )
#define AV2D_CSR_SMON_CSR_SMON_R6_OFFSET ( 0x00000118U )
#define AV2D_CSR_SMON_CSR_SMON_R7_OFFSET ( 0x0000011cU )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO0_OFFSET ( 0x00000120U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO1_OFFSET ( 0x00000124U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO2_OFFSET ( 0x00000128U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO3_OFFSET ( 0x0000012cU )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO4_OFFSET ( 0x00000130U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO5_OFFSET ( 0x00000134U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO6_OFFSET ( 0x00000138U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO7_OFFSET ( 0x0000013cU )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL0_OFFSET ( 0x00000140U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL1_OFFSET ( 0x00000144U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL2_OFFSET ( 0x00000148U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL3_OFFSET ( 0x0000014cU )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL4_OFFSET ( 0x00000150U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL5_OFFSET ( 0x00000154U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL6_OFFSET ( 0x00000158U )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL7_OFFSET ( 0x0000015cU )
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_STAT_OFFSET ( 0x00000160U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO0_OFFSET ( 0x00000170U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO1_OFFSET ( 0x00000174U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO2_OFFSET ( 0x00000178U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO3_OFFSET ( 0x0000017cU )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO4_OFFSET ( 0x00000180U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO5_OFFSET ( 0x00000184U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO6_OFFSET ( 0x00000188U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO7_OFFSET ( 0x0000018cU )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL0_OFFSET ( 0x00000190U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL1_OFFSET ( 0x00000194U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL2_OFFSET ( 0x00000198U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL3_OFFSET ( 0x0000019cU )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL4_OFFSET ( 0x000001a0U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL5_OFFSET ( 0x000001a4U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL6_OFFSET ( 0x000001a8U )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL7_OFFSET ( 0x000001acU )
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_STAT_OFFSET ( 0x000001b0U )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define AV2D_CSR_AV2D_SCRATCH_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_AV2D_SCRATCH_OFFSET ) ))
#define AV2D_CSR_APB_BRI_STAT_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_APB_BRI_STAT_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_GNRL_CSR_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_SIF_CTRL_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_BUF_STAT_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PTR_BOUND0_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PTR_BOUND1_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PTR_BOUND2_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PTR_BOUND3_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND0_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND1_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND2_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND3_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_STRM_CNT0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_STRM_CNT0_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_STRM_CNT1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_STRM_CNT1_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_STRM_CNT2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_STRM_CNT2_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_STRM_CNT3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_STRM_CNT3_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PD_STRM_CNT0_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PD_STRM_CNT1_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PD_STRM_CNT2_OFFSET ) ))
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_CSR_TX_PD_STRM_CNT3_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_GNRL_CSR_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_PACKET_SZ_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT0_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT1_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_STRM_CNT0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_STRM_CNT0_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_STRM_CNT1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_STRM_CNT1_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_STRM_CNT2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_STRM_CNT2_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_STRM_CNT3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_STRM_CNT3_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_PD_STRM_CNT0_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_PD_STRM_CNT1_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_PD_STRM_CNT2_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_PD_STRM_CNT3_OFFSET ) ))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT4_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_RX_CSR_RX_PD_STRM_CNT4_OFFSET ) ))
#define AV2D_CSR_PIF_CTRL_ADR(_BASE)    (( ( _BASE ) + ( AV2D_CSR_PIF_CTRL_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START0_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START1_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START2_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START3_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO0_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO1_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO2_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO3_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO4_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO4_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO5_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO5_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO6_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO6_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO7_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO7_OFFSET ) ))
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_WM_TX_START_WM_OFFSET ) ))
#define AV2D_CSR_INT_CSR_INT_STAT_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_INT_CSR_INT_STAT_OFFSET ) ))
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_INT_CSR_INT_HIGH_EN_OFFSET ) ))
#define AV2D_CSR_INT_CSR_INT_LOW_EN_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_INT_CSR_INT_LOW_EN_OFFSET ) ))
#define AV2D_CSR_INT_CSR_INT_CLR_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_INT_CSR_INT_CLR_OFFSET ) ))
#define AV2D_CSR_INT_CSR_INT_FORCE_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_INT_CSR_INT_FORCE_OFFSET ) ))
#define AV2D_CSR_SMON_CSR_SMON_R0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_SMON_CSR_SMON_R0_OFFSET ) ))
#define AV2D_CSR_SMON_CSR_SMON_R1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_SMON_CSR_SMON_R1_OFFSET ) ))
#define AV2D_CSR_SMON_CSR_SMON_R2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_SMON_CSR_SMON_R2_OFFSET ) ))
#define AV2D_CSR_SMON_CSR_SMON_R3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_SMON_CSR_SMON_R3_OFFSET ) ))
#define AV2D_CSR_SMON_CSR_SMON_R4_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_SMON_CSR_SMON_R4_OFFSET ) ))
#define AV2D_CSR_SMON_CSR_SMON_R5_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_SMON_CSR_SMON_R5_OFFSET ) ))
#define AV2D_CSR_SMON_CSR_SMON_R6_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_SMON_CSR_SMON_R6_OFFSET ) ))
#define AV2D_CSR_SMON_CSR_SMON_R7_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_SMON_CSR_SMON_R7_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO0_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO1_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO2_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO3_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO4_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO4_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO5_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO5_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO6_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO6_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO7_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO7_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL0_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL1_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL2_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL3_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL4_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL4_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL5_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL5_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL6_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL6_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL7_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL7_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_STAT_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_STAT_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO0_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO1_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO2_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO3_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO4_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO4_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO5_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO5_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO6_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO6_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO7_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO7_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL0_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL0_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL1_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL1_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL2_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL2_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL3_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL3_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL4_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL4_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL5_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL5_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL6_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL6_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL7_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL7_OFFSET ) ))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_STAT_ADR(_BASE) (( ( _BASE ) + ( AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_STAT_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief AV2D_CSR_COM_REG_AV2D_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/AV2D_SCRATCH
  * Scratch Register
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Scratch pad
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_av2d_scratch_reg_t;

#define AV2D_CSR_AV2D_SCRATCH_DEFAULT (0x00000000U)
#define AV2D_CSR_AV2D_SCRATCH_RD_MASK (0xffffffffU)
#define AV2D_CSR_AV2D_SCRATCH_WR_MASK (0xffffffffU)


///< Scratch pad
#define AV2D_CSR_AV2D_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define AV2D_CSR_AV2D_SCRATCH_SCRATCHPAD_BF_WID (32)
#define AV2D_CSR_AV2D_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define AV2D_CSR_AV2D_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_APB_BRI_STATUS register description at address offset 0x4
  *
  * Register default value:        0x00010000
  * Register full path in IP: av2d_csr_com/reg/APB_BRI_STATUS
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW/L" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW/1S/V/L" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW/1C/V" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW/1C/V" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW/1C/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_apb_bri_stat_reg_t;

#define AV2D_CSR_APB_BRI_STAT_DEFAULT (0x00010000U)
#define AV2D_CSR_APB_BRI_STAT_RD_MASK (0xffffffffU)
#define AV2D_CSR_APB_BRI_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define AV2D_CSR_APB_BRI_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define AV2D_CSR_APB_BRI_STAT_TIMEOUT_VAL_BF_WID (20)
#define AV2D_CSR_APB_BRI_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define AV2D_CSR_APB_BRI_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define AV2D_CSR_APB_BRI_STAT_REVISION_BF_OFF (20)
#define AV2D_CSR_APB_BRI_STAT_REVISION_BF_WID ( 8)
#define AV2D_CSR_APB_BRI_STAT_REVISION_BF_MSK (0x0FF00000)
#define AV2D_CSR_APB_BRI_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define AV2D_CSR_APB_BRI_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define AV2D_CSR_APB_BRI_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define AV2D_CSR_APB_BRI_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define AV2D_CSR_APB_BRI_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define AV2D_CSR_APB_BRI_STAT_UNSOL_ACK_BF_OFF (29)
#define AV2D_CSR_APB_BRI_STAT_UNSOL_ACK_BF_WID ( 1)
#define AV2D_CSR_APB_BRI_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define AV2D_CSR_APB_BRI_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define AV2D_CSR_APB_BRI_STAT_ACK_ERR_BF_OFF (30)
#define AV2D_CSR_APB_BRI_STAT_ACK_ERR_BF_WID ( 1)
#define AV2D_CSR_APB_BRI_STAT_ACK_ERR_BF_MSK (0x40000000)
#define AV2D_CSR_APB_BRI_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define AV2D_CSR_APB_BRI_STAT_TIMEOUT_BF_OFF (31)
#define AV2D_CSR_APB_BRI_STAT_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_APB_BRI_STAT_TIMEOUT_BF_MSK (0x80000000)
#define AV2D_CSR_APB_BRI_STAT_TIMEOUT_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_TX_CSR_TX_GNRL_CSR register description at address offset 0x10
  *
  * Register default value:        0x00000003
  * Register full path in IP: av2d_csr_com/reg/TX_CSR/TX_GNRL_CSR
  * Tx (VEX Array to DRF and PDPD) General Control and Status Register
  */

typedef union {
  struct {
    uint32_t BUFFER_0_POWER_DOWN : 1;
    ///< Buffer Memory Power Down. When set, the corresponding Tx Buffer Memory
    ///< is powered down.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t BUFFER_1_POWER_DOWN : 1;
    ///< Buffer Memory Power Down. When set, the corresponding Tx Buffer Memory
    ///< is powered down.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x1"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
    uint32_t TX_ALARM_ECC_DBE_MASK : 1;
    ///< Tx Alarm ECC Multi-bit Error Mask. When set, this bit masks out ECC
    ///< multi-bit error for Tx alarm to DRF.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t TX_ALARM_UNDERRUN_MASK : 1;
    ///< Tx Alarm Underrun Mask. When set, this bit masks out Tx underrun for
    ///< Tx alarm to DRF.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t TX_ALARM_CM_0_ERR_MASK : 1;
    ///< Tx Alarm CommonModule(nsip_hbi) Error Mask. When set, the corresponding
    ///< CM error from CM's high priority interrupt signal is masked out for
    ///< Tx alarm to DRF.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t TX_ALARM_CM_1_ERR_MASK : 1;
    ///< Tx Alarm CommonModule(nsip_hbi) Error Mask. When set, the corresponding
    ///< CM error from CM's high priority interrupt signal is masked out for
    ///< Tx alarm to DRF.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t PD_EXTRA_EN : 1;
    ///< PDPD Extra Term Enable. When set, this field informs Tx logic that
    ///< the PDPD extra term, C path, is enabled and A path is disabled. Otherwise,
    ///< A path is enabled and C path is disabled.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
    uint32_t TX_CFG_COMPLETE : 1;
    ///< Tx Configuration Completed. This field informs Tx logic that Tx related
    ///< registers are programmed and ready to handle Tx traffic.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t TX_CAPTURE_IDX_AC : 2;
    ///< Tx Capture Index A/C. When a data with this index value is seen on
    ///< Tx Buffer write for path A/C, data to DRF or PDPD extra term, the
    ///< TX_CAPTURE_DONE_AC bit will be triggered and the BFN time will be
    ///< captured. Update of this value will reset TX_CAPTURE_DONE_AC bit and
    ///< be ready for trigger again.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t TX_CAPTURE_IDX_B : 2;
    ///< Tx Capture Index B. When a data with this index value is seen on Tx
    ///< Buffer write for path B, data to PDPD main term, the TX_CAPTURE_DONE_B
    ///< bit will be triggered and the BFN time will be captured. Update of
    ///< this value will reset TX_CAPTURE_DONE_B bit and be ready for trigger
    ///< again.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t TX_CAPTURE_DONE_AC : 1;
    ///< Tx Capture Done A/C. When it's 0 and the logic sees a data with TX_CAPTUE_IDX_AC
    ///< index on Tx Buffer write side for path A/C, data to DRF or PDPF extra
    ///< term, this bit will be set. An update of TX_CAPTURE_IDX_AC value will
    ///< reset this bit to 0, and get ready to re-trigger.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint32_t TX_CAPTURE_DONE_B : 1;
    ///< Tx Capture Done B. When it's 0 and the logic sees a data with TX_CAPTUE_IDX_B
    ///< index on Tx Buffer write side for path B, data to PDPF main term,
    ///< this bit will be set. An update of TX_CAPTURE_IDX_B value will reset
    ///< this bit to 0, and get ready to re-trigger.
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_csr_tx_gnrl_csr_reg_t;

#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_DEFAULT (0x00000003U)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_RD_MASK (0x3f8100f3U)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_WR_MASK (0x0f8100f3U)


///< Buffer Memory Power Down. When set, the corresponding Tx Buffer Memory
///< is powered down.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_BUFF_0_PWR_DOWN_BF_OFF ( 0)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_BUFF_0_PWR_DOWN_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_BUFF_0_PWR_DOWN_BF_MSK (0x00000001)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_BUFF_0_PWR_DOWN_BF_DEF (0x00000001)

///< Buffer Memory Power Down. When set, the corresponding Tx Buffer Memory
///< is powered down.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_BUFF_1_PWR_DOWN_BF_OFF ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_BUFF_1_PWR_DOWN_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_BUFF_1_PWR_DOWN_BF_MSK (0x00000002)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_BUFF_1_PWR_DOWN_BF_DEF (0x00000002)

///< Tx Alarm ECC Multi-bit Error Mask. When set, this bit masks out ECC
///< multi-bit error for Tx alarm to DRF.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_ECC_DBE_MASK_BF_OFF ( 4)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_ECC_DBE_MASK_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_ECC_DBE_MASK_BF_MSK (0x00000010)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_ECC_DBE_MASK_BF_DEF (0x00000000)

///< Tx Alarm Underrun Mask. When set, this bit masks out Tx underrun for
///< Tx alarm to DRF.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_UNDERRUN_MASK_BF_OFF ( 5)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_UNDERRUN_MASK_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_UNDERRUN_MASK_BF_MSK (0x00000020)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_UNDERRUN_MASK_BF_DEF (0x00000000)

///< Tx Alarm CommonModule(nsip_hbi) Error Mask. When set, the corresponding
///< CM error from CM's high priority interrupt signal is masked out for
///< Tx alarm to DRF.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_CM_0_ERR_MASK_BF_OFF ( 6)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_CM_0_ERR_MASK_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_CM_0_ERR_MASK_BF_MSK (0x00000040)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_CM_0_ERR_MASK_BF_DEF (0x00000000)

///< Tx Alarm CommonModule(nsip_hbi) Error Mask. When set, the corresponding
///< CM error from CM's high priority interrupt signal is masked out for
///< Tx alarm to DRF.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_CM_1_ERR_MASK_BF_OFF ( 7)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_CM_1_ERR_MASK_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_CM_1_ERR_MASK_BF_MSK (0x00000080)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_ALARM_CM_1_ERR_MASK_BF_DEF (0x00000000)

///< PDPD Extra Term Enable. When set, this field informs Tx logic that
///< the PDPD extra term, C path, is enabled and A path is disabled. Otherwise,
///< A path is enabled and C path is disabled.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_PD_EXTRA_EN_BF_OFF (16)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_PD_EXTRA_EN_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_PD_EXTRA_EN_BF_MSK (0x00010000)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_PD_EXTRA_EN_BF_DEF (0x00000000)

///< Tx Configuration Completed. This field informs Tx logic that Tx related
///< registers are programmed and ready to handle Tx traffic.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CFG_COMPLETE_BF_OFF (23)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CFG_COMPLETE_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CFG_COMPLETE_BF_MSK (0x00800000)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CFG_COMPLETE_BF_DEF (0x00000000)

///< Tx Capture Index A/C. When a data with this index value is seen on
///< Tx Buffer write for path A/C, data to DRF or PDPD extra term, the
///< TX_CAPTURE_DONE_AC bit will be triggered and the BFN time will be
///< captured. Update of this value will reset TX_CAPTURE_DONE_AC bit and
///< be ready for trigger again.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_IDX_AC_BF_OFF (24)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_IDX_AC_BF_WID ( 2)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_IDX_AC_BF_MSK (0x03000000)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_IDX_AC_BF_DEF (0x00000000)

///< Tx Capture Index B. When a data with this index value is seen on Tx
///< Buffer write for path B, data to PDPD main term, the TX_CAPTURE_DONE_B
///< bit will be triggered and the BFN time will be captured. Update of
///< this value will reset TX_CAPTURE_DONE_B bit and be ready for trigger
///< again.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_IDX_B_BF_OFF (26)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_IDX_B_BF_WID ( 2)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_IDX_B_BF_MSK (0x0C000000)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_IDX_B_BF_DEF (0x00000000)

///< Tx Capture Done A/C. When it's 0 and the logic sees a data with TX_CAPTUE_IDX_AC
///< index on Tx Buffer write side for path A/C, data to DRF or PDPF extra
///< term, this bit will be set. An update of TX_CAPTURE_IDX_AC value will
///< reset this bit to 0, and get ready to re-trigger.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_DONE_AC_BF_OFF (28)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_DONE_AC_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_DONE_AC_BF_MSK (0x10000000)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_DONE_AC_BF_DEF (0x00000000)

///< Tx Capture Done B. When it's 0 and the logic sees a data with TX_CAPTUE_IDX_B
///< index on Tx Buffer write side for path B, data to PDPF main term,
///< this bit will be set. An update of TX_CAPTURE_IDX_B value will reset
///< this bit to 0, and get ready to re-trigger.
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_DONE_B_BF_OFF (29)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_DONE_B_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_DONE_B_BF_MSK (0x20000000)
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_TX_CAP_DONE_B_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_TX_CSR_TX_SIF_CTRL register description at address offset 0x14
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_CSR/TX_SIF_CTRL
  * Tx Sample Interface Control Register
  */

typedef union {
  struct {
    uint32_t TX_SYS_RATE : 5;
    ///< Tx System Sampling Rate. This field controls the system sampling rate
    ///< for VEX to DRF direction. This control and DRF_1P5G_CLK bit affect
    ///< data pattern on Tx Sample Interface. The described numbers of clock
    ///< cycles, N/M, are based on clock rates 983M/1.474G Hz, indicated by
    ///< DRF_1p5G_CLK bit.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
    uint32_t DRF_1P5G_CLK : 1;
    ///< DigRF On 1.5G Clock. When set, it indicates V2D and DRF blocks are
    ///< running with 1.474G clock rate. By default, the clock rate is 983M.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t TX_USE_PD : 1;
    ///< Tx Use PDPD Output Data. When high, this bit shows Tx Sample Interface
    ///< is using data from PDPD block, instead of using data from VEX Array,
    ///< and data pattern on Tx Sample Interface will be controlled by PDPD
    ///< sampling rate, not TX_SYS_RATE.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t TX_RX_LPBK : 1;
    ///< Tx to Rx Loopback. When set, Tx data will be looped back to Rx side,
    ///< nsip_hbi 0, on DRF Sample Interface.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_csr_tx_sif_ctrl_reg_t;

#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_RD_MASK (0x0000039fU)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_WR_MASK (0x0000029fU)


///< Tx System Sampling Rate. This field controls the system sampling rate
///< for VEX to DRF direction. This control and DRF_1P5G_CLK bit affect
///< data pattern on Tx Sample Interface. The described numbers of clock
///< cycles, N/M, are based on clock rates 983M/1.474G Hz, indicated by
///< DRF_1p5G_CLK bit.
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_SYS_RATE_BF_OFF ( 0)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_SYS_RATE_BF_WID ( 5)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_SYS_RATE_BF_MSK (0x0000001F)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_SYS_RATE_BF_DEF (0x00000000)

///< DigRF On 1.5G Clock. When set, it indicates V2D and DRF blocks are
///< running with 1.474G clock rate. By default, the clock rate is 983M.
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_DRF_1P5G_CLK_BF_OFF ( 7)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_DRF_1P5G_CLK_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_DRF_1P5G_CLK_BF_MSK (0x00000080)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_DRF_1P5G_CLK_BF_DEF (0x00000000)

///< Tx Use PDPD Output Data. When high, this bit shows Tx Sample Interface
///< is using data from PDPD block, instead of using data from VEX Array,
///< and data pattern on Tx Sample Interface will be controlled by PDPD
///< sampling rate, not TX_SYS_RATE.
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_USE_PD_BF_OFF ( 8)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_USE_PD_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_USE_PD_BF_MSK (0x00000100)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_USE_PD_BF_DEF (0x00000000)

///< Tx to Rx Loopback. When set, Tx data will be looped back to Rx side,
///< nsip_hbi 0, on DRF Sample Interface.
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_RX_LPBK_BF_OFF ( 9)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_RX_LPBK_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_RX_LPBK_BF_MSK (0x00000200)
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_TX_RX_LPBK_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_TX_CSR_TX_SIF_SMPL_CNT register description at address offset 0x18
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_CSR/TX_SIF_SMPL_CNT
  * Tx Sample Interface Sample Count
  */

typedef union {
  struct {
    uint32_t SAMPLE_COUNT : 24;
    ///< This is the value of the 24-bit counter on Tx Sample Interface. It
    ///< increments by 1 when a valid 256-bit sample data is sent to DRF.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_csr_tx_sif_smpl_cnt_reg_t;

#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_RD_MASK (0x00ffffffU)
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_WR_MASK (0x00000000U)


///< This is the value of the 24-bit counter on Tx Sample Interface. It
///< increments by 1 when a valid 256-bit sample data is sent to DRF.
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_SAMPLE_CNT_BF_OFF ( 0)
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_SAMPLE_CNT_BF_WID (24)
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_SAMPLE_CNT_BF_MSK (0x00FFFFFF)
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_SAMPLE_CNT_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_TX_CSR_TX_BUF_STATUS register description at address offset 0x1c
  *
  * Register default value:        0x00FF0000
  * Register full path in IP: av2d_csr_com/reg/TX_CSR/TX_BUF_STATUS
  * Tx Buffer Full/Empty Status
  */

typedef union {
  struct {
    uint32_t TX_AC_BUF_FULL : 4;
    ///< This field shows the Buffer full status for the allocated spaces for
    ///< the four Tx data or PDPD extra term streams, A or C streams.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TX_B_BUF_FULL : 4;
    ///< This field shows the Buffer full status for the allocated spaces for
    ///< the four PDPD main streams, B streams.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t TX_AC_BUF_EMPTY : 4;
    ///< This field shows the Buffer empty status for the allocated spaces
    ///< for the four Tx data or PDPD extra term streams, A or C streams.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0xF"
    uint32_t TX_B_BUF_EMPTY : 4;
    ///< This field shows the Buffer empty status for the allocated spaces
    ///< for the four PDPD main streams, B streams.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0xF"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_csr_tx_buf_stat_reg_t;

#define AV2D_CSR_TX_CSR_TX_BUF_STAT_DEFAULT (0x00ff0000U)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_RD_MASK (0x00ff00ffU)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_WR_MASK (0x00000000U)


///< This field shows the Buffer full status for the allocated spaces for
///< the four Tx data or PDPD extra term streams, A or C streams.
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_AC_BUF_FULL_BF_OFF ( 0)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_AC_BUF_FULL_BF_WID ( 4)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_AC_BUF_FULL_BF_MSK (0x0000000F)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_AC_BUF_FULL_BF_DEF (0x00000000)

///< This field shows the Buffer full status for the allocated spaces for
///< the four PDPD main streams, B streams.
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_B_BUF_FULL_BF_OFF ( 4)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_B_BUF_FULL_BF_WID ( 4)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_B_BUF_FULL_BF_MSK (0x000000F0)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_B_BUF_FULL_BF_DEF (0x00000000)

///< This field shows the Buffer empty status for the allocated spaces
///< for the four Tx data or PDPD extra term streams, A or C streams.
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_AC_BUF_EMPTY_BF_OFF (16)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_AC_BUF_EMPTY_BF_WID ( 4)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_AC_BUF_EMPTY_BF_MSK (0x000F0000)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_AC_BUF_EMPTY_BF_DEF (0x000F0000)

///< This field shows the Buffer empty status for the allocated spaces
///< for the four PDPD main streams, B streams.
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_B_BUF_EMPTY_BF_OFF (20)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_B_BUF_EMPTY_BF_WID ( 4)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_B_BUF_EMPTY_BF_MSK (0x00F00000)
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_TX_B_BUF_EMPTY_BF_DEF (0x00F00000)


/** @brief AV2D_CSR_COM_REG_TX_CSR_TX_PTR_BOUND[4] register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_CSR/TX_PTR_BOUND
  * Tx Data and PDPD Extra Term Buffer Read/Write Pointer Upper/Lower Boundary Control Register
  */

typedef union {
  struct {
    uint32_t AC_LOWER_BOUND : 11;
    ///< Lower Boundary for Tx A/C Buffer Pointers. This field defines pointer's
    ///< starting location for a circular buffer partition in the buffer memory.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t AC_UPPER_BOUND : 11;
    ///< Upper Boundary for Tx A/C Buffer Pointers. This field defines pointer's
    ///< ending location for a circular buffer partition in the buffer memory.
    ///< This value is not allowed to be less than the value of AC_LOWER_BOUND.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_csr_tx_ptr_bound_reg_t;

#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_RD_MASK (0x07ff07ffU)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_WR_MASK (0x07ff07ffU)


///< Lower Boundary for Tx A/C Buffer Pointers. This field defines pointer's
///< starting location for a circular buffer partition in the buffer memory.
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_AC_LOWER_BOUND_BF_OFF ( 0)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_AC_LOWER_BOUND_BF_WID (11)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_AC_LOWER_BOUND_BF_MSK (0x000007FF)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_AC_LOWER_BOUND_BF_DEF (0x00000000)

///< Upper Boundary for Tx A/C Buffer Pointers. This field defines pointer's
///< ending location for a circular buffer partition in the buffer memory.
///< This value is not allowed to be less than the value of AC_LOWER_BOUND.
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_AC_UPPER_BOUND_BF_OFF (16)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_AC_UPPER_BOUND_BF_WID (11)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_AC_UPPER_BOUND_BF_MSK (0x07FF0000)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_AC_UPPER_BOUND_BF_DEF (0x00000000)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_ARR_SZ0 (4)
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_TX_CSR_TX_PD_PTR_BOUND[4] register description at address offset 0x30
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_CSR/TX_PD_PTR_BOUND
  * Tx PDPD Main Data Buffer Read/Write Pointer Upper/Lower Boundary Control Register
  */

typedef union {
  struct {
    uint32_t B_LOWER_BOUND : 11;
    ///< Lower Boundary for Tx B Buffer Pointers. This field defines pointer's
    ///< starting location for a circular buffer partition in the buffer memory.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
    uint32_t B_UPPER_BOUND : 11;
    ///< Upper Boundary for Tx B Buffer Pointers. This field defines pointer's
    ///< ending location for a circular buffer partition in the buffer memory.
    ///< This value is not allowed to be less than the value of B_LOWER_BOUND.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 5;
    ///< Reserved
    ///< AccessType="RO" BitOffset="27" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_csr_tx_pd_ptr_bound_reg_t;

#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_RD_MASK (0x07ff07ffU)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_WR_MASK (0x07ff07ffU)


///< Lower Boundary for Tx B Buffer Pointers. This field defines pointer's
///< starting location for a circular buffer partition in the buffer memory.
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_B_LOWER_BOUND_BF_OFF ( 0)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_B_LOWER_BOUND_BF_WID (11)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_B_LOWER_BOUND_BF_MSK (0x000007FF)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_B_LOWER_BOUND_BF_DEF (0x00000000)

///< Upper Boundary for Tx B Buffer Pointers. This field defines pointer's
///< ending location for a circular buffer partition in the buffer memory.
///< This value is not allowed to be less than the value of B_LOWER_BOUND.
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_B_UPPER_BOUND_BF_OFF (16)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_B_UPPER_BOUND_BF_WID (11)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_B_UPPER_BOUND_BF_MSK (0x07FF0000)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_B_UPPER_BOUND_BF_DEF (0x00000000)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_ARR_SZ0 (4)
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_TX_CSR_TX_STREAM_CNT[4] register description at address offset 0x40
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_CSR/TX_STREAM_CNT
  * Tx Stream Count
  */

typedef union {
  struct {
    uint32_t STREAM_CNT : 10;
    ///< Stream Count. This value is used to read data flits out of Tx Buffer.
    ///< It supports up to 1k 512-bit data flits. 0 means 1 flit.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t STREAM_EN : 1;
    ///< Stream Enable. This value is used to enable the STREAM_CNT field.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_tx_csr_tx_strm_cnt_reg_t;

#define AV2D_CSR_TX_CSR_TX_STRM_CNT_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_RD_MASK (0x800003ffU)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_WR_MASK (0x800003ffU)


///< Stream Count. This value is used to read data flits out of Tx Buffer.
///< It supports up to 1k 512-bit data flits. 0 means 1 flit.
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_STRM_CNT_BF_OFF ( 0)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_STRM_CNT_BF_WID (10)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_STRM_CNT_BF_MSK (0x000003FF)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_STRM_CNT_BF_DEF (0x00000000)

///< Stream Enable. This value is used to enable the STREAM_CNT field.
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_STRM_EN_BF_OFF (31)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_STRM_EN_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_STRM_EN_BF_MSK (0x80000000)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_STRM_EN_BF_DEF (0x00000000)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_ARR_SZ0 (4)
#define AV2D_CSR_TX_CSR_TX_STRM_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_TX_CSR_TX_PD_STREAM_CNT[4] register description at address offset 0x50
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_CSR/TX_PD_STREAM_CNT
  * Tx PDPD Main Stream Count
  */

typedef union {
  struct {
    uint32_t STREAM_CNT : 10;
    ///< Stream Count. This value is used to read data flits out of Tx Buffer.
    ///< It supports up to 1k 512-bit data flits. 0 means 1 flit.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t STREAM_EN : 1;
    ///< Stream Enable. This value is used to enable the STREAM_CNT field.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_tx_csr_tx_pd_strm_cnt_reg_t;

#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_RD_MASK (0x800003ffU)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_WR_MASK (0x800003ffU)


///< Stream Count. This value is used to read data flits out of Tx Buffer.
///< It supports up to 1k 512-bit data flits. 0 means 1 flit.
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_STRM_CNT_BF_OFF ( 0)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_STRM_CNT_BF_WID (10)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_STRM_CNT_BF_MSK (0x000003FF)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_STRM_CNT_BF_DEF (0x00000000)

///< Stream Enable. This value is used to enable the STREAM_CNT field.
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_STRM_EN_BF_OFF (31)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_STRM_EN_BF_WID ( 1)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_STRM_EN_BF_MSK (0x80000000)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_STRM_EN_BF_DEF (0x00000000)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_ARR_SZ0 (4)
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_RX_CSR_RX_GNRL_CSR register description at address offset 0x60
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/RX_CSR/RX_GNRL_CSR
  * Rx (DRF and PDPD to VEX Array) General Control and Status Register
  */

typedef union {
  struct {
    uint32_t RX_CFG_COMPLETE : 1;
    ///< Rx Configuration Completed. This bit informs Rx logic, abc_v2d_rx
    ///< 0,  that Rx related registers are programmed and ready to handle DRF
    ///< Rx traffic.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RX_STARTED : 1;
    ///< Rx Started. When 1, it indicates that abc_v2d_rx 0 block has received
    ///< a data.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t RX_PD_CFG_COMPLETE : 1;
    ///< Rx PDPD Configuration Completed. This bit informs Rx logic, abc_v2d_rx
    ///< 1,  that Rx related registers are programmed and ready to handle PDPD
    ///< egress traffic.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t RX_PD_STARTED : 1;
    ///< Rx PDPD Started. When 1, it indicates that abc_v2d_rx 1 block has
    ///< received a data from PDPD.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t RX_PD_EN : 1;
    ///< Rx PDPD Enable. When high, this bit enables Rx logic, abc_v2d_rx 1,
    ///< to receive PDPD egress traffic.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_rx_csr_rx_gnrl_csr_reg_t;

#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_DEFAULT (0x00000000U)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RD_MASK (0x0000001fU)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_WR_MASK (0x00000015U)


///< Rx Configuration Completed. This bit informs Rx logic, abc_v2d_rx
///< 0,  that Rx related registers are programmed and ready to handle DRF
///< Rx traffic.
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_CFG_COMPLETE_BF_OFF ( 0)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_CFG_COMPLETE_BF_WID ( 1)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_CFG_COMPLETE_BF_MSK (0x00000001)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_CFG_COMPLETE_BF_DEF (0x00000000)

///< Rx Started. When 1, it indicates that abc_v2d_rx 0 block has received
///< a data.
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_STARTED_BF_OFF ( 1)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_STARTED_BF_WID ( 1)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_STARTED_BF_MSK (0x00000002)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_STARTED_BF_DEF (0x00000000)

///< Rx PDPD Configuration Completed. This bit informs Rx logic, abc_v2d_rx
///< 1,  that Rx related registers are programmed and ready to handle PDPD
///< egress traffic.
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_CFG_COMPLETE_BF_OFF ( 2)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_CFG_COMPLETE_BF_WID ( 1)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_CFG_COMPLETE_BF_MSK (0x00000004)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_CFG_COMPLETE_BF_DEF (0x00000000)

///< Rx PDPD Started. When 1, it indicates that abc_v2d_rx 1 block has
///< received a data from PDPD.
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_STARTED_BF_OFF ( 3)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_STARTED_BF_WID ( 1)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_STARTED_BF_MSK (0x00000008)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_STARTED_BF_DEF (0x00000000)

///< Rx PDPD Enable. When high, this bit enables Rx logic, abc_v2d_rx 1,
///< to receive PDPD egress traffic.
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_EN_BF_OFF ( 4)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_EN_BF_WID ( 1)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_EN_BF_MSK (0x00000010)
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_RX_PD_EN_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_RX_CSR_RX_PACKET_SZ register description at address offset 0x64
  *
  * Register default value:        0x00AA00AA
  * Register full path in IP: av2d_csr_com/reg/RX_CSR/RX_PACKET_SZ
  * Rx HBI Interface Per Stream Packet Size Control Register
  */

typedef union {
  struct {
    uint32_t RX_PKT_SZ_STREAM_0 : 2;
    ///< Packet Size for Rx Stream. Each 2 bits define a packet size for a
    ///< stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
    ///< AccessType="RW" BitOffset="0" ResetValue="0x2"
    uint32_t RX_PKT_SZ_STREAM_1 : 2;
    ///< Packet Size for Rx Stream. Each 2 bits define a packet size for a
    ///< stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
    ///< AccessType="RW" BitOffset="2" ResetValue="0x2"
    uint32_t RX_PKT_SZ_STREAM_2 : 2;
    ///< Packet Size for Rx Stream. Each 2 bits define a packet size for a
    ///< stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
    ///< AccessType="RW" BitOffset="4" ResetValue="0x2"
    uint32_t RX_PKT_SZ_STREAM_3 : 2;
    ///< Packet Size for Rx Stream. Each 2 bits define a packet size for a
    ///< stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
    ///< AccessType="RW" BitOffset="6" ResetValue="0x2"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
    uint32_t PD_PKT_SZ_STREAM_0 : 2;
    ///< Packet Size for PDPD Stream. Each 2 bits define a packet size for
    ///< a stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
    ///< AccessType="RW" BitOffset="16" ResetValue="0x2"
    uint32_t PD_PKT_SZ_STREAM_1 : 2;
    ///< Packet Size for PDPD Stream. Each 2 bits define a packet size for
    ///< a stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
    ///< AccessType="RW" BitOffset="18" ResetValue="0x2"
    uint32_t PD_PKT_SZ_STREAM_2 : 2;
    ///< Packet Size for PDPD Stream. Each 2 bits define a packet size for
    ///< a stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
    ///< AccessType="RW" BitOffset="20" ResetValue="0x2"
    uint32_t PD_PKT_SZ_STREAM_3 : 2;
    ///< Packet Size for PDPD Stream. Each 2 bits define a packet size for
    ///< a stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
    ///< AccessType="RW" BitOffset="22" ResetValue="0x2"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_rx_csr_rx_packet_sz_reg_t;

#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_DEFAULT (0x00aa00aaU)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RD_MASK (0x00ff00ffU)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_WR_MASK (0x00ff00ffU)


///< Packet Size for Rx Stream. Each 2 bits define a packet size for a
///< stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_0_BF_OFF ( 0)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_0_BF_WID ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_0_BF_MSK (0x00000003)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_0_BF_DEF (0x00000002)

///< Packet Size for Rx Stream. Each 2 bits define a packet size for a
///< stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_1_BF_OFF ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_1_BF_WID ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_1_BF_MSK (0x0000000C)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_1_BF_DEF (0x00000008)

///< Packet Size for Rx Stream. Each 2 bits define a packet size for a
///< stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_2_BF_OFF ( 4)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_2_BF_WID ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_2_BF_MSK (0x00000030)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_2_BF_DEF (0x00000020)

///< Packet Size for Rx Stream. Each 2 bits define a packet size for a
///< stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_3_BF_OFF ( 6)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_3_BF_WID ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_3_BF_MSK (0x000000C0)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_RX_PKT_SZ_STRM_3_BF_DEF (0x00000080)

///< Packet Size for PDPD Stream. Each 2 bits define a packet size for
///< a stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_0_BF_OFF (16)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_0_BF_WID ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_0_BF_MSK (0x00030000)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_0_BF_DEF (0x00020000)

///< Packet Size for PDPD Stream. Each 2 bits define a packet size for
///< a stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_1_BF_OFF (18)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_1_BF_WID ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_1_BF_MSK (0x000C0000)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_1_BF_DEF (0x00080000)

///< Packet Size for PDPD Stream. Each 2 bits define a packet size for
///< a stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_2_BF_OFF (20)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_2_BF_WID ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_2_BF_MSK (0x00300000)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_2_BF_DEF (0x00200000)

///< Packet Size for PDPD Stream. Each 2 bits define a packet size for
///< a stream. There are total 4 streams. The packet length equals to 2^pkt_sz[1:0].
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_3_BF_OFF (22)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_3_BF_WID ( 2)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_3_BF_MSK (0x00C00000)
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_PD_PKT_SZ_STRM_3_BF_DEF (0x00800000)


/** @brief AV2D_CSR_COM_REG_RX_CSR_RX_IN_SMPL_CNT[2] register description at address offset 0x68
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/RX_CSR/RX_IN_SMPL_CNT
  * Rx Ingress Sample Count
  */

typedef union {
  struct {
    uint32_t SAMPLE_COUNT : 24;
    ///< This is the value of the 24-bit counter on Rx ingress, DRF Sample
    ///< Interface or PDPD Egress Interface. It increments by 1 when a valid
    ///< 256-bit sample data is received.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_rx_csr_rx_in_smpl_cnt_reg_t;

#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_DEFAULT (0x00000000U)
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_RD_MASK (0x00ffffffU)
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_WR_MASK (0x00000000U)


///< This is the value of the 24-bit counter on Rx ingress, DRF Sample
///< Interface or PDPD Egress Interface. It increments by 1 when a valid
///< 256-bit sample data is received.
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_SAMPLE_CNT_BF_OFF ( 0)
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_SAMPLE_CNT_BF_WID (24)
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_SAMPLE_CNT_BF_MSK (0x00FFFFFF)
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_SAMPLE_CNT_BF_DEF (0x00000000)
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_ARR_SZ0 (2)
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_RX_CSR_RX_STREAM_CNT[4] register description at address offset 0x70
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/RX_CSR/RX_STREAM_CNT
  * Rx Stream Count
  */

typedef union {
  struct {
    uint32_t STREAM_CNT : 10;
    ///< Stream Count. This value is in flits and used to assign data from
    ///< DRF to VEX streams. It supports up to 1k 512-bit data flits. 0 means
    ///< 1 flit. The value should be multiple of packet size, 2^RX(PD)_PKT_SZ_Stream_N.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t STREAM_EN : 1;
    ///< Stream Enable. This value is used to enable the STREAM_CNT field.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_rx_csr_rx_strm_cnt_reg_t;

#define AV2D_CSR_RX_CSR_RX_STRM_CNT_DEFAULT (0x00000000U)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_RD_MASK (0x800003ffU)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_WR_MASK (0x800003ffU)


///< Stream Count. This value is in flits and used to assign data from
///< DRF to VEX streams. It supports up to 1k 512-bit data flits. 0 means
///< 1 flit. The value should be multiple of packet size, 2^RX(PD)_PKT_SZ_Stream_N.
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_STRM_CNT_BF_OFF ( 0)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_STRM_CNT_BF_WID (10)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_STRM_CNT_BF_MSK (0x000003FF)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_STRM_CNT_BF_DEF (0x00000000)

///< Stream Enable. This value is used to enable the STREAM_CNT field.
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_STRM_EN_BF_OFF (31)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_STRM_EN_BF_WID ( 1)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_STRM_EN_BF_MSK (0x80000000)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_STRM_EN_BF_DEF (0x00000000)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_ARR_SZ0 (4)
#define AV2D_CSR_RX_CSR_RX_STRM_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_RX_CSR_RX_PD_STREAM_CNT[5] register description at address offset 0x80
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/RX_CSR/RX_PD_STREAM_CNT
  * Rx PDPD Main Stream Count
  */

typedef union {
  struct {
    uint32_t STREAM_CNT : 10;
    ///< Stream Count. This value is used to read data flits out of Tx Buffer.
    ///< It supports up to 1k 512-bit data flits. 0 means 1 flit.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t STREAM_EN : 1;
    ///< Stream Enable. This value is used to enable the STREAM_CNT field.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_rx_csr_rx_pd_strm_cnt_reg_t;

#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_DEFAULT (0x00000000U)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_RD_MASK (0x800003ffU)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_WR_MASK (0x800003ffU)


///< Stream Count. This value is used to read data flits out of Tx Buffer.
///< It supports up to 1k 512-bit data flits. 0 means 1 flit.
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_STRM_CNT_BF_OFF ( 0)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_STRM_CNT_BF_WID (10)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_STRM_CNT_BF_MSK (0x000003FF)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_STRM_CNT_BF_DEF (0x00000000)

///< Stream Enable. This value is used to enable the STREAM_CNT field.
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_STRM_EN_BF_OFF (31)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_STRM_EN_BF_WID ( 1)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_STRM_EN_BF_MSK (0x80000000)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_STRM_EN_BF_DEF (0x00000000)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_ARR_SZ0 (5)
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_PIF_CTRL register description at address offset 0x94
  *
  * Register default value:        0xFFFF0000
  * Register full path in IP: av2d_csr_com/reg/PIF_CTRL
  * PDPD Interface Control Register
  */

typedef union {
  struct {
    uint32_t PD_IN_SYS_RATE : 3;
    ///< PDPD Ingress Sampling Rate. This field controls PDPD sampling rate
    ///< on input of PDPD. This control affects data pattern on PDPD B Interfaces.
    ///< The described sampling rates N/M are based on clock rates 983MHz/1.475GHz.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
    uint32_t PD_OUT_SYS_RATE : 3;
    ///< PDPD Egress Sampling Rate. This field controls PDPD sampling rate
    ///< on output of PDPD. This control affects data pattern on PDPD C Interface
    ///< and PDPD output. The described sampling rates N/M are based on clock
    ///< rates 983MHz/1.475GHz.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 1;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
    uint32_t PD_GANG_MODE : 1;
    ///< PDPD Ganging Mode. When set, this field informs PDPD logic to be in
    ///< ganging mode, in this case, odd numbered channel uses main data from
    ///< even numbered channel.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t PD_CAP_MEM_SEL : 2;
    ///< PDPD Capture Memory Source Select. This bit selects the data source
    ///< going to Capture Memory.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t PD_EXTRA_ONLY : 1;
    ///< PDPD Extra Term Only. This bit enables the mode which has only extra
    ///< term traffic, C path, and there is no main term traffic, B path.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t PC_LUT_MODE : 2;
    ///< PDPD Coefficient Update LUT Mode. This field controls the number of
    ///< Look-Up Tables in PDPD coefficient update Mode 1 data.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="14" ResetValue="None"
    uint32_t PC_TIMEOUT_CNT : 16;
    ///< PDPD Coefficient Update Timeout Value. This is the count value to
    ///< timeout HBI and AXI data transfers for PDPD Coefficient update.
    ///< AccessType="RW" BitOffset="16" ResetValue="0xFFFF"
  } ;
  uint32_t value;
} av2d_csr_pif_ctrl_reg_t;

#define AV2D_CSR_PIF_CTRL_DEFAULT (0xffff0000U)
#define AV2D_CSR_PIF_CTRL_RD_MASK (0xffff3f77U)
#define AV2D_CSR_PIF_CTRL_WR_MASK (0xffff3f77U)


///< PDPD Ingress Sampling Rate. This field controls PDPD sampling rate
///< on input of PDPD. This control affects data pattern on PDPD B Interfaces.
///< The described sampling rates N/M are based on clock rates 983MHz/1.475GHz.
#define AV2D_CSR_PIF_CTRL_PD_IN_SYS_RATE_BF_OFF ( 0)
#define AV2D_CSR_PIF_CTRL_PD_IN_SYS_RATE_BF_WID ( 3)
#define AV2D_CSR_PIF_CTRL_PD_IN_SYS_RATE_BF_MSK (0x00000007)
#define AV2D_CSR_PIF_CTRL_PD_IN_SYS_RATE_BF_DEF (0x00000000)

///< PDPD Egress Sampling Rate. This field controls PDPD sampling rate
///< on output of PDPD. This control affects data pattern on PDPD C Interface
///< and PDPD output. The described sampling rates N/M are based on clock
///< rates 983MHz/1.475GHz.
#define AV2D_CSR_PIF_CTRL_PD_OUT_SYS_RATE_BF_OFF ( 4)
#define AV2D_CSR_PIF_CTRL_PD_OUT_SYS_RATE_BF_WID ( 3)
#define AV2D_CSR_PIF_CTRL_PD_OUT_SYS_RATE_BF_MSK (0x00000070)
#define AV2D_CSR_PIF_CTRL_PD_OUT_SYS_RATE_BF_DEF (0x00000000)

///< PDPD Ganging Mode. When set, this field informs PDPD logic to be in
///< ganging mode, in this case, odd numbered channel uses main data from
///< even numbered channel.
#define AV2D_CSR_PIF_CTRL_PD_GANG_MODE_BF_OFF ( 8)
#define AV2D_CSR_PIF_CTRL_PD_GANG_MODE_BF_WID ( 1)
#define AV2D_CSR_PIF_CTRL_PD_GANG_MODE_BF_MSK (0x00000100)
#define AV2D_CSR_PIF_CTRL_PD_GANG_MODE_BF_DEF (0x00000000)

///< PDPD Capture Memory Source Select. This bit selects the data source
///< going to Capture Memory.
#define AV2D_CSR_PIF_CTRL_PD_CAP_MEM_SEL_BF_OFF ( 9)
#define AV2D_CSR_PIF_CTRL_PD_CAP_MEM_SEL_BF_WID ( 2)
#define AV2D_CSR_PIF_CTRL_PD_CAP_MEM_SEL_BF_MSK (0x00000600)
#define AV2D_CSR_PIF_CTRL_PD_CAP_MEM_SEL_BF_DEF (0x00000000)

///< PDPD Extra Term Only. This bit enables the mode which has only extra
///< term traffic, C path, and there is no main term traffic, B path.
#define AV2D_CSR_PIF_CTRL_PD_EXTRA_ONLY_BF_OFF (11)
#define AV2D_CSR_PIF_CTRL_PD_EXTRA_ONLY_BF_WID ( 1)
#define AV2D_CSR_PIF_CTRL_PD_EXTRA_ONLY_BF_MSK (0x00000800)
#define AV2D_CSR_PIF_CTRL_PD_EXTRA_ONLY_BF_DEF (0x00000000)

///< PDPD Coefficient Update LUT Mode. This field controls the number of
///< Look-Up Tables in PDPD coefficient update Mode 1 data.
#define AV2D_CSR_PIF_CTRL_PC_LUT_MODE_BF_OFF (12)
#define AV2D_CSR_PIF_CTRL_PC_LUT_MODE_BF_WID ( 2)
#define AV2D_CSR_PIF_CTRL_PC_LUT_MODE_BF_MSK (0x00003000)
#define AV2D_CSR_PIF_CTRL_PC_LUT_MODE_BF_DEF (0x00000000)

///< PDPD Coefficient Update Timeout Value. This is the count value to
///< timeout HBI and AXI data transfers for PDPD Coefficient update.
#define AV2D_CSR_PIF_CTRL_PC_TIMEOUT_CNT_BF_OFF (16)
#define AV2D_CSR_PIF_CTRL_PC_TIMEOUT_CNT_BF_WID (16)
#define AV2D_CSR_PIF_CTRL_PC_TIMEOUT_CNT_BF_MSK (0xFFFF0000)
#define AV2D_CSR_PIF_CTRL_PC_TIMEOUT_CNT_BF_DEF (0xFFFF0000)


/** @brief AV2D_CSR_COM_REG_TX_BUF_WM_TX_BUF_WM_START[4] register description at address offset 0xa0
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_BUF_WM/TX_BUF_WM_START
  * Tx Buffer Partition Watermarks at Start
  */

typedef union {
  struct {
    uint32_t PARTITION_M_WM : 12;
    ///< Partition M Watermark. Maximum value is 0x800 for 2k in flits. M =
    ///< 0, 2, 4, 6 in 4 registers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t PARTITION_N_WM : 12;
    ///< Partition N Watermark. Maximum value is 0x800 for 2k in flits. N =
    ///< 1, 3, 5, 7 in 4 registers.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_buf_wm_tx_buf_wm_start_reg_t;

#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_RD_MASK (0x0fff0fffU)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_WR_MASK (0x00000000U)


///< Partition M Watermark. Maximum value is 0x800 for 2k in flits. M =
///< 0, 2, 4, 6 in 4 registers.
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_PARTITION_M_WM_BF_OFF ( 0)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_PARTITION_M_WM_BF_WID (12)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_PARTITION_M_WM_BF_MSK (0x00000FFF)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_PARTITION_M_WM_BF_DEF (0x00000000)

///< Partition N Watermark. Maximum value is 0x800 for 2k in flits. N =
///< 1, 3, 5, 7 in 4 registers.
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_PARTITION_N_WM_BF_OFF (16)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_PARTITION_N_WM_BF_WID (12)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_PARTITION_N_WM_BF_MSK (0x0FFF0000)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_PARTITION_N_WM_BF_DEF (0x00000000)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_ARR_SZ0 (4)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_TX_BUF_WM_TX_BUF_WM_HILO[8] register description at address offset 0xb0
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_BUF_WM/TX_BUF_WM_HILO
  * Tx Buffer Partition Highest/Lowest Watermarks
  */

typedef union {
  struct {
    uint32_t PARTITION_M_WM_LO : 12;
    ///< Partition M Lowest Watermark after start. Minimum value could be 0
    ///< in flits. M = 0, 1, ..., 6, 7 in 8 registers.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t PARTITION_M_WM_HI : 12;
    ///< Partition M Highest Watermark after start. Maximum value is 0x800
    ///< for 2k in flits. M = 0, 1, ..., 6, 7 in 8 registers.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t;

#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_RD_MASK (0x0fff0fffU)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_WR_MASK (0x00000000U)


///< Partition M Lowest Watermark after start. Minimum value could be 0
///< in flits. M = 0, 1, ..., 6, 7 in 8 registers.
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_PARTITION_M_WM_LO_BF_OFF ( 0)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_PARTITION_M_WM_LO_BF_WID (12)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_PARTITION_M_WM_LO_BF_MSK (0x00000FFF)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_PARTITION_M_WM_LO_BF_DEF (0x00000000)

///< Partition M Highest Watermark after start. Maximum value is 0x800
///< for 2k in flits. M = 0, 1, ..., 6, 7 in 8 registers.
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_PARTITION_M_WM_HI_BF_OFF (16)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_PARTITION_M_WM_HI_BF_WID (12)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_PARTITION_M_WM_HI_BF_MSK (0x0FFF0000)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_PARTITION_M_WM_HI_BF_DEF (0x00000000)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_ARR_SZ0 (8)
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO_ARRAY_STRIDE0 (0x0004)


/** @brief AV2D_CSR_COM_REG_TX_BUF_WM_TX_START_WM register description at address offset 0xd0
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_BUF_WM/TX_START_WM
  * Tx Start On Watermark
  */

typedef union {
  struct {
    uint32_t START_AC_WATERMARK : 12;
    ///< Start Watermark for A/C Path. If enabled by START_AC_WM_EN, this value
    ///< will be compared with A/C path first enabled Stream's filling watermark
    ///< in Tx Buffers. If there is a match, Tx A path DigRF or PDPD C path
    ///< only transmission will start. Maximum value is 0x800 for 2k in flits.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="12" ResetValue="None"
    uint32_t START_AC_WM_EN : 1;
    ///< Start On Watermark Enable for A/C Path. When set, BFN/JESD controlled
    ///< starts will be ignored and when filling watermark in Tx Buffer for
    ///< A/C path first enabled Stream matches with START_AC_WATERMARK, Tx
    ///< A path DigRF or PDPD C path only sampling data transmission will start.
    ///< After setting this bit to high, software should not clear this bit.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t START_B_WATERMARK : 12;
    ///< Start Watermark for B Path. If enabled by START_B_WM_EN, this value
    ///< will be compared with B path first enabled Stream's filling watermark
    ///< in Tx Buffers. If there is a match, PDPD B or B+C path transmission
    ///< will start. Maximum value is 0x800 for 2k in flits.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t  : 3;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
    uint32_t START_B_WM_EN : 1;
    ///< Start On Watermark Enable for B Path. When set, BFN/JESD controlled
    ///< starts will be ignored and when filling watermark in Tx Buffer for
    ///< B path first enabled Stream matches with START_B_WATERMARK, PDPD B
    ///< or B+C path sampling data transmission will start. After setting this
    ///< bit to high, software should not clear this bit.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_tx_buf_wm_tx_start_wm_reg_t;

#define AV2D_CSR_TX_BUF_WM_TX_START_WM_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_RD_MASK (0x8fff8fffU)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_WR_MASK (0x8fff8fffU)


///< Start Watermark for A/C Path. If enabled by START_AC_WM_EN, this value
///< will be compared with A/C path first enabled Stream's filling watermark
///< in Tx Buffers. If there is a match, Tx A path DigRF or PDPD C path
///< only transmission will start. Maximum value is 0x800 for 2k in flits.
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_AC_WATERMARK_BF_OFF ( 0)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_AC_WATERMARK_BF_WID (12)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_AC_WATERMARK_BF_MSK (0x00000FFF)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_AC_WATERMARK_BF_DEF (0x00000000)

///< Start On Watermark Enable for A/C Path. When set, BFN/JESD controlled
///< starts will be ignored and when filling watermark in Tx Buffer for
///< A/C path first enabled Stream matches with START_AC_WATERMARK, Tx
///< A path DigRF or PDPD C path only sampling data transmission will start.
///< After setting this bit to high, software should not clear this bit.
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_AC_WM_EN_BF_OFF (15)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_AC_WM_EN_BF_WID ( 1)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_AC_WM_EN_BF_MSK (0x00008000)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_AC_WM_EN_BF_DEF (0x00000000)

///< Start Watermark for B Path. If enabled by START_B_WM_EN, this value
///< will be compared with B path first enabled Stream's filling watermark
///< in Tx Buffers. If there is a match, PDPD B or B+C path transmission
///< will start. Maximum value is 0x800 for 2k in flits.
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_B_WATERMARK_BF_OFF (16)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_B_WATERMARK_BF_WID (12)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_B_WATERMARK_BF_MSK (0x0FFF0000)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_B_WATERMARK_BF_DEF (0x00000000)

///< Start On Watermark Enable for B Path. When set, BFN/JESD controlled
///< starts will be ignored and when filling watermark in Tx Buffer for
///< B path first enabled Stream matches with START_B_WATERMARK, PDPD B
///< or B+C path sampling data transmission will start. After setting this
///< bit to high, software should not clear this bit.
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_B_WM_EN_BF_OFF (31)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_B_WM_EN_BF_WID ( 1)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_B_WM_EN_BF_MSK (0x80000000)
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_START_B_WM_EN_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_INT_CSR_INT_STATUS register description at address offset 0xe0
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/INT_CSR/INT_STATUS
  * ABC V2D Interrupt Status Register
  */

typedef union {
  struct {
    uint32_t TX_BUF_0_ECC_SBE : 1;
    ///< Tx Buffer 0 ECC Single Bit Error. This bit indicates that an ECC single-bit
    ///< error was detected when reading the Tx Buffer 0. This is the OR'ed
    ///< version of register bits TX_BUF_ECC_ERR_STAT[0].ECC_SBE.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t TX_BUF_0_ECC_DBE : 1;
    ///< Tx Buffer 0 ECC Double/Multi Bit Error. This bit indicates that an
    ///< ECC double/multi-bit error was detected when reading the Tx Buffer
    ///< 0. This is the OR'ed version of register bits TX_BUF_ECC_ERR_STAT[0].ECC_DBE.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t TX_BUF_1_ECC_SBE : 1;
    ///< Tx Buffer 1 ECC Single Bit Error. This bit indicates that an ECC single-bit
    ///< error was detected when reading the Tx Buffer 1. This is the OR'ed
    ///< version of register bits TX_BUF_ECC_ERR_STAT[1].ECC_SBE.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x0"
    uint32_t TX_BUF_1_ECC_DBE : 1;
    ///< Tx Buffer 1 ECC Double/Multi Bit Error. This bit indicates that an
    ///< ECC double/multi-bit error was detected when reading the Tx Buffer
    ///< 1. This is the OR'ed version of register bits TX_BUF_ECC_ERR_STAT[1].ECC_DBE.
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x0"
    uint32_t TX_BUF_0_ECC_SBE_CNT_OVFL : 1;
    ///< Tx Buffer 0 ECC SBE Count Overflow. This bit indicates that an ECC
    ///< SBE count overflow happened for Tx Buffer 0. This is the OR'ed version
    ///< of register bits TX_BUF_ECC_ERR_STAT[0].ECC_SBE_CNT_OVFL.
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t TX_BUF_1_ECC_SBE_CNT_OVFL : 1;
    ///< Tx Buffer 1 ECC SBE Count Overflow. This bit indicates that an ECC
    ///< SBE count overflow happened for Tx Buffer 1. This is the OR'ed version
    ///< of register bits TX_BUF_ECC_ERR_STAT[1].ECC_SBE_CNT_OVFL.
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t PD_MAIN_NODATA_START : 1;
    ///< PDPD Main No Data Start. This bit indicates that PDPD main data (B
    ///< path) are not available when start transmission signal asserts.
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t PD_EXTRA_NODATA_START : 1;
    ///< PDPD Extra No Data Start. This bit indicates that PDPD extra data
    ///< (C path) are not available when start transmission signal asserts.
    ///< AccessType="RO/V" BitOffset="7" ResetValue="0x0"
    uint32_t RX_HBI_0_OVFL_DROP : 1;
    ///< Rx HBI 0 Overflow Drop. This bit indicates that a data is dropped
    ///< at Rx HBI 0 interface due to nsip_hbi backpressure.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t RX_HBI_1_OVFL_DROP : 1;
    ///< Rx HBI 1 Overflow Drop. This bit indicates that a data is dropped
    ///< at Rx HBI 1 interface due to nsip_hbi backpressure.
    ///< AccessType="RO/V" BitOffset="9" ResetValue="0x0"
    uint32_t RX_0_NOCFG_DROP : 1;
    ///< Rx 0 No Cfg Drop. This bit indicates that a data is dropped at Rx
    ///< 0 ingress due to no stream counter is enabled.
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t RX_1_NOCFG_DROP : 1;
    ///< Rx 1 No Cfg Drop. This bit indicates that a data is dropped at Rx
    ///< 1 ingress due to no stream counter is enabled.
    ///< AccessType="RO/V" BitOffset="11" ResetValue="0x0"
    uint32_t TX_UNDERRUN : 1;
    ///< Tx Underrun. This bit indicates that Tx data from VEX Array(A path)
    ///< are not available during transmitting to DRF.
    ///< AccessType="RO/V" BitOffset="12" ResetValue="0x0"
    uint32_t TX_NODATA_START : 1;
    ///< Tx No Data Start. This bit indicates that Tx data (A path) are not
    ///< available when start transmission signal asserts.
    ///< AccessType="RO/V" BitOffset="13" ResetValue="0x0"
    uint32_t SMON_INTR : 1;
    ///< SMON Interrupt. This bit shows the value of abc_v2d's AW_smon interrupt
    ///< output.
    ///< AccessType="RO/V" BitOffset="14" ResetValue="0x0"
    uint32_t PC_HBI_AXI : 1;
    ///< PDPD Coefficient Update AXI Collide with HBI.
    ///< AccessType="RO/V" BitOffset="15" ResetValue="0x0"
    uint32_t TX_HBI_0_NOCFG_DROP : 1;
    ///< Tx HBI 0 No-Config Data Drop. This bit indicates that a data from
    ///< nsip_hbi 0 was dropped due to that the data stream is not enabled.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t TX_HBI_1_NOCFG_DROP : 1;
    ///< Tx HBI 1 No-Config Data Drop. This bit indicates that a data from
    ///< nsip_hbi 1 was dropped due to that the data stream is not enabled.
    ///< AccessType="RO/V" BitOffset="17" ResetValue="0x0"
    uint32_t PD_MAIN_UNDERRUN : 1;
    ///< PDPD Main Data Underrun. This bit indicates that PDPD main data are
    ///< not available during transmitting to PDPD.
    ///< AccessType="RO/V" BitOffset="18" ResetValue="0x0"
    uint32_t PD_EXTRA_UNDERRUN : 1;
    ///< PDPD Extra Data Underrun. This bit indicates that PDPD extra term
    ///< data are not available during transmitting to PDPD.
    ///< AccessType="RO/V" BitOffset="19" ResetValue="0x0"
    uint32_t PC_HBI_DROP : 1;
    ///< PDPD Coefficient Update Data Drop on HBI.
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t PC_HBI_TIMEOUT : 1;
    ///< PDPD Coefficient Update Timeout on HBI.
    ///< AccessType="RO/V" BitOffset="21" ResetValue="0x0"
    uint32_t PC_HBI_M2_IN_M1 : 1;
    ///< PDPD Coefficient Update M2 Data Seen in M1 Data Set Error on HBI.
    ///< AccessType="RO/V" BitOffset="22" ResetValue="0x0"
    uint32_t PC_AXI_TIMEOUT : 1;
    ///< PDPD Coefficient Update Timeout on AXI.
    ///< AccessType="RO/V" BitOffset="23" ResetValue="0x0"
    uint32_t PC_AXI_SIZE_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Size Error.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint32_t PC_AXI_STROBE_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Strobe Error.
    ///< AccessType="RO/V" BitOffset="25" ResetValue="0x0"
    uint32_t PC_AXI_LENGTH_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Length Error.
    ///< AccessType="RO/V" BitOffset="26" ResetValue="0x0"
    uint32_t PC_AXI_ERR_DROP : 1;
    ///< PDPD Coefficient Update Data Drop on AXI Write Start Error. This indicates
    ///< AXI write had an unexpected address for starting coefficient update.
    ///< AccessType="RO/V" BitOffset="27" ResetValue="0x0"
    uint32_t PC_AXI_READ_ERR : 1;
    ///< PDPD Coefficient Update AXI Read Error.
    ///< AccessType="RO/V" BitOffset="28" ResetValue="0x0"
    uint32_t PC_UPDATE_ERR : 1;
    ///< PDPD Coefficient Update Error. This is the error signal sent to PDPD
    ///< with last signal.
    ///< AccessType="RO/V" BitOffset="29" ResetValue="0x0"
    uint32_t CMEM_OVLP_CHNL_ERR : 1;
    ///< Capture Memory Channel Data Select Overlap Error. This error indicates
    ///< Capture Memory Data selects between the two data channels have overlap.
    ///< AccessType="RO/V" BitOffset="30" ResetValue="0x0"
    uint32_t CMEM_OVLP_V2D_ERR : 1;
    ///< Capture Memory V2D Data Select Overlap Error. This error indicates
    ///< Capture Memory Data selects between this channel and the odd V2D have
    ///< overlap.
    ///< AccessType="RO/V" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_int_csr_int_stat_reg_t;

#define AV2D_CSR_INT_CSR_INT_STAT_DEFAULT (0x00000000U)
#define AV2D_CSR_INT_CSR_INT_STAT_RD_MASK (0xffffffffU)
#define AV2D_CSR_INT_CSR_INT_STAT_WR_MASK (0x00000000U)


///< Tx Buffer 0 ECC Single Bit Error. This bit indicates that an ECC single-bit
///< error was detected when reading the Tx Buffer 0. This is the OR'ed
///< version of register bits TX_BUF_ECC_ERR_STAT[0].ECC_SBE.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_SBE_BF_OFF ( 0)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_SBE_BF_MSK (0x00000001)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_SBE_BF_DEF (0x00000000)

///< Tx Buffer 0 ECC Double/Multi Bit Error. This bit indicates that an
///< ECC double/multi-bit error was detected when reading the Tx Buffer
///< 0. This is the OR'ed version of register bits TX_BUF_ECC_ERR_STAT[0].ECC_DBE.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_DBE_BF_OFF ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_DBE_BF_MSK (0x00000002)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_DBE_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC Single Bit Error. This bit indicates that an ECC single-bit
///< error was detected when reading the Tx Buffer 1. This is the OR'ed
///< version of register bits TX_BUF_ECC_ERR_STAT[1].ECC_SBE.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_SBE_BF_OFF ( 2)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_SBE_BF_MSK (0x00000004)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_SBE_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC Double/Multi Bit Error. This bit indicates that an
///< ECC double/multi-bit error was detected when reading the Tx Buffer
///< 1. This is the OR'ed version of register bits TX_BUF_ECC_ERR_STAT[1].ECC_DBE.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_DBE_BF_OFF ( 3)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_DBE_BF_MSK (0x00000008)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_DBE_BF_DEF (0x00000000)

///< Tx Buffer 0 ECC SBE Count Overflow. This bit indicates that an ECC
///< SBE count overflow happened for Tx Buffer 0. This is the OR'ed version
///< of register bits TX_BUF_ECC_ERR_STAT[0].ECC_SBE_CNT_OVFL.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_OFF ( 4)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_MSK (0x00000010)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC SBE Count Overflow. This bit indicates that an ECC
///< SBE count overflow happened for Tx Buffer 1. This is the OR'ed version
///< of register bits TX_BUF_ECC_ERR_STAT[1].ECC_SBE_CNT_OVFL.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< PDPD Main No Data Start. This bit indicates that PDPD main data (B
///< path) are not available when start transmission signal asserts.
#define AV2D_CSR_INT_CSR_INT_STAT_PD_MAIN_NODATA_START_BF_OFF ( 6)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_MAIN_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_MAIN_NODATA_START_BF_MSK (0x00000040)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_MAIN_NODATA_START_BF_DEF (0x00000000)

///< PDPD Extra No Data Start. This bit indicates that PDPD extra data
///< (C path) are not available when start transmission signal asserts.
#define AV2D_CSR_INT_CSR_INT_STAT_PD_EXTRA_NODATA_START_BF_OFF ( 7)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_EXTRA_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_EXTRA_NODATA_START_BF_MSK (0x00000080)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_EXTRA_NODATA_START_BF_DEF (0x00000000)

///< Rx HBI 0 Overflow Drop. This bit indicates that a data is dropped
///< at Rx HBI 0 interface due to nsip_hbi backpressure.
#define AV2D_CSR_INT_CSR_INT_STAT_RX_HBI_0_OVFL_DROP_BF_OFF ( 8)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_HBI_0_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_HBI_0_OVFL_DROP_BF_MSK (0x00000100)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_HBI_0_OVFL_DROP_BF_DEF (0x00000000)

///< Rx HBI 1 Overflow Drop. This bit indicates that a data is dropped
///< at Rx HBI 1 interface due to nsip_hbi backpressure.
#define AV2D_CSR_INT_CSR_INT_STAT_RX_HBI_1_OVFL_DROP_BF_OFF ( 9)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_HBI_1_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_HBI_1_OVFL_DROP_BF_MSK (0x00000200)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_HBI_1_OVFL_DROP_BF_DEF (0x00000000)

///< Rx 0 No Cfg Drop. This bit indicates that a data is dropped at Rx
///< 0 ingress due to no stream counter is enabled.
#define AV2D_CSR_INT_CSR_INT_STAT_RX_0_NOCFG_DROP_BF_OFF (10)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_0_NOCFG_DROP_BF_MSK (0x00000400)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_0_NOCFG_DROP_BF_DEF (0x00000000)

///< Rx 1 No Cfg Drop. This bit indicates that a data is dropped at Rx
///< 1 ingress due to no stream counter is enabled.
#define AV2D_CSR_INT_CSR_INT_STAT_RX_1_NOCFG_DROP_BF_OFF (11)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_1_NOCFG_DROP_BF_MSK (0x00000800)
#define AV2D_CSR_INT_CSR_INT_STAT_RX_1_NOCFG_DROP_BF_DEF (0x00000000)

///< Tx Underrun. This bit indicates that Tx data from VEX Array(A path)
///< are not available during transmitting to DRF.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_UNDERRUN_BF_OFF (12)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_UNDERRUN_BF_MSK (0x00001000)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_UNDERRUN_BF_DEF (0x00000000)

///< Tx No Data Start. This bit indicates that Tx data (A path) are not
///< available when start transmission signal asserts.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_NODATA_START_BF_OFF (13)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_NODATA_START_BF_MSK (0x00002000)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_NODATA_START_BF_DEF (0x00000000)

///< SMON Interrupt. This bit shows the value of abc_v2d's AW_smon interrupt
///< output.
#define AV2D_CSR_INT_CSR_INT_STAT_SMON_INTR_BF_OFF (14)
#define AV2D_CSR_INT_CSR_INT_STAT_SMON_INTR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_SMON_INTR_BF_MSK (0x00004000)
#define AV2D_CSR_INT_CSR_INT_STAT_SMON_INTR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Collide with HBI.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_AXI_BF_OFF (15)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_AXI_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_AXI_BF_MSK (0x00008000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_AXI_BF_DEF (0x00000000)

///< Tx HBI 0 No-Config Data Drop. This bit indicates that a data from
///< nsip_hbi 0 was dropped due to that the data stream is not enabled.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_HBI_0_NOCFG_DROP_BF_OFF (16)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_HBI_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_HBI_0_NOCFG_DROP_BF_MSK (0x00010000)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_HBI_0_NOCFG_DROP_BF_DEF (0x00000000)

///< Tx HBI 1 No-Config Data Drop. This bit indicates that a data from
///< nsip_hbi 1 was dropped due to that the data stream is not enabled.
#define AV2D_CSR_INT_CSR_INT_STAT_TX_HBI_1_NOCFG_DROP_BF_OFF (17)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_HBI_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_HBI_1_NOCFG_DROP_BF_MSK (0x00020000)
#define AV2D_CSR_INT_CSR_INT_STAT_TX_HBI_1_NOCFG_DROP_BF_DEF (0x00000000)

///< PDPD Main Data Underrun. This bit indicates that PDPD main data are
///< not available during transmitting to PDPD.
#define AV2D_CSR_INT_CSR_INT_STAT_PD_MAIN_UNDERRUN_BF_OFF (18)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_MAIN_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_MAIN_UNDERRUN_BF_MSK (0x00040000)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_MAIN_UNDERRUN_BF_DEF (0x00000000)

///< PDPD Extra Data Underrun. This bit indicates that PDPD extra term
///< data are not available during transmitting to PDPD.
#define AV2D_CSR_INT_CSR_INT_STAT_PD_EXTRA_UNDERRUN_BF_OFF (19)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_EXTRA_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_EXTRA_UNDERRUN_BF_MSK (0x00080000)
#define AV2D_CSR_INT_CSR_INT_STAT_PD_EXTRA_UNDERRUN_BF_DEF (0x00000000)

///< PDPD Coefficient Update Data Drop on HBI.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_DROP_BF_OFF (20)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_DROP_BF_MSK (0x00100000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_DROP_BF_DEF (0x00000000)

///< PDPD Coefficient Update Timeout on HBI.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_TIMEOUT_BF_OFF (21)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_TIMEOUT_BF_MSK (0x00200000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_TIMEOUT_BF_DEF (0x00000000)

///< PDPD Coefficient Update M2 Data Seen in M1 Data Set Error on HBI.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_M2_IN_M1_BF_OFF (22)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_M2_IN_M1_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_M2_IN_M1_BF_MSK (0x00400000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_HBI_M2_IN_M1_BF_DEF (0x00000000)

///< PDPD Coefficient Update Timeout on AXI.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_TIMEOUT_BF_OFF (23)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_TIMEOUT_BF_MSK (0x00800000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_TIMEOUT_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Size Error.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_SIZE_ERR_BF_OFF (24)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_SIZE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_SIZE_ERR_BF_MSK (0x01000000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_SIZE_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Strobe Error.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_STROBE_ERR_BF_OFF (25)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_STROBE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_STROBE_ERR_BF_MSK (0x02000000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_STROBE_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Length Error.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_LENGTH_ERR_BF_OFF (26)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_LENGTH_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_LENGTH_ERR_BF_MSK (0x04000000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_LENGTH_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update Data Drop on AXI Write Start Error. This indicates
///< AXI write had an unexpected address for starting coefficient update.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_ERR_DROP_BF_OFF (27)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_ERR_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_ERR_DROP_BF_MSK (0x08000000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_ERR_DROP_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Read Error.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_READ_ERR_BF_OFF (28)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_READ_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_READ_ERR_BF_MSK (0x10000000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_AXI_READ_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update Error. This is the error signal sent to PDPD
///< with last signal.
#define AV2D_CSR_INT_CSR_INT_STAT_PC_UPDATE_ERR_BF_OFF (29)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_UPDATE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_UPDATE_ERR_BF_MSK (0x20000000)
#define AV2D_CSR_INT_CSR_INT_STAT_PC_UPDATE_ERR_BF_DEF (0x00000000)

///< Capture Memory Channel Data Select Overlap Error. This error indicates
///< Capture Memory Data selects between the two data channels have overlap.
#define AV2D_CSR_INT_CSR_INT_STAT_CMEM_OVLP_CHNL_ERR_BF_OFF (30)
#define AV2D_CSR_INT_CSR_INT_STAT_CMEM_OVLP_CHNL_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_CMEM_OVLP_CHNL_ERR_BF_MSK (0x40000000)
#define AV2D_CSR_INT_CSR_INT_STAT_CMEM_OVLP_CHNL_ERR_BF_DEF (0x00000000)

///< Capture Memory V2D Data Select Overlap Error. This error indicates
///< Capture Memory Data selects between this channel and the odd V2D have
///< overlap.
#define AV2D_CSR_INT_CSR_INT_STAT_CMEM_OVLP_V2D_ERR_BF_OFF (31)
#define AV2D_CSR_INT_CSR_INT_STAT_CMEM_OVLP_V2D_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_STAT_CMEM_OVLP_V2D_ERR_BF_MSK (0x80000000)
#define AV2D_CSR_INT_CSR_INT_STAT_CMEM_OVLP_V2D_ERR_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_INT_CSR_INT_HIGH_EN register description at address offset 0xe4
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/INT_CSR/INT_HIGH_EN
  * ABC V2D High Priority Interrupt Enable Register
  */

typedef union {
  struct {
    uint32_t HIGH_EN_TX_BUF_0_ECC_SBE : 1;
    ///< High Enable for Tx Buffer 0 ECC Single-bit Error. This bit enables
    ///< TX_BUF_0_ECC_SBE in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t HIGH_EN_TX_BUF_0_ECC_DBE : 1;
    ///< High Enable for Tx Buffer 0 ECC Multi-bit Error. This bit enables
    ///< TX_BUF_0_ECC_DBE in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t HIGH_EN_TX_BUF_1_ECC_SBE : 1;
    ///< High Enable for Tx Buffer 1 ECC Single-bit Error. This bit enables
    ///< TX_BUF_1_ECC_SBE in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t HIGH_EN_TX_BUF_1_ECC_DBE : 1;
    ///< High Enable for Tx Buffer 1 ECC Multi-bit Error. This bit enables
    ///< TX_BUF_1_ECC_DBE in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t HIGH_EN_TX_BUF_0_ECC_SBE_CNT_OVFL : 1;
    ///< High Enable for Tx Buffer 0 ECC SBE Count Overflow. This bit enables
    ///< TX_BUF_0_ECC_SBE_CNT_OVFL in INT_STATUS register for high priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t HIGH_EN_TX_BUF_1_ECC_SBE_CNT_OVFL : 1;
    ///< High Enable for Tx Buffer 1 ECC SBE Count Overflow. This bit enables
    ///< TX_BUF_1_ECC_SBE_CNT_OVFL in INT_STATUS register for high priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t HIGH_EN_PD_MAIN_NODATA_START : 1;
    ///< High Enable for PDPD Main No Data Start. This bit enables PD_MAIN_NODATA_START
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t HIGH_EN_PD_EXTRA_NODATA_START : 1;
    ///< High Enable for PDPD Extra No Data Start. This bit enables PD_EXTRA_NODATA_START
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t HIGH_EN_RX_HBI_0_OVFL_DROP : 1;
    ///< High Enable for Rx HBI 0 Overflow Drop. This bit enables RX_HBI_0_OVFL_DROP
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t HIGH_EN_RX_HBI_1_OVFL_DROP : 1;
    ///< High Enable for Rx HBI 1 Overflow Drop. This bit enables RX_HBI_1_OVFL_DROP
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t HIGH_EN_RX_0_NOCFG_DROP : 1;
    ///< High Enable for Rx 0 No Cfg Drop. This bit enables RX_0_NOCFG_DROP
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t HIGH_EN_RX_1_NOCFG_DROP : 1;
    ///< High Enable for Rx 1 No Cfg Drop. This bit enables RX_1_NOCFG_DROP
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t HIGH_EN_TX_UNDERRUN : 1;
    ///< High Enable for Tx Underrun. This bit enables TX_UNDERRUN in INT_STATUS
    ///< register for high priority interrupt.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t HIGH_EN_TX_NODATA_START : 1;
    ///< High Enable for Tx No Data Start. This bit enables TX_NODATA_START
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t HIGH_EN_SMON_INTR : 1;
    ///< High Enable for SMON Interrupt. This bit enables SMON_INTR in INT_STATUS
    ///< register for high priority interrupt.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t HIGH_EN_PC_HBI_AXI : 1;
    ///< High Enable for PDPD Coefficient Update AXI Collide with HBI. This
    ///< bit enables PC_HBI_AXI in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t HIGH_EN_TX_HBI_0_NOCFG_DROP : 1;
    ///< High Enable for Tx HBI 0 No-Config Data Drop. This bit enables TX_HBI_0_NOCFG_DROP
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t HIGH_EN_TX_HBI_1_NOCFG_DROP : 1;
    ///< High Enable for Tx HBI 1 No-Config Data Drop. This bit enables TX_HBI_1_NOCFG_DROP
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t HIGH_EN_PD_MAIN_UNDERRUN : 1;
    ///< High Enable for PDPD Main Data Underrun. This bit enables PD_MAIN_UNDERRUN
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t HIGH_EN_PD_EXTRA_UNDERRUN : 1;
    ///< High Enable for PDPD Extra Data Underrun. This bit enables PD_EXTRA_UNDERRUN
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t HIGH_EN_PC_HBI_DROP : 1;
    ///< High Enable for PDPD Coefficient Update Data Drop on HBI. This bit
    ///< enables PC_HBI_DROP in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t HIGH_EN_PC_HBI_TIMEOUT : 1;
    ///< High Enable for PDPD Coefficient Update Timeout on HBI. This bit enables
    ///< PC_HBI_TIMEOUT in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t HIGH_EN_PC_HBI_M2_IN_M1 : 1;
    ///< High Enable for PDPD Coefficient Update M2 in M1 on HBI. This bit
    ///< enables PC_HBI_M2_IN_M1 in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t HIGH_EN_PC_AXI_TIMEOUT : 1;
    ///< High Enable for PDPD Coefficient Update Timeout on AXI. This bit enables
    ///< PC_AXI_TIMEOUT in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t HIGH_EN_PC_AXI_SIZE_ERR : 1;
    ///< High Enable for PDPD Coefficient Update AXI Write Size Error. This
    ///< bit enables PC_AXI_SIZE_ERR in INT_STATUS register for high priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t HIGH_EN_PC_AXI_STROBE_ERR : 1;
    ///< High Enable for PDPD Coefficient Update AXI Write Strobe Error. This
    ///< bit enables PC_AXI_STROBE_ERR in INT_STATUS register for high priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t HIGH_EN_PC_AXI_LENGTH_ERR : 1;
    ///< High Enable for PDPD Coefficient Update AXI Write Length Error. This
    ///< bit enables PC_AXI_LENGTH_ERR in INT_STATUS register for high priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t HIGH_EN_PC_AXI_ERR_DROP : 1;
    ///< High Enable for PDPD Coefficient Update Data Drop on AXI Write Start
    ///< Error. This bit enables PC_AXI_ERR_DROP in INT_STATUS register for
    ///< high priority interrupt.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t HIGH_EN_PC_AXI_READ_ERR : 1;
    ///< High Enable for PDPD Coefficient Update AXI Read Error. This bit enables
    ///< PC_AXI_READ_ERR in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t HIGH_EN_PC_UPDATE_ERR : 1;
    ///< High Enable for PDPD Coefficient Update Error. This bit enables PC_UPDATE_ERR
    ///< in INT_STATUS register for high priority interrupt.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t HIGH_EN_CMEM_OVLP_CHNL_ERR : 1;
    ///< High Enable for Capture Memory Channel Data Select Overlap Error.
    ///< This bit enables CMEM_OVLP_CHNL_ERR in INT_STATUS register for high
    ///< priority interrupt.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t HIGH_EN_CMEM_OVLP_V2D_ERR : 1;
    ///< High Enable for Capture Memory V2D Data Select Overlap Error. This
    ///< bit enables CMEM_OVLP_V2D_ERR in INT_STATUS register for high priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_int_csr_int_high_en_reg_t;

#define AV2D_CSR_INT_CSR_INT_HIGH_EN_DEFAULT (0x00000000U)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_RD_MASK (0xffffffffU)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_WR_MASK (0xffffffffU)


///< High Enable for Tx Buffer 0 ECC Single-bit Error. This bit enables
///< TX_BUF_0_ECC_SBE in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_SBE_BF_OFF ( 0)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_SBE_BF_MSK (0x00000001)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_SBE_BF_DEF (0x00000000)

///< High Enable for Tx Buffer 0 ECC Multi-bit Error. This bit enables
///< TX_BUF_0_ECC_DBE in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_DBE_BF_OFF ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_DBE_BF_MSK (0x00000002)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_DBE_BF_DEF (0x00000000)

///< High Enable for Tx Buffer 1 ECC Single-bit Error. This bit enables
///< TX_BUF_1_ECC_SBE in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_SBE_BF_OFF ( 2)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_SBE_BF_MSK (0x00000004)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_SBE_BF_DEF (0x00000000)

///< High Enable for Tx Buffer 1 ECC Multi-bit Error. This bit enables
///< TX_BUF_1_ECC_DBE in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_DBE_BF_OFF ( 3)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_DBE_BF_MSK (0x00000008)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_DBE_BF_DEF (0x00000000)

///< High Enable for Tx Buffer 0 ECC SBE Count Overflow. This bit enables
///< TX_BUF_0_ECC_SBE_CNT_OVFL in INT_STATUS register for high priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_OFF ( 4)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_MSK (0x00000010)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< High Enable for Tx Buffer 1 ECC SBE Count Overflow. This bit enables
///< TX_BUF_1_ECC_SBE_CNT_OVFL in INT_STATUS register for high priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< High Enable for PDPD Main No Data Start. This bit enables PD_MAIN_NODATA_START
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_MAIN_NODATA_START_BF_OFF ( 6)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_MAIN_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_MAIN_NODATA_START_BF_MSK (0x00000040)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_MAIN_NODATA_START_BF_DEF (0x00000000)

///< High Enable for PDPD Extra No Data Start. This bit enables PD_EXTRA_NODATA_START
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_EXTRA_NODATA_START_BF_OFF ( 7)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_EXTRA_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_EXTRA_NODATA_START_BF_MSK (0x00000080)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_EXTRA_NODATA_START_BF_DEF (0x00000000)

///< High Enable for Rx HBI 0 Overflow Drop. This bit enables RX_HBI_0_OVFL_DROP
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_HBI_0_OVFL_DROP_BF_OFF ( 8)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_HBI_0_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_HBI_0_OVFL_DROP_BF_MSK (0x00000100)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_HBI_0_OVFL_DROP_BF_DEF (0x00000000)

///< High Enable for Rx HBI 1 Overflow Drop. This bit enables RX_HBI_1_OVFL_DROP
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_HBI_1_OVFL_DROP_BF_OFF ( 9)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_HBI_1_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_HBI_1_OVFL_DROP_BF_MSK (0x00000200)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_HBI_1_OVFL_DROP_BF_DEF (0x00000000)

///< High Enable for Rx 0 No Cfg Drop. This bit enables RX_0_NOCFG_DROP
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_0_NOCFG_DROP_BF_OFF (10)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_0_NOCFG_DROP_BF_MSK (0x00000400)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_0_NOCFG_DROP_BF_DEF (0x00000000)

///< High Enable for Rx 1 No Cfg Drop. This bit enables RX_1_NOCFG_DROP
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_1_NOCFG_DROP_BF_OFF (11)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_1_NOCFG_DROP_BF_MSK (0x00000800)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_RX_1_NOCFG_DROP_BF_DEF (0x00000000)

///< High Enable for Tx Underrun. This bit enables TX_UNDERRUN in INT_STATUS
///< register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_UNDERRUN_BF_OFF (12)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_UNDERRUN_BF_MSK (0x00001000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_UNDERRUN_BF_DEF (0x00000000)

///< High Enable for Tx No Data Start. This bit enables TX_NODATA_START
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_NODATA_START_BF_OFF (13)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_NODATA_START_BF_MSK (0x00002000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_NODATA_START_BF_DEF (0x00000000)

///< High Enable for SMON Interrupt. This bit enables SMON_INTR in INT_STATUS
///< register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_SMON_INTR_BF_OFF (14)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_SMON_INTR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_SMON_INTR_BF_MSK (0x00004000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_SMON_INTR_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update AXI Collide with HBI. This
///< bit enables PC_HBI_AXI in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_AXI_BF_OFF (15)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_AXI_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_AXI_BF_MSK (0x00008000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_AXI_BF_DEF (0x00000000)

///< High Enable for Tx HBI 0 No-Config Data Drop. This bit enables TX_HBI_0_NOCFG_DROP
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_HBI_0_NOCFG_DROP_BF_OFF (16)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_HBI_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_HBI_0_NOCFG_DROP_BF_MSK (0x00010000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_HBI_0_NOCFG_DROP_BF_DEF (0x00000000)

///< High Enable for Tx HBI 1 No-Config Data Drop. This bit enables TX_HBI_1_NOCFG_DROP
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_HBI_1_NOCFG_DROP_BF_OFF (17)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_HBI_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_HBI_1_NOCFG_DROP_BF_MSK (0x00020000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_TX_HBI_1_NOCFG_DROP_BF_DEF (0x00000000)

///< High Enable for PDPD Main Data Underrun. This bit enables PD_MAIN_UNDERRUN
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_MAIN_UNDERRUN_BF_OFF (18)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_MAIN_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_MAIN_UNDERRUN_BF_MSK (0x00040000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_MAIN_UNDERRUN_BF_DEF (0x00000000)

///< High Enable for PDPD Extra Data Underrun. This bit enables PD_EXTRA_UNDERRUN
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_EXTRA_UNDERRUN_BF_OFF (19)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_EXTRA_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_EXTRA_UNDERRUN_BF_MSK (0x00080000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PD_EXTRA_UNDERRUN_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update Data Drop on HBI. This bit
///< enables PC_HBI_DROP in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_DROP_BF_OFF (20)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_DROP_BF_MSK (0x00100000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_DROP_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update Timeout on HBI. This bit enables
///< PC_HBI_TIMEOUT in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_TIMEOUT_BF_OFF (21)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_TIMEOUT_BF_MSK (0x00200000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_TIMEOUT_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update M2 in M1 on HBI. This bit
///< enables PC_HBI_M2_IN_M1 in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_M2_IN_M1_BF_OFF (22)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_M2_IN_M1_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_M2_IN_M1_BF_MSK (0x00400000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_HBI_M2_IN_M1_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update Timeout on AXI. This bit enables
///< PC_AXI_TIMEOUT in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_TIMEOUT_BF_OFF (23)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_TIMEOUT_BF_MSK (0x00800000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_TIMEOUT_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update AXI Write Size Error. This
///< bit enables PC_AXI_SIZE_ERR in INT_STATUS register for high priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_SIZE_ERR_BF_OFF (24)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_SIZE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_SIZE_ERR_BF_MSK (0x01000000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_SIZE_ERR_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update AXI Write Strobe Error. This
///< bit enables PC_AXI_STROBE_ERR in INT_STATUS register for high priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_STROBE_ERR_BF_OFF (25)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_STROBE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_STROBE_ERR_BF_MSK (0x02000000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_STROBE_ERR_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update AXI Write Length Error. This
///< bit enables PC_AXI_LENGTH_ERR in INT_STATUS register for high priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_LENGTH_ERR_BF_OFF (26)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_LENGTH_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_LENGTH_ERR_BF_MSK (0x04000000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_LENGTH_ERR_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update Data Drop on AXI Write Start
///< Error. This bit enables PC_AXI_ERR_DROP in INT_STATUS register for
///< high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_ERR_DROP_BF_OFF (27)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_ERR_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_ERR_DROP_BF_MSK (0x08000000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_ERR_DROP_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update AXI Read Error. This bit enables
///< PC_AXI_READ_ERR in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_READ_ERR_BF_OFF (28)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_READ_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_READ_ERR_BF_MSK (0x10000000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_AXI_READ_ERR_BF_DEF (0x00000000)

///< High Enable for PDPD Coefficient Update Error. This bit enables PC_UPDATE_ERR
///< in INT_STATUS register for high priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_UPDATE_ERR_BF_OFF (29)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_UPDATE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_UPDATE_ERR_BF_MSK (0x20000000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_PC_UPDATE_ERR_BF_DEF (0x00000000)

///< High Enable for Capture Memory Channel Data Select Overlap Error.
///< This bit enables CMEM_OVLP_CHNL_ERR in INT_STATUS register for high
///< priority interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_CMEM_OVLP_CHNL_ERR_BF_OFF (30)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_CMEM_OVLP_CHNL_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_CMEM_OVLP_CHNL_ERR_BF_MSK (0x40000000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_CMEM_OVLP_CHNL_ERR_BF_DEF (0x00000000)

///< High Enable for Capture Memory V2D Data Select Overlap Error. This
///< bit enables CMEM_OVLP_V2D_ERR in INT_STATUS register for high priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_CMEM_OVLP_V2D_ERR_BF_OFF (31)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_CMEM_OVLP_V2D_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_CMEM_OVLP_V2D_ERR_BF_MSK (0x80000000)
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_HIGH_EN_CMEM_OVLP_V2D_ERR_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_INT_CSR_INT_LOW_EN register description at address offset 0xe8
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/INT_CSR/INT_LOW_EN
  * ABC V2D Low Priority Interrupt Enable Register
  */

typedef union {
  struct {
    uint32_t LOW_EN_TX_BUF_0_ECC_SBE : 1;
    ///< Low Enable for Tx Buffer 0 ECC Single-bit Error. This bit enables
    ///< TX_BUF_0_ECC_SBE in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t LOW_EN_TX_BUF_0_ECC_DBE : 1;
    ///< Low Enable for Tx Buffer 0 ECC Multi-bit Error. This bit enables TX_BUF_0_ECC_DBE
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t LOW_EN_TX_BUF_1_ECC_SBE : 1;
    ///< Low Enable for Tx Buffer 1 ECC Single-bit Error. This bit enables
    ///< TX_BUF_1_ECC_SBE in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t LOW_EN_TX_BUF_1_ECC_DBE : 1;
    ///< Low Enable for Tx Buffer 1 ECC Multi-bit Error. This bit enables TX_BUF_1_ECC_DBE
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t LOW_EN_TX_BUF_0_ECC_SBE_CNT_OVFL : 1;
    ///< Low Enable for Tx Buffer 0 ECC SBE Count Overflow. This bit enables
    ///< TX_BUF_0_ECC_SBE_CNT_OVFL in INT_STATUS register for low priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t LOW_EN_TX_BUF_1_ECC_SBE_CNT_OVFL : 1;
    ///< Low Enable for Tx Buffer 1 ECC SBE Count Overflow. This bit enables
    ///< TX_BUF_1_ECC_SBE_CNT_OVFL in INT_STATUS register for low priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t LOW_EN_PD_MAIN_NODATA_START : 1;
    ///< Low Enable for PDPD Main No Data Start. This bit enables PD_MAIN_NODATA_START
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t LOW_EN_PD_EXTRA_NODATA_START : 1;
    ///< Low Enable for PDPD Extra No Data Start. This bit enables PD_EXTRA_NODATA_START
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t LOW_EN_RX_HBI_0_OVFL_DROP : 1;
    ///< Low Enable for Rx HBI 0 Overflow Drop. This bit enables RX_HBI_0_OVFL_DROP
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t LOW_EN_RX_HBI_1_OVFL_DROP : 1;
    ///< Low Enable for Rx HBI 1 Overflow Drop. This bit enables RX_HBI_1_OVFL_DROP
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t LOW_EN_RX_0_NOCFG_DROP : 1;
    ///< Low Enable for Rx 0 No Cfg Drop. This bit enables RX_0_NOCFG_DROP
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t LOW_EN_RX_1_NOCFG_DROP : 1;
    ///< Low Enable for Rx 1 No Cfg Drop. This bit enables RX_1_NOCFG_DROP
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t LOW_EN_TX_UNDERRUN : 1;
    ///< Low Enable for Tx Underrun. This bit enables TX_UNDERRUN in INT_STATUS
    ///< register for low priority interrupt.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t LOW_EN_TX_NODATA_START : 1;
    ///< Low Enable for Tx No Data Start. This bit enables TX_NODATA_START
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t LOW_EN_SMON_INTR : 1;
    ///< Low Enable for SMON Interrupt. This bit enables SMON_INTR in INT_STATUS
    ///< register for low priority interrupt.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t LOW_EN_PC_HBI_AXI : 1;
    ///< Low Enable for PDPD Coefficient Update AXI Collide with HBI. This
    ///< bit enables PC_HBI_AXI in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t LOW_EN_TX_HBI_0_NOCFG_DROP : 1;
    ///< Low Enable for Tx HBI 0 No-Config Data Drop. This bit enables TX_HBI_0_NOCFG_DROP
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t LOW_EN_TX_HBI_1_NOCFG_DROP : 1;
    ///< Low Enable for Tx HBI 1 No-Config Data Drop. This bit enables TX_HBI_1_NOCFG_DROP
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t LOW_EN_PD_MAIN_UNDERRUN : 1;
    ///< Low Enable for PDPD Main Data Underrun. This bit enables PD_MAIN_UNDERRUN
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t LOW_EN_PD_EXTRA_UNDERRUN : 1;
    ///< Low Enable for PDPD Extra Data Underrun. This bit enables PD_EXTRA_UNDERRUN
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t LOW_EN_PC_HBI_DROP : 1;
    ///< Low Enable for PDPD Coefficient Update Data Drop on HBI. This bit
    ///< enables PC_HBI_DROP in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t LOW_EN_PC_HBI_TIMEOUT : 1;
    ///< Low Enable for PDPD Coefficient Update Timeout on HBI. This bit enables
    ///< PC_HBI_TIMEOUT in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t LOW_EN_PC_HBI_M2_IN_M1 : 1;
    ///< Low Enable for PDPD Coefficient Update M2 In M1 on HBI. This bit enables
    ///< PC_HBI_M2_IN_M1 in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t LOW_EN_PC_AXI_TIMEOUT : 1;
    ///< Low Enable for PDPD Coefficient Update Timeout on AXI. This bit enables
    ///< PC_AXI_TIMEOUT in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t LOW_EN_PC_AXI_SIZE_ERR : 1;
    ///< Low Enable for PDPD Coefficient Update AXI Write Size Error. This
    ///< bit enables PC_AXI_SIZE_ERR in INT_STATUS register for low priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t LOW_EN_PC_AXI_STROBE_ERR : 1;
    ///< Low Enable for PDPD Coefficient Update AXI Write Strobe Error. This
    ///< bit enables PC_AXI_STROBE_ERR in INT_STATUS register for low priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t LOW_EN_PC_AXI_LENGTH_ERR : 1;
    ///< Low Enable for PDPD Coefficient Update AXI Write Length Error. This
    ///< bit enables PC_AXI_LENGTH_ERR in INT_STATUS register for low priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t LOW_EN_PC_AXI_ERR_DROP : 1;
    ///< Low Enable for PDPD Coefficient Update Data Drop on AXI Write Start
    ///< Error. This bit enables PC_AXI_ERR_DROP in INT_STATUS register for
    ///< low priority interrupt.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t LOW_EN_PC_AXI_READ_ERR : 1;
    ///< Low Enable for PDPD Coefficient Update AXI Read Error. This bit enables
    ///< PC_AXI_READ_ERR in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t LOW_EN_PC_UPDATE_ERR : 1;
    ///< Low Enable for PDPD Coefficient Update Error. This bit enables PC_UPDATE_ERR
    ///< in INT_STATUS register for low priority interrupt.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t LOW_EN_CMEM_OVLP_CHNL_ERR : 1;
    ///< Low Enable for Capture Memory Channel Data Select Overlap Error. This
    ///< bit enables CMEM_OVLP_CHNL_ERR in INT_STATUS register for low priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t LOW_EN_CMEM_OVLP_V2D_ERR : 1;
    ///< Low Enable for Capture Memory V2D Data Select Overlap Error. This
    ///< bit enables CMEM_OVLP_V2D_ERR in INT_STATUS register for low priority
    ///< interrupt.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_int_csr_int_low_en_reg_t;

#define AV2D_CSR_INT_CSR_INT_LOW_EN_DEFAULT (0x00000000U)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_RD_MASK (0xffffffffU)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_WR_MASK (0xffffffffU)


///< Low Enable for Tx Buffer 0 ECC Single-bit Error. This bit enables
///< TX_BUF_0_ECC_SBE in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_SBE_BF_OFF ( 0)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_SBE_BF_MSK (0x00000001)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_SBE_BF_DEF (0x00000000)

///< Low Enable for Tx Buffer 0 ECC Multi-bit Error. This bit enables TX_BUF_0_ECC_DBE
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_DBE_BF_OFF ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_DBE_BF_MSK (0x00000002)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_DBE_BF_DEF (0x00000000)

///< Low Enable for Tx Buffer 1 ECC Single-bit Error. This bit enables
///< TX_BUF_1_ECC_SBE in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_SBE_BF_OFF ( 2)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_SBE_BF_MSK (0x00000004)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_SBE_BF_DEF (0x00000000)

///< Low Enable for Tx Buffer 1 ECC Multi-bit Error. This bit enables TX_BUF_1_ECC_DBE
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_DBE_BF_OFF ( 3)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_DBE_BF_MSK (0x00000008)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_DBE_BF_DEF (0x00000000)

///< Low Enable for Tx Buffer 0 ECC SBE Count Overflow. This bit enables
///< TX_BUF_0_ECC_SBE_CNT_OVFL in INT_STATUS register for low priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_OFF ( 4)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_MSK (0x00000010)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Low Enable for Tx Buffer 1 ECC SBE Count Overflow. This bit enables
///< TX_BUF_1_ECC_SBE_CNT_OVFL in INT_STATUS register for low priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Low Enable for PDPD Main No Data Start. This bit enables PD_MAIN_NODATA_START
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_MAIN_NODATA_START_BF_OFF ( 6)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_MAIN_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_MAIN_NODATA_START_BF_MSK (0x00000040)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_MAIN_NODATA_START_BF_DEF (0x00000000)

///< Low Enable for PDPD Extra No Data Start. This bit enables PD_EXTRA_NODATA_START
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_EXTRA_NODATA_START_BF_OFF ( 7)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_EXTRA_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_EXTRA_NODATA_START_BF_MSK (0x00000080)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_EXTRA_NODATA_START_BF_DEF (0x00000000)

///< Low Enable for Rx HBI 0 Overflow Drop. This bit enables RX_HBI_0_OVFL_DROP
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_HBI_0_OVFL_DROP_BF_OFF ( 8)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_HBI_0_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_HBI_0_OVFL_DROP_BF_MSK (0x00000100)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_HBI_0_OVFL_DROP_BF_DEF (0x00000000)

///< Low Enable for Rx HBI 1 Overflow Drop. This bit enables RX_HBI_1_OVFL_DROP
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_HBI_1_OVFL_DROP_BF_OFF ( 9)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_HBI_1_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_HBI_1_OVFL_DROP_BF_MSK (0x00000200)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_HBI_1_OVFL_DROP_BF_DEF (0x00000000)

///< Low Enable for Rx 0 No Cfg Drop. This bit enables RX_0_NOCFG_DROP
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_0_NOCFG_DROP_BF_OFF (10)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_0_NOCFG_DROP_BF_MSK (0x00000400)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_0_NOCFG_DROP_BF_DEF (0x00000000)

///< Low Enable for Rx 1 No Cfg Drop. This bit enables RX_1_NOCFG_DROP
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_1_NOCFG_DROP_BF_OFF (11)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_1_NOCFG_DROP_BF_MSK (0x00000800)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_RX_1_NOCFG_DROP_BF_DEF (0x00000000)

///< Low Enable for Tx Underrun. This bit enables TX_UNDERRUN in INT_STATUS
///< register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_UNDERRUN_BF_OFF (12)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_UNDERRUN_BF_MSK (0x00001000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_UNDERRUN_BF_DEF (0x00000000)

///< Low Enable for Tx No Data Start. This bit enables TX_NODATA_START
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_NODATA_START_BF_OFF (13)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_NODATA_START_BF_MSK (0x00002000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_NODATA_START_BF_DEF (0x00000000)

///< Low Enable for SMON Interrupt. This bit enables SMON_INTR in INT_STATUS
///< register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_SMON_INTR_BF_OFF (14)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_SMON_INTR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_SMON_INTR_BF_MSK (0x00004000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_SMON_INTR_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update AXI Collide with HBI. This
///< bit enables PC_HBI_AXI in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_AXI_BF_OFF (15)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_AXI_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_AXI_BF_MSK (0x00008000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_AXI_BF_DEF (0x00000000)

///< Low Enable for Tx HBI 0 No-Config Data Drop. This bit enables TX_HBI_0_NOCFG_DROP
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_HBI_0_NOCFG_DROP_BF_OFF (16)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_HBI_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_HBI_0_NOCFG_DROP_BF_MSK (0x00010000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_HBI_0_NOCFG_DROP_BF_DEF (0x00000000)

///< Low Enable for Tx HBI 1 No-Config Data Drop. This bit enables TX_HBI_1_NOCFG_DROP
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_HBI_1_NOCFG_DROP_BF_OFF (17)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_HBI_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_HBI_1_NOCFG_DROP_BF_MSK (0x00020000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_TX_HBI_1_NOCFG_DROP_BF_DEF (0x00000000)

///< Low Enable for PDPD Main Data Underrun. This bit enables PD_MAIN_UNDERRUN
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_MAIN_UNDERRUN_BF_OFF (18)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_MAIN_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_MAIN_UNDERRUN_BF_MSK (0x00040000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_MAIN_UNDERRUN_BF_DEF (0x00000000)

///< Low Enable for PDPD Extra Data Underrun. This bit enables PD_EXTRA_UNDERRUN
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_EXTRA_UNDERRUN_BF_OFF (19)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_EXTRA_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_EXTRA_UNDERRUN_BF_MSK (0x00080000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PD_EXTRA_UNDERRUN_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update Data Drop on HBI. This bit
///< enables PC_HBI_DROP in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_DROP_BF_OFF (20)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_DROP_BF_MSK (0x00100000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_DROP_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update Timeout on HBI. This bit enables
///< PC_HBI_TIMEOUT in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_TIMEOUT_BF_OFF (21)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_TIMEOUT_BF_MSK (0x00200000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_TIMEOUT_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update M2 In M1 on HBI. This bit enables
///< PC_HBI_M2_IN_M1 in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_M2_IN_M1_BF_OFF (22)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_M2_IN_M1_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_M2_IN_M1_BF_MSK (0x00400000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_HBI_M2_IN_M1_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update Timeout on AXI. This bit enables
///< PC_AXI_TIMEOUT in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_TIMEOUT_BF_OFF (23)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_TIMEOUT_BF_MSK (0x00800000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_TIMEOUT_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update AXI Write Size Error. This
///< bit enables PC_AXI_SIZE_ERR in INT_STATUS register for low priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_SIZE_ERR_BF_OFF (24)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_SIZE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_SIZE_ERR_BF_MSK (0x01000000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_SIZE_ERR_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update AXI Write Strobe Error. This
///< bit enables PC_AXI_STROBE_ERR in INT_STATUS register for low priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_STROBE_ERR_BF_OFF (25)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_STROBE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_STROBE_ERR_BF_MSK (0x02000000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_STROBE_ERR_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update AXI Write Length Error. This
///< bit enables PC_AXI_LENGTH_ERR in INT_STATUS register for low priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_LENGTH_ERR_BF_OFF (26)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_LENGTH_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_LENGTH_ERR_BF_MSK (0x04000000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_LENGTH_ERR_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update Data Drop on AXI Write Start
///< Error. This bit enables PC_AXI_ERR_DROP in INT_STATUS register for
///< low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_ERR_DROP_BF_OFF (27)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_ERR_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_ERR_DROP_BF_MSK (0x08000000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_ERR_DROP_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update AXI Read Error. This bit enables
///< PC_AXI_READ_ERR in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_READ_ERR_BF_OFF (28)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_READ_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_READ_ERR_BF_MSK (0x10000000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_AXI_READ_ERR_BF_DEF (0x00000000)

///< Low Enable for PDPD Coefficient Update Error. This bit enables PC_UPDATE_ERR
///< in INT_STATUS register for low priority interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_UPDATE_ERR_BF_OFF (29)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_UPDATE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_UPDATE_ERR_BF_MSK (0x20000000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_PC_UPDATE_ERR_BF_DEF (0x00000000)

///< Low Enable for Capture Memory Channel Data Select Overlap Error. This
///< bit enables CMEM_OVLP_CHNL_ERR in INT_STATUS register for low priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_CMEM_OVLP_CHNL_ERR_BF_OFF (30)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_CMEM_OVLP_CHNL_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_CMEM_OVLP_CHNL_ERR_BF_MSK (0x40000000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_CMEM_OVLP_CHNL_ERR_BF_DEF (0x00000000)

///< Low Enable for Capture Memory V2D Data Select Overlap Error. This
///< bit enables CMEM_OVLP_V2D_ERR in INT_STATUS register for low priority
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_CMEM_OVLP_V2D_ERR_BF_OFF (31)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_CMEM_OVLP_V2D_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_CMEM_OVLP_V2D_ERR_BF_MSK (0x80000000)
#define AV2D_CSR_INT_CSR_INT_LOW_EN_LOW_EN_CMEM_OVLP_V2D_ERR_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_INT_CSR_INT_CLEAR register description at address offset 0xec
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/INT_CSR/INT_CLEAR
  * ABC V2D Interrupt Clear Register
  */

typedef union {
  struct {
    uint32_t CLEAR_TX_BUF_0_ECC_SBE : 1;
    ///< Tx Buffer 0 ECC Single-bit Error Clear. This bit clears TX_BUF_0_ECC_SBE
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t CLEAR_TX_BUF_0_ECC_DBE : 1;
    ///< Tx Buffer 0 ECC Multi-bit Error Clear. This bit clears TX_BUF_0_ECC_DBE
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t CLEAR_TX_BUF_1_ECC_SBE : 1;
    ///< Tx Buffer 1 ECC Single-bit Error Clear. This bit clears TX_BUF_1_ECC_SBE
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CLEAR_TX_BUF_1_ECC_DBE : 1;
    ///< Tx Buffer 1 ECC Multi-bit Error Clear. This bit clears TX_BUF_1_ECC_DBE
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CLEAR_TX_BUF_0_ECC_SBE_CNT_OVFL : 1;
    ///< Tx Buffer 0 ECC SBE Count Overflow Clear. This bit clears TX_BUF_0_ECC_SBE_CNT_OVFL
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t CLEAR_TX_BUF_1_ECC_SBE_CNT_OVFL : 1;
    ///< Tx Buffer 1 ECC SBE Count Overflow Clear. This bit clears TX_BUF_1_ECC_SBE_CNT_OVFL
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t CLEAR_PD_MAIN_NODATA_START : 1;
    ///< PDPD Main No Data Start Clear. This bit clears PD_MAIN_NODATA_START
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t CLEAR_PD_EXTRA_NODATA_START : 1;
    ///< PDPD Extra No Data Start Clear. This bit clears PD_EXTRA_NODATA_START
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t CLEAR_RX_HBI_0_OVFL_DROP : 1;
    ///< Rx HBI 0 Overflow Drop Clear. This bit clears RX_HBI_0_OVFL_DROP in
    ///< INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t CLEAR_RX_HBI_1_OVFL_DROP : 1;
    ///< Rx HBI 1 Overflow Drop Clear. This bit clears RX_HBI_1_OVFL_DROP in
    ///< INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t CLEAR_RX_0_NOCFG_DROP : 1;
    ///< Rx 0 No Cfg Drop Clear. This bit clears RX_0_NOCFG_DROP in INT_STATUS
    ///< register for interrupt.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t CLEAR_RX_1_NOCFG_DROP : 1;
    ///< Rx 1 No Cfg Drop Clear. This bit clears RX_1_NOCFG_DROP in INT_STATUS
    ///< register for interrupt.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t CLEAR_TX_UNDERRUN : 1;
    ///< Tx Underrun Clear. This bit clears TX_UNDERRUN in INT_STATUS register
    ///< for interrupt.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t CLEAR_TX_NODATA_START : 1;
    ///< Tx No Data Start Clear. This bit clears TX_NODATA_START in INT_STATUS
    ///< register for interrupt.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t CLEAR_SMON_INTR : 1;
    ///< SMON Interrupt Clear. This bit clears SMON_INTR in INT_STATUS register
    ///< for interrupt.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t CLEAR_PC_HBI_AXI : 1;
    ///< PDPD Coefficient Update AXI Collide with HBI Clear. This bit clears
    ///< PC_HBI_AXI in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t CLEAR_TX_HBI_0_NOCFG_DROP : 1;
    ///< Tx HBI 0 No-Config Data Drop Clear. This bit clears TX_HBI_0_NOCFG_DROP
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t CLEAR_TX_HBI_1_NOCFG_DROP : 1;
    ///< Tx HBI 1 No-Config Data Drop Clear. This bit clears TX_HBI_1_NOCFG_DROP
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t CLEAR_PD_MAIN_UNDERRUN : 1;
    ///< PDPD Main Data Underrun Clear. This bit clears PD_MAIN_UNDERRUN in
    ///< INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t CLEAR_PD_EXTRA_UNDERRUN : 1;
    ///< PDPD Extra Data Underrun Clear. This bit clears PD_EXTRA_UNDERRUN
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t CLEAR_PC_HBI_DROP : 1;
    ///< PDPD Coefficient Update Data Drop on HBI Clear. This bit clears PC_HBI_DROP
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t CLEAR_PC_HBI_TIMEOUT : 1;
    ///< PDPD Coefficient Update Timeout on HBI Clear. This bit clears PC_HBI_TIMEOUT
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t CLEAR_PC_HBI_M2_IN_M1 : 1;
    ///< PDPD Coefficient Update M2 In M1 on HBI Clear. This bit clears PC_HBI_M2_IN_M1
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t CLEAR_PC_AXI_TIMEOUT : 1;
    ///< PDPD Coefficient Update Timeout on AXI Clear. This bit clears PC_AXI_TIMEOUT
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t CLEAR_PC_AXI_SIZE_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Size Error Clear. This bit clears
    ///< PC_AXI_SIZE_ERR in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t CLEAR_PC_AXI_STROBE_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Strobe Error Clear. This bit clears
    ///< PC_AXI_STROBE_ERR in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t CLEAR_PC_AXI_LENGTH_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Length Error Clear. This bit clears
    ///< PC_AXI_LENGTH_ERR in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t CLEAR_PC_AXI_ERR_DROP : 1;
    ///< PDPD Coefficient Update Data Drop on AXI Write Start Error Clear.
    ///< This bit clears PC_AXI_ERR_DROP in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t CLEAR_PC_AXI_READ_ERR : 1;
    ///< PDPD Coefficient Update AXI Read Error Clear. This bit clears PC_AXI_READ_ERR
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t CLEAR_PC_UPDATE_ERR : 1;
    ///< PDPD Coefficient Update Error Clear. This bit clears PC_UPDATE_ERR
    ///< in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t CLEAR_CMEM_OVLP_CHNL_ERR : 1;
    ///< Capture Memory Channel Data Select Overlap Error Clear. This bit clears
    ///< CMEM_OVLP_CHNL_ERR in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t CLEAR_CMEM_OVLP_V2D_ERR : 1;
    ///< Capture Memory V2D Data Select Overlap Error Clear. This bit clears
    ///< CMEM_OVLP_V2D_ERR in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_int_csr_int_clr_reg_t;

#define AV2D_CSR_INT_CSR_INT_CLR_DEFAULT (0x00000000U)
#define AV2D_CSR_INT_CSR_INT_CLR_RD_MASK (0xffffffffU)
#define AV2D_CSR_INT_CSR_INT_CLR_WR_MASK (0xffffffffU)


///< Tx Buffer 0 ECC Single-bit Error Clear. This bit clears TX_BUF_0_ECC_SBE
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_SBE_BF_OFF ( 0)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_SBE_BF_MSK (0x00000001)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_SBE_BF_DEF (0x00000000)

///< Tx Buffer 0 ECC Multi-bit Error Clear. This bit clears TX_BUF_0_ECC_DBE
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_DBE_BF_OFF ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_DBE_BF_MSK (0x00000002)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_DBE_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC Single-bit Error Clear. This bit clears TX_BUF_1_ECC_SBE
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_SBE_BF_OFF ( 2)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_SBE_BF_MSK (0x00000004)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_SBE_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC Multi-bit Error Clear. This bit clears TX_BUF_1_ECC_DBE
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_DBE_BF_OFF ( 3)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_DBE_BF_MSK (0x00000008)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_DBE_BF_DEF (0x00000000)

///< Tx Buffer 0 ECC SBE Count Overflow Clear. This bit clears TX_BUF_0_ECC_SBE_CNT_OVFL
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_OFF ( 4)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_MSK (0x00000010)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC SBE Count Overflow Clear. This bit clears TX_BUF_1_ECC_SBE_CNT_OVFL
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< PDPD Main No Data Start Clear. This bit clears PD_MAIN_NODATA_START
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PD_MAIN_NODATA_START_BF_OFF ( 6)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_MAIN_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_MAIN_NODATA_START_BF_MSK (0x00000040)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_MAIN_NODATA_START_BF_DEF (0x00000000)

///< PDPD Extra No Data Start Clear. This bit clears PD_EXTRA_NODATA_START
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PD_EXTRA_NODATA_START_BF_OFF ( 7)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_EXTRA_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_EXTRA_NODATA_START_BF_MSK (0x00000080)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_EXTRA_NODATA_START_BF_DEF (0x00000000)

///< Rx HBI 0 Overflow Drop Clear. This bit clears RX_HBI_0_OVFL_DROP in
///< INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_RX_HBI_0_OVFL_DROP_BF_OFF ( 8)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_HBI_0_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_HBI_0_OVFL_DROP_BF_MSK (0x00000100)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_HBI_0_OVFL_DROP_BF_DEF (0x00000000)

///< Rx HBI 1 Overflow Drop Clear. This bit clears RX_HBI_1_OVFL_DROP in
///< INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_RX_HBI_1_OVFL_DROP_BF_OFF ( 9)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_HBI_1_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_HBI_1_OVFL_DROP_BF_MSK (0x00000200)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_HBI_1_OVFL_DROP_BF_DEF (0x00000000)

///< Rx 0 No Cfg Drop Clear. This bit clears RX_0_NOCFG_DROP in INT_STATUS
///< register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_RX_0_NOCFG_DROP_BF_OFF (10)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_0_NOCFG_DROP_BF_MSK (0x00000400)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_0_NOCFG_DROP_BF_DEF (0x00000000)

///< Rx 1 No Cfg Drop Clear. This bit clears RX_1_NOCFG_DROP in INT_STATUS
///< register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_RX_1_NOCFG_DROP_BF_OFF (11)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_1_NOCFG_DROP_BF_MSK (0x00000800)
#define AV2D_CSR_INT_CSR_INT_CLR_RX_1_NOCFG_DROP_BF_DEF (0x00000000)

///< Tx Underrun Clear. This bit clears TX_UNDERRUN in INT_STATUS register
///< for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_UNDERRUN_BF_OFF (12)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_UNDERRUN_BF_MSK (0x00001000)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_UNDERRUN_BF_DEF (0x00000000)

///< Tx No Data Start Clear. This bit clears TX_NODATA_START in INT_STATUS
///< register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_NODATA_START_BF_OFF (13)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_NODATA_START_BF_MSK (0x00002000)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_NODATA_START_BF_DEF (0x00000000)

///< SMON Interrupt Clear. This bit clears SMON_INTR in INT_STATUS register
///< for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_SMON_INTR_BF_OFF (14)
#define AV2D_CSR_INT_CSR_INT_CLR_SMON_INTR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_SMON_INTR_BF_MSK (0x00004000)
#define AV2D_CSR_INT_CSR_INT_CLR_SMON_INTR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Collide with HBI Clear. This bit clears
///< PC_HBI_AXI in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_AXI_BF_OFF (15)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_AXI_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_AXI_BF_MSK (0x00008000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_AXI_BF_DEF (0x00000000)

///< Tx HBI 0 No-Config Data Drop Clear. This bit clears TX_HBI_0_NOCFG_DROP
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_HBI_0_NOCFG_DROP_BF_OFF (16)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_HBI_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_HBI_0_NOCFG_DROP_BF_MSK (0x00010000)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_HBI_0_NOCFG_DROP_BF_DEF (0x00000000)

///< Tx HBI 1 No-Config Data Drop Clear. This bit clears TX_HBI_1_NOCFG_DROP
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_TX_HBI_1_NOCFG_DROP_BF_OFF (17)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_HBI_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_HBI_1_NOCFG_DROP_BF_MSK (0x00020000)
#define AV2D_CSR_INT_CSR_INT_CLR_TX_HBI_1_NOCFG_DROP_BF_DEF (0x00000000)

///< PDPD Main Data Underrun Clear. This bit clears PD_MAIN_UNDERRUN in
///< INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PD_MAIN_UNDERRUN_BF_OFF (18)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_MAIN_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_MAIN_UNDERRUN_BF_MSK (0x00040000)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_MAIN_UNDERRUN_BF_DEF (0x00000000)

///< PDPD Extra Data Underrun Clear. This bit clears PD_EXTRA_UNDERRUN
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PD_EXTRA_UNDERRUN_BF_OFF (19)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_EXTRA_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_EXTRA_UNDERRUN_BF_MSK (0x00080000)
#define AV2D_CSR_INT_CSR_INT_CLR_PD_EXTRA_UNDERRUN_BF_DEF (0x00000000)

///< PDPD Coefficient Update Data Drop on HBI Clear. This bit clears PC_HBI_DROP
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_DROP_BF_OFF (20)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_DROP_BF_MSK (0x00100000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_DROP_BF_DEF (0x00000000)

///< PDPD Coefficient Update Timeout on HBI Clear. This bit clears PC_HBI_TIMEOUT
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_TIMEOUT_BF_OFF (21)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_TIMEOUT_BF_MSK (0x00200000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_TIMEOUT_BF_DEF (0x00000000)

///< PDPD Coefficient Update M2 In M1 on HBI Clear. This bit clears PC_HBI_M2_IN_M1
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_M2_IN_M1_BF_OFF (22)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_M2_IN_M1_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_M2_IN_M1_BF_MSK (0x00400000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_HBI_M2_IN_M1_BF_DEF (0x00000000)

///< PDPD Coefficient Update Timeout on AXI Clear. This bit clears PC_AXI_TIMEOUT
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_TIMEOUT_BF_OFF (23)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_TIMEOUT_BF_MSK (0x00800000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_TIMEOUT_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Size Error Clear. This bit clears
///< PC_AXI_SIZE_ERR in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_SIZE_ERR_BF_OFF (24)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_SIZE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_SIZE_ERR_BF_MSK (0x01000000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_SIZE_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Strobe Error Clear. This bit clears
///< PC_AXI_STROBE_ERR in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_STROBE_ERR_BF_OFF (25)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_STROBE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_STROBE_ERR_BF_MSK (0x02000000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_STROBE_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Length Error Clear. This bit clears
///< PC_AXI_LENGTH_ERR in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_LENGTH_ERR_BF_OFF (26)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_LENGTH_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_LENGTH_ERR_BF_MSK (0x04000000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_LENGTH_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update Data Drop on AXI Write Start Error Clear.
///< This bit clears PC_AXI_ERR_DROP in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_ERR_DROP_BF_OFF (27)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_ERR_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_ERR_DROP_BF_MSK (0x08000000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_ERR_DROP_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Read Error Clear. This bit clears PC_AXI_READ_ERR
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_READ_ERR_BF_OFF (28)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_READ_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_READ_ERR_BF_MSK (0x10000000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_AXI_READ_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update Error Clear. This bit clears PC_UPDATE_ERR
///< in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_PC_UPDATE_ERR_BF_OFF (29)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_UPDATE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_UPDATE_ERR_BF_MSK (0x20000000)
#define AV2D_CSR_INT_CSR_INT_CLR_PC_UPDATE_ERR_BF_DEF (0x00000000)

///< Capture Memory Channel Data Select Overlap Error Clear. This bit clears
///< CMEM_OVLP_CHNL_ERR in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_CMEM_OVLP_CHNL_ERR_BF_OFF (30)
#define AV2D_CSR_INT_CSR_INT_CLR_CMEM_OVLP_CHNL_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_CMEM_OVLP_CHNL_ERR_BF_MSK (0x40000000)
#define AV2D_CSR_INT_CSR_INT_CLR_CMEM_OVLP_CHNL_ERR_BF_DEF (0x00000000)

///< Capture Memory V2D Data Select Overlap Error Clear. This bit clears
///< CMEM_OVLP_V2D_ERR in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_CLR_CMEM_OVLP_V2D_ERR_BF_OFF (31)
#define AV2D_CSR_INT_CSR_INT_CLR_CMEM_OVLP_V2D_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_CLR_CMEM_OVLP_V2D_ERR_BF_MSK (0x80000000)
#define AV2D_CSR_INT_CSR_INT_CLR_CMEM_OVLP_V2D_ERR_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_INT_CSR_INT_FORCE register description at address offset 0xf0
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/INT_CSR/INT_FORCE
  * ABC V2D Interrupt Force Register
  */

typedef union {
  struct {
    uint32_t FORCE_TX_BUF_0_ECC_SBE : 1;
    ///< Tx Buffer 0 ECC Single-bit Error Force. This bit forces TX_BUF_0_ECC_SBE
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_TX_BUF_0_ECC_DBE : 1;
    ///< Tx Buffer 0 ECC Multi-bit Error Force. This bit forces TX_BUF_0_ECC_DBE
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t FORCE_TX_BUF_1_ECC_SBE : 1;
    ///< Tx Buffer 1 ECC Single-bit Error Force. This bit forces TX_BUF_1_ECC_SBE
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t FORCE_TX_BUF_1_ECC_DBE : 1;
    ///< Tx Buffer 1 ECC Multi-bit Error Force. This bit forces TX_BUF_1_ECC_DBE
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t FORCE_TX_BUF_0_ECC_SBE_CNT_OVFL : 1;
    ///< Tx Buffer 0 ECC SBE Count Overflow Force. This bit forces TX_BUF_0_ECC_SBE_CNT_OVFL
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t FORCE_TX_BUF_1_ECC_SBE_CNT_OVFL : 1;
    ///< Tx Buffer 1 ECC SBE Count Overflow Force. This bit forces TX_BUF_1_ECC_SBE_CNT_OVFL
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t FORCE_PD_MAIN_NODATA_START : 1;
    ///< PDPD Main No Data Start Force. This bit forces PD_MAIN_NODATA_START
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t FORCE_PD_EXTRA_NODATA_START : 1;
    ///< PDPD Extra No Data Start Force. This bit forces PD_EXTRA_NODATA_START
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t FORCE_RX_HBI_0_OVFL_DROP : 1;
    ///< Rx HBI 0 Overflow Drop Force. This bit forces RX_HBI_0_OVFL_DROP bit
    ///< to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t FORCE_RX_HBI_1_OVFL_DROP : 1;
    ///< Rx HBI 1 Overflow Drop Force. This bit forces RX_HBI_1_OVFL_DROP bit
    ///< to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t FORCE_RX_0_NOCFG_DROP : 1;
    ///< Rx 0 No Cfg Drop Force. This bit forces RX_0_NOCFG_DROP bit to 1 in
    ///< INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t FORCE_RX_1_NOCFG_DROP : 1;
    ///< Rx 1 No Cfg Drop Force. This bit forces RX_1_NOCFG_DROP bit to 1 in
    ///< INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t FORCE_TX_UNDERRUN : 1;
    ///< Tx Underrun Force. This bit forces TX_UNDERRUN bit to 1 in INT_STATUS
    ///< register for interrupt.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t FORCE_TX_NODATA_START : 1;
    ///< Tx No Data Start Force. This bit forces TX_NODATA_START bit to 1 in
    ///< INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t FORCE_SMON_INTR : 1;
    ///< SMON Interrupt Force. This bit forces SMON_INTR bit to 1 in INT_STATUS
    ///< register for interrupt.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t FORCE_PC_HBI_AXI : 1;
    ///< PDPD Coefficient Update AXI Collide with HBI Force. This bit forces
    ///< PC_HBI_AXI bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t FORCE_TX_HBI_0_NOCFG_DROP : 1;
    ///< Tx HBI 0 No-Config Data Drop Force. This bit forces TX_HBI_0_NOCFG_DROP
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t FORCE_TX_HBI_1_NOCFG_DROP : 1;
    ///< Tx HBI 1 No-Config Data Drop Force. This bit forces TX_HBI_1_NOCFG_DROP
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t FORCE_PD_MAIN_UNDERRUN : 1;
    ///< PDPD Main Data Underrun Force. This bit forces PD_MAIN_UNDERRUN bit
    ///< to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t FORCE_PD_EXTRA_UNDERRUN : 1;
    ///< PDPD Extra Data Underrun Force. This bit forces PD_EXTRA_UNDERRUN
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t FORCE_PC_HBI_DROP : 1;
    ///< PDPD Coefficient Update Data Drop on HBI Force. This bit forces PC_HBI_DROP
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t FORCE_PC_HBI_TIMEOUT : 1;
    ///< PDPD Coefficient Update Timeout on HBI Force. This bit forces PC_HBI_TIMEOUT
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t FORCE_PC_HBI_M2_IN_M1 : 1;
    ///< PDPD Coefficient Update M2 In M1 on HBI Force. This bit forces PC_HBI_M2_IN_M1
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="22" ResetValue="0x0"
    uint32_t FORCE_PC_AXI_TIMEOUT : 1;
    ///< PDPD Coefficient Update Timeout on AXI Force. This bit forces PC_AXI_TIMEOUT
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t FORCE_PC_AXI_SIZE_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Size Error Force. This bit forces
    ///< PC_AXI_SIZE_ERR bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t FORCE_PC_AXI_STROBE_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Strobe Error Force. This bit forces
    ///< PC_AXI_STROBE_ERR bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t FORCE_PC_AXI_LENGTH_ERR : 1;
    ///< PDPD Coefficient Update AXI Write Length Error Force. This bit forces
    ///< PC_AXI_LENGTH_ERR bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t FORCE_PC_AXI_ERR_DROP : 1;
    ///< PDPD Coefficient Update Data Drop on AXI Write Start Error Force.
    ///< This bit forces PC_AXI_ERR_DROP bit to 1 in INT_STATUS register for
    ///< interrupt.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t FORCE_PC_AXI_READ_ERR : 1;
    ///< PDPD Coefficient Update AXI Read Error Force. This bit forces PC_AXI_READ_ERR
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t FORCE_PC_UPDATE_ERR : 1;
    ///< PDPD Coefficient Update Error Force. This bit forces PC_UPDATE_ERR
    ///< bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t FORCE_CMEM_OVLP_CHNL_ERR : 1;
    ///< Capture Memory Channel Data Select Overlap Error Force. This bit forces
    ///< CMEM_OVLP_CHNL_ERR bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t FORCE_CMEM_OVLP_V2D_ERR : 1;
    ///< Capture Memory V2D Data Select Overlap Error Force. This bit forces
    ///< CMEM_OVLP_V2D_ERR bit to 1 in INT_STATUS register for interrupt.
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_int_csr_int_force_reg_t;

#define AV2D_CSR_INT_CSR_INT_FORCE_DEFAULT (0x00000000U)
#define AV2D_CSR_INT_CSR_INT_FORCE_RD_MASK (0xffffffffU)
#define AV2D_CSR_INT_CSR_INT_FORCE_WR_MASK (0xffffffffU)


///< Tx Buffer 0 ECC Single-bit Error Force. This bit forces TX_BUF_0_ECC_SBE
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_SBE_BF_OFF ( 0)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_SBE_BF_MSK (0x00000001)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_SBE_BF_DEF (0x00000000)

///< Tx Buffer 0 ECC Multi-bit Error Force. This bit forces TX_BUF_0_ECC_DBE
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_DBE_BF_OFF ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_DBE_BF_MSK (0x00000002)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_DBE_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC Single-bit Error Force. This bit forces TX_BUF_1_ECC_SBE
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_SBE_BF_OFF ( 2)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_SBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_SBE_BF_MSK (0x00000004)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_SBE_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC Multi-bit Error Force. This bit forces TX_BUF_1_ECC_DBE
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_DBE_BF_OFF ( 3)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_DBE_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_DBE_BF_MSK (0x00000008)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_DBE_BF_DEF (0x00000000)

///< Tx Buffer 0 ECC SBE Count Overflow Force. This bit forces TX_BUF_0_ECC_SBE_CNT_OVFL
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_OFF ( 4)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_MSK (0x00000010)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_0_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< Tx Buffer 1 ECC SBE Count Overflow Force. This bit forces TX_BUF_1_ECC_SBE_CNT_OVFL
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_OFF ( 5)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_MSK (0x00000020)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_BUF_1_ECC_SBE_CNT_OVFL_BF_DEF (0x00000000)

///< PDPD Main No Data Start Force. This bit forces PD_MAIN_NODATA_START
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_MAIN_NODATA_START_BF_OFF ( 6)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_MAIN_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_MAIN_NODATA_START_BF_MSK (0x00000040)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_MAIN_NODATA_START_BF_DEF (0x00000000)

///< PDPD Extra No Data Start Force. This bit forces PD_EXTRA_NODATA_START
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_EXTRA_NODATA_START_BF_OFF ( 7)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_EXTRA_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_EXTRA_NODATA_START_BF_MSK (0x00000080)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_EXTRA_NODATA_START_BF_DEF (0x00000000)

///< Rx HBI 0 Overflow Drop Force. This bit forces RX_HBI_0_OVFL_DROP bit
///< to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_HBI_0_OVFL_DROP_BF_OFF ( 8)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_HBI_0_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_HBI_0_OVFL_DROP_BF_MSK (0x00000100)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_HBI_0_OVFL_DROP_BF_DEF (0x00000000)

///< Rx HBI 1 Overflow Drop Force. This bit forces RX_HBI_1_OVFL_DROP bit
///< to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_HBI_1_OVFL_DROP_BF_OFF ( 9)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_HBI_1_OVFL_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_HBI_1_OVFL_DROP_BF_MSK (0x00000200)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_HBI_1_OVFL_DROP_BF_DEF (0x00000000)

///< Rx 0 No Cfg Drop Force. This bit forces RX_0_NOCFG_DROP bit to 1 in
///< INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_0_NOCFG_DROP_BF_OFF (10)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_0_NOCFG_DROP_BF_MSK (0x00000400)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_0_NOCFG_DROP_BF_DEF (0x00000000)

///< Rx 1 No Cfg Drop Force. This bit forces RX_1_NOCFG_DROP bit to 1 in
///< INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_1_NOCFG_DROP_BF_OFF (11)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_1_NOCFG_DROP_BF_MSK (0x00000800)
#define AV2D_CSR_INT_CSR_INT_FORCE_RX_1_NOCFG_DROP_BF_DEF (0x00000000)

///< Tx Underrun Force. This bit forces TX_UNDERRUN bit to 1 in INT_STATUS
///< register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_UNDERRUN_BF_OFF (12)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_UNDERRUN_BF_MSK (0x00001000)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_UNDERRUN_BF_DEF (0x00000000)

///< Tx No Data Start Force. This bit forces TX_NODATA_START bit to 1 in
///< INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_NODATA_START_BF_OFF (13)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_NODATA_START_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_NODATA_START_BF_MSK (0x00002000)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_NODATA_START_BF_DEF (0x00000000)

///< SMON Interrupt Force. This bit forces SMON_INTR bit to 1 in INT_STATUS
///< register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_SMON_INTR_BF_OFF (14)
#define AV2D_CSR_INT_CSR_INT_FORCE_SMON_INTR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_SMON_INTR_BF_MSK (0x00004000)
#define AV2D_CSR_INT_CSR_INT_FORCE_SMON_INTR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Collide with HBI Force. This bit forces
///< PC_HBI_AXI bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_AXI_BF_OFF (15)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_AXI_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_AXI_BF_MSK (0x00008000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_AXI_BF_DEF (0x00000000)

///< Tx HBI 0 No-Config Data Drop Force. This bit forces TX_HBI_0_NOCFG_DROP
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_HBI_0_NOCFG_DROP_BF_OFF (16)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_HBI_0_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_HBI_0_NOCFG_DROP_BF_MSK (0x00010000)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_HBI_0_NOCFG_DROP_BF_DEF (0x00000000)

///< Tx HBI 1 No-Config Data Drop Force. This bit forces TX_HBI_1_NOCFG_DROP
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_HBI_1_NOCFG_DROP_BF_OFF (17)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_HBI_1_NOCFG_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_HBI_1_NOCFG_DROP_BF_MSK (0x00020000)
#define AV2D_CSR_INT_CSR_INT_FORCE_TX_HBI_1_NOCFG_DROP_BF_DEF (0x00000000)

///< PDPD Main Data Underrun Force. This bit forces PD_MAIN_UNDERRUN bit
///< to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_MAIN_UNDERRUN_BF_OFF (18)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_MAIN_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_MAIN_UNDERRUN_BF_MSK (0x00040000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_MAIN_UNDERRUN_BF_DEF (0x00000000)

///< PDPD Extra Data Underrun Force. This bit forces PD_EXTRA_UNDERRUN
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_EXTRA_UNDERRUN_BF_OFF (19)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_EXTRA_UNDERRUN_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_EXTRA_UNDERRUN_BF_MSK (0x00080000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PD_EXTRA_UNDERRUN_BF_DEF (0x00000000)

///< PDPD Coefficient Update Data Drop on HBI Force. This bit forces PC_HBI_DROP
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_DROP_BF_OFF (20)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_DROP_BF_MSK (0x00100000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_DROP_BF_DEF (0x00000000)

///< PDPD Coefficient Update Timeout on HBI Force. This bit forces PC_HBI_TIMEOUT
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_TIMEOUT_BF_OFF (21)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_TIMEOUT_BF_MSK (0x00200000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_TIMEOUT_BF_DEF (0x00000000)

///< PDPD Coefficient Update M2 In M1 on HBI Force. This bit forces PC_HBI_M2_IN_M1
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_M2_IN_M1_BF_OFF (22)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_M2_IN_M1_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_M2_IN_M1_BF_MSK (0x00400000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_HBI_M2_IN_M1_BF_DEF (0x00000000)

///< PDPD Coefficient Update Timeout on AXI Force. This bit forces PC_AXI_TIMEOUT
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_TIMEOUT_BF_OFF (23)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_TIMEOUT_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_TIMEOUT_BF_MSK (0x00800000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_TIMEOUT_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Size Error Force. This bit forces
///< PC_AXI_SIZE_ERR bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_SIZE_ERR_BF_OFF (24)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_SIZE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_SIZE_ERR_BF_MSK (0x01000000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_SIZE_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Strobe Error Force. This bit forces
///< PC_AXI_STROBE_ERR bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_STROBE_ERR_BF_OFF (25)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_STROBE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_STROBE_ERR_BF_MSK (0x02000000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_STROBE_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Write Length Error Force. This bit forces
///< PC_AXI_LENGTH_ERR bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_LENGTH_ERR_BF_OFF (26)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_LENGTH_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_LENGTH_ERR_BF_MSK (0x04000000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_LENGTH_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update Data Drop on AXI Write Start Error Force.
///< This bit forces PC_AXI_ERR_DROP bit to 1 in INT_STATUS register for
///< interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_ERR_DROP_BF_OFF (27)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_ERR_DROP_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_ERR_DROP_BF_MSK (0x08000000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_ERR_DROP_BF_DEF (0x00000000)

///< PDPD Coefficient Update AXI Read Error Force. This bit forces PC_AXI_READ_ERR
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_READ_ERR_BF_OFF (28)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_READ_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_READ_ERR_BF_MSK (0x10000000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_AXI_READ_ERR_BF_DEF (0x00000000)

///< PDPD Coefficient Update Error Force. This bit forces PC_UPDATE_ERR
///< bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_UPDATE_ERR_BF_OFF (29)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_UPDATE_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_UPDATE_ERR_BF_MSK (0x20000000)
#define AV2D_CSR_INT_CSR_INT_FORCE_PC_UPDATE_ERR_BF_DEF (0x00000000)

///< Capture Memory Channel Data Select Overlap Error Force. This bit forces
///< CMEM_OVLP_CHNL_ERR bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_CMEM_OVLP_CHNL_ERR_BF_OFF (30)
#define AV2D_CSR_INT_CSR_INT_FORCE_CMEM_OVLP_CHNL_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_CMEM_OVLP_CHNL_ERR_BF_MSK (0x40000000)
#define AV2D_CSR_INT_CSR_INT_FORCE_CMEM_OVLP_CHNL_ERR_BF_DEF (0x00000000)

///< Capture Memory V2D Data Select Overlap Error Force. This bit forces
///< CMEM_OVLP_V2D_ERR bit to 1 in INT_STATUS register for interrupt.
#define AV2D_CSR_INT_CSR_INT_FORCE_CMEM_OVLP_V2D_ERR_BF_OFF (31)
#define AV2D_CSR_INT_CSR_INT_FORCE_CMEM_OVLP_V2D_ERR_BF_WID ( 1)
#define AV2D_CSR_INT_CSR_INT_FORCE_CMEM_OVLP_V2D_ERR_BF_MSK (0x80000000)
#define AV2D_CSR_INT_CSR_INT_FORCE_CMEM_OVLP_V2D_ERR_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_SMON_CSR_SMON_R0 register description at address offset 0x100
  *
  * Register default value:        0x40000000
  * Register full path in IP: av2d_csr_com/reg/SMON_CSR/SMON_r0
  * AW_smon CONTROL0 register
  */

typedef union {
  struct {
    uint32_t SMON_ENABLE : 1;
    ///< enable the SMON counters
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t RSVD0 : 3;
    ///< reserved
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t SMON0_FUNCTION : 3;
    ///< SMON0 function    3'h0 = free running function. Trigger to accumulate
    ///< the value into the engine SMON_COUNT when an event is valid.    3'h1
    ///< = free running function. Trigger to accumulate a fixed value of 1
    ///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
    ///< Trigger to update max value when an event is valid and larger than
    ///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
    ///< First Mode. Capture the timer value on the first occurance of an event.
    ///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
    ///< the timer value on every occurance of an event.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t SMON0_FUNCTION_COMPARE : 1;
    ///< SMON0 function_compare    1'h0 = compare mode disabled    1'h1 = compare
    ///< mode enabled
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t SMON1_FUNCTION : 3;
    ///< SMON1 function    3'h0 = free running function. Trigger to accumulate
    ///< the value into the engine SMON_COUNT when an event is valid.    3'h1
    ///< = free running function. Trigger to accumulate a fixed value of 1
    ///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
    ///< Trigger to update max value when an event is valid and larger than
    ///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
    ///< First Mode. Capture the timer value on the first occurance of an event.
    ///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
    ///< the timer value on every occurance of an event.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t SMON1_FUNCTION_COMPARE : 1;
    ///< SMON1 function_compare    1'h0 = compare mode disabled    1'h1 = compare
    ///< mode enabled
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t SMON_MODE : 4;
    ///< SMON mode     4'h0 = Independant Mode. SMON0_COUNT & SMON1_COUNT operate
    ///< independantly as their function is configured.       4'h1 = Average
    ///< Latency Mode. SMON0 trigger starts timer & SMON1 trigger stops timer.
    ///< SMON0_COUNT accumulates occurances and SMON1_COUNT accumulates timer
    ///< values. For multiple stop for a single start, accumulate  start_to_stop1,
    ///< start_to_stop1stop2 ...    4'h2 = MinMax Latency Mode,. SMON0 trigger
    ///< starts timer & SMON1 trigger stops timer. SMON0_COUNT maintains the
    ///< minimum timer value and SMON1_COUNT maintains the maximum timer value.
    ///< 4'h3 = Average Mode.   SMON0 trigger increments SMON0_COUNT and the
    ///< value is accumulated in SMON1_COUNT. SMON1 events are disabled.
    ///< 4'h4 = Average Lantecy Mode 2. same as mode01, but only accumulate
    ///< the first start_to_stop1 if there are multiple stop for each start.
    ///< 4'h5 = Average Latency Mode 3. same as mode01, but accumualte the
    ///< incremental start_to_stop1, stop1_to_stop2... if there are multiple
    ///< stop for each start.
    ///< AccessType="RW" BitOffset="12" ResetValue="0x0"
    uint32_t STOPCOUNTEROVFL : 1;
    ///< configure to stop on counter0 or counter1 overflow
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t INTCOUNTEROVFL : 1;
    ///< configure to interupt on counter0 or counter1 overflow
    ///< AccessType="RW" BitOffset="17" ResetValue="0x0"
    uint32_t STATCOUNTER0OVFL : 1;
    ///< status for counter0 overflow. A value of '1' signifies counter0 overflow.
    ///< AccessType="RW/V" BitOffset="18" ResetValue="0x0"
    uint32_t STATCOUNTER1OVFL : 1;
    ///< status for counter1 overflow. A value of '1' signifies counter1 overflow.
    ///< AccessType="RW/V" BitOffset="19" ResetValue="0x0"
    uint32_t STOPTIMEROVFL : 1;
    ///< configure to stop on timer overflow or timer>maxvalue
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t INTTIMEROVFL : 1;
    ///< configure to interrupt on timer overflow or timer>maxvalue
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t STATTIMEROVFL : 1;
    ///< status of timer overflow. A value of '1' signifies timer overflow,
    ///< or timer>maxvalue.
    ///< AccessType="RW/V" BitOffset="22" ResetValue="0x0"
    uint32_t RSVD1 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="23" ResetValue="0x0"
    uint32_t TIMER_PRESCALE : 5;
    ///< timer prescale    5'h00 = mode00, increment timer every      1 clock
    ///< 5'h01 = mode01, increment timer every      2 clocks    5'h02 = mode02,
    ///< increment timer every      4 clocks    5'h03 = mode03, increment timer
    ///< every      8 clocks    5'h04 = mode04, increment timer every     16
    ///< clocks    5'h05 = mode05, increment timer every     32 clocks    5'h06
    ///< = mode06, increment timer every     64 clocks    5'h07 = mode07, increment
    ///< timer every    128 clocks    5'h08 = mode08, increment timer every
    ///< 256 clocks    5'h09 = mode09, increment timer every    512 clocks
    ///< 5'h0a = mode10, increment timer every   1024 clocks    5'h0b = mode11,
    ///< increment timer every   2048 clocks    5'h0c = mode12, increment timer
    ///< every   4096 clocks    5'h0d = mode13, increment timer every   8192
    ///< clocks    5'h0e = mode14, increment timer every  16384 clocks    5'h0f
    ///< = mode15, increment timer every  32768 clocks    5'h10 = mode16, increment
    ///< timer every  65536 clocks    5'h11 = mode17, increment timer every
    ///< 131072 clocks    5'h12 = mode18, increment timer every 262144 clocks
    ///< 5'h13 = mode19, increment timer every 524288 clocks
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t RSVD2 : 1;
    ///< reserved
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t VERSION : 2;
    ///< version
    ///< AccessType="RO" BitOffset="30" ResetValue="0x1"
  } ;
  uint32_t value;
} av2d_csr_smon_csr_smon_r0_reg_t;

#define AV2D_CSR_SMON_CSR_SMON_R0_DEFAULT (0x40000000U)
#define AV2D_CSR_SMON_CSR_SMON_R0_RD_MASK (0xffffffffU)
#define AV2D_CSR_SMON_CSR_SMON_R0_WR_MASK (0x3fffffffU)


///< enable the SMON counters
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON_EN_BF_OFF ( 0)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON_EN_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON_EN_BF_MSK (0x00000001)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON_EN_BF_DEF (0x00000000)

///< reserved
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD0_BF_OFF ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD0_BF_WID ( 3)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD0_BF_MSK (0x0000000E)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD0_BF_DEF (0x00000000)

///< SMON0 function    3'h0 = free running function. Trigger to accumulate
///< the value into the engine SMON_COUNT when an event is valid.    3'h1
///< = free running function. Trigger to accumulate a fixed value of 1
///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
///< Trigger to update max value when an event is valid and larger than
///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
///< First Mode. Capture the timer value on the first occurance of an event.
///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
///< the timer value on every occurance of an event.
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON0_FUNCTION_BF_OFF ( 4)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON0_FUNCTION_BF_WID ( 3)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON0_FUNCTION_BF_MSK (0x00000070)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON0_FUNCTION_BF_DEF (0x00000000)

///< SMON0 function_compare    1'h0 = compare mode disabled    1'h1 = compare
///< mode enabled
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_OFF ( 7)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_MSK (0x00000080)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON0_FUNCTION_CMP_BF_DEF (0x00000000)

///< SMON1 function    3'h0 = free running function. Trigger to accumulate
///< the value into the engine SMON_COUNT when an event is valid.    3'h1
///< = free running function. Trigger to accumulate a fixed value of 1
///< into the engine SMON_COUNT when an event is valid.    3'h2 = max function.
///< Trigger to update max value when an event is valid and larger than
///< the current value stored in the engine SMON_COUNT.    3'h3 = Timestamp
///< First Mode. Capture the timer value on the first occurance of an event.
///< Need to write CONTROL01 to reset.    3'h4 = Timestamp Mode. Capture
///< the timer value on every occurance of an event.
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON1_FUNCTION_BF_OFF ( 8)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON1_FUNCTION_BF_WID ( 3)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON1_FUNCTION_BF_MSK (0x00000700)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON1_FUNCTION_BF_DEF (0x00000000)

///< SMON1 function_compare    1'h0 = compare mode disabled    1'h1 = compare
///< mode enabled
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_OFF (11)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_MSK (0x00000800)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON1_FUNCTION_CMP_BF_DEF (0x00000000)

///< SMON mode     4'h0 = Independant Mode. SMON0_COUNT & SMON1_COUNT operate
///< independantly as their function is configured.       4'h1 = Average
///< Latency Mode. SMON0 trigger starts timer & SMON1 trigger stops timer.
///< SMON0_COUNT accumulates occurances and SMON1_COUNT accumulates timer
///< values. For multiple stop for a single start, accumulate  start_to_stop1,
///< start_to_stop1stop2 ...    4'h2 = MinMax Latency Mode,. SMON0 trigger
///< starts timer & SMON1 trigger stops timer. SMON0_COUNT maintains the
///< minimum timer value and SMON1_COUNT maintains the maximum timer value.
///< 4'h3 = Average Mode.   SMON0 trigger increments SMON0_COUNT and the
///< value is accumulated in SMON1_COUNT. SMON1 events are disabled.
///< 4'h4 = Average Lantecy Mode 2. same as mode01, but only accumulate
///< the first start_to_stop1 if there are multiple stop for each start.
///< 4'h5 = Average Latency Mode 3. same as mode01, but accumualte the
///< incremental start_to_stop1, stop1_to_stop2... if there are multiple
///< stop for each start.
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON_MODE_BF_OFF (12)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON_MODE_BF_WID ( 4)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON_MODE_BF_MSK (0x0000F000)
#define AV2D_CSR_SMON_CSR_SMON_R0_SMON_MODE_BF_DEF (0x00000000)

///< configure to stop on counter0 or counter1 overflow
#define AV2D_CSR_SMON_CSR_SMON_R0_STOPCNTEROVFL_BF_OFF (16)
#define AV2D_CSR_SMON_CSR_SMON_R0_STOPCNTEROVFL_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_STOPCNTEROVFL_BF_MSK (0x00010000)
#define AV2D_CSR_SMON_CSR_SMON_R0_STOPCNTEROVFL_BF_DEF (0x00000000)

///< configure to interupt on counter0 or counter1 overflow
#define AV2D_CSR_SMON_CSR_SMON_R0_INTCNTEROVFL_BF_OFF (17)
#define AV2D_CSR_SMON_CSR_SMON_R0_INTCNTEROVFL_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_INTCNTEROVFL_BF_MSK (0x00020000)
#define AV2D_CSR_SMON_CSR_SMON_R0_INTCNTEROVFL_BF_DEF (0x00000000)

///< status for counter0 overflow. A value of '1' signifies counter0 overflow.
#define AV2D_CSR_SMON_CSR_SMON_R0_STATCNTER0OVFL_BF_OFF (18)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATCNTER0OVFL_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATCNTER0OVFL_BF_MSK (0x00040000)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATCNTER0OVFL_BF_DEF (0x00000000)

///< status for counter1 overflow. A value of '1' signifies counter1 overflow.
#define AV2D_CSR_SMON_CSR_SMON_R0_STATCNTER1OVFL_BF_OFF (19)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATCNTER1OVFL_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATCNTER1OVFL_BF_MSK (0x00080000)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATCNTER1OVFL_BF_DEF (0x00000000)

///< configure to stop on timer overflow or timer>maxvalue
#define AV2D_CSR_SMON_CSR_SMON_R0_STOPTIMEROVFL_BF_OFF (20)
#define AV2D_CSR_SMON_CSR_SMON_R0_STOPTIMEROVFL_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_STOPTIMEROVFL_BF_MSK (0x00100000)
#define AV2D_CSR_SMON_CSR_SMON_R0_STOPTIMEROVFL_BF_DEF (0x00000000)

///< configure to interrupt on timer overflow or timer>maxvalue
#define AV2D_CSR_SMON_CSR_SMON_R0_INTTIMEROVFL_BF_OFF (21)
#define AV2D_CSR_SMON_CSR_SMON_R0_INTTIMEROVFL_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_INTTIMEROVFL_BF_MSK (0x00200000)
#define AV2D_CSR_SMON_CSR_SMON_R0_INTTIMEROVFL_BF_DEF (0x00000000)

///< status of timer overflow. A value of '1' signifies timer overflow,
///< or timer>maxvalue.
#define AV2D_CSR_SMON_CSR_SMON_R0_STATTIMEROVFL_BF_OFF (22)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATTIMEROVFL_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATTIMEROVFL_BF_MSK (0x00400000)
#define AV2D_CSR_SMON_CSR_SMON_R0_STATTIMEROVFL_BF_DEF (0x00000000)

///< reserved
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD1_BF_OFF (23)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD1_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD1_BF_MSK (0x00800000)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD1_BF_DEF (0x00000000)

///< timer prescale    5'h00 = mode00, increment timer every      1 clock
///< 5'h01 = mode01, increment timer every      2 clocks    5'h02 = mode02,
///< increment timer every      4 clocks    5'h03 = mode03, increment timer
///< every      8 clocks    5'h04 = mode04, increment timer every     16
///< clocks    5'h05 = mode05, increment timer every     32 clocks    5'h06
///< = mode06, increment timer every     64 clocks    5'h07 = mode07, increment
///< timer every    128 clocks    5'h08 = mode08, increment timer every
///< 256 clocks    5'h09 = mode09, increment timer every    512 clocks
///< 5'h0a = mode10, increment timer every   1024 clocks    5'h0b = mode11,
///< increment timer every   2048 clocks    5'h0c = mode12, increment timer
///< every   4096 clocks    5'h0d = mode13, increment timer every   8192
///< clocks    5'h0e = mode14, increment timer every  16384 clocks    5'h0f
///< = mode15, increment timer every  32768 clocks    5'h10 = mode16, increment
///< timer every  65536 clocks    5'h11 = mode17, increment timer every
///< 131072 clocks    5'h12 = mode18, increment timer every 262144 clocks
///< 5'h13 = mode19, increment timer every 524288 clocks
#define AV2D_CSR_SMON_CSR_SMON_R0_TIMER_PRESCALE_BF_OFF (24)
#define AV2D_CSR_SMON_CSR_SMON_R0_TIMER_PRESCALE_BF_WID ( 5)
#define AV2D_CSR_SMON_CSR_SMON_R0_TIMER_PRESCALE_BF_MSK (0x1F000000)
#define AV2D_CSR_SMON_CSR_SMON_R0_TIMER_PRESCALE_BF_DEF (0x00000000)

///< reserved
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD2_BF_OFF (29)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD2_BF_WID ( 1)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD2_BF_MSK (0x20000000)
#define AV2D_CSR_SMON_CSR_SMON_R0_RSVD2_BF_DEF (0x00000000)

///< version
#define AV2D_CSR_SMON_CSR_SMON_R0_VER_BF_OFF (30)
#define AV2D_CSR_SMON_CSR_SMON_R0_VER_BF_WID ( 2)
#define AV2D_CSR_SMON_CSR_SMON_R0_VER_BF_MSK (0xC0000000)
#define AV2D_CSR_SMON_CSR_SMON_R0_VER_BF_DEF (0x40000000)


/** @brief AV2D_CSR_COM_REG_SMON_CSR_SMON_R1 register description at address offset 0x104
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/SMON_CSR/SMON_r1
  * AW_smon CONTROL1 register
  */

typedef union {
  struct {
    uint32_t MODE0 : 8;
    ///< select input signal for SMON0 engine. <br/>  0x0  = Triggered by NSIP
    ///< 0 B2H FIFO pop signal, b2h_ff_pop. Counter input is connected to b2h_ff_pop_data[31:0]
    ///< . <br/> 0x1  = Triggered by NSIP 0 B2H FIFO pop signal, b2h_ff_pop.
    ///< Counter input is connected to  22d0, b2h_ff_pop_data[521:512] . <br/>
    ///< 0x2  = Triggered by NSIP 1 B2H FIFO pop signal, b2h_ff_pop. Counter
    ///< input is connected to b2h_ff_pop_data[31:0] . <br/>  0x3  = Triggered
    ///< by NSIP 1 B2H FIFO pop signal, b2h_ff_pop. Counter input is connected
    ///< to  22d0, b2h_ff_pop_data[521:512] . <br/>  0x4  = Triggered by NSIP
    ///< 0 H2B FIFO push signal, h2b_ff_push. Counter input is connected to
    ///< h2b_ff_push_data[31:0] . <br/>  0x5  = Triggered by NSIP 0 H2B FIFO
    ///< push signal, h2b_ff_push. Counter input is connected to  22d0, h2b_ff_push_data[521:512]
    ///< . <br/>  0x6  = Triggered by NSIP 1 H2B FIFO push signal, h2b_ff_push.
    ///< Counter input is connected to h2b_ff_push_data[31:0] . <br/>  0x7
    ///< = Triggered by NSIP 1 H2B FIFO push signal, h2b_ff_push. Counter input
    ///< is connected to  22d0, h2b_ff_push_data[521:512] . <br/>  0x8  = Triggered
    ///< by NSIP 1 PDPD Coefficient data valid signal, hbi_coef_v. Counter
    ///< input is connected to hbi_coef_data[31:0]. <br/>  0x9  = Triggered
    ///< by NSIP 1 PDPD Coefficient data valid signal, hbi_coef_v. Counter
    ///< input is connected to  31d0, hbi_coef_idx . <br/>  0xA  = Triggered
    ///< by Coefficient AXI AW valid signal, i_axi4_m_awvalid. Counter input
    ///< is connected to  o_axi4_m_awready, 1d0, i_axi4_m_awid, i_axi4_m_awsize,
    ///< i_axi4_m_awaddr . <br/>  0xB  = Triggered by Coefficient AXI W valid
    ///< signal, i_axi4_m_wvalid. Counter input is connected to i_axi4_m_wdata[31:0].
    ///< <br/>  0xC  = Triggered by Coefficient AXI W valid signal, i_axi4_m_wvalid.
    ///< Counter input is connected to  o_axi4_m_wready, 14d0, i_axi4_m_w.last,
    ///< i_axi4_m_w.strb . <br/>  0xD  = Triggered by Coefficient AXI B valid
    ///< signal, i_axi4_m_bvalid. Counter input is connected to  i_axi4_m_bready,
    ///< 17d0, o_axi4_m_b.id, o_axi4_m_b.resp . <br/>  0xE  = Triggered by
    ///< Tx Buffer 0 Write Enalbe signal, tx_buf_mem_req[0][0].we. Counter
    ///< input is connected to tx_buf_mem_req[0][0].wdata[31:0]. <br/>  0xF
    ///< = Triggered by Tx Buffer 0 Write Enalbe signal, tx_buf_mem_req[0][0].we.
    ///< Counter input is connected to  22d0, tx_buf_mem_req[0][0].waddr .
    ///< <br/>  0x10 = Triggered by Tx Buffer 1 Write Enalbe signal, tx_buf_mem_req[1][0].we.
    ///< Counter input is connected to tx_buf_mem_req[1][0].wdata[31:0]. <br/>
    ///< 0x11 = Triggered by Tx Buffer 1 Write Enalbe signal, tx_buf_mem_req[1][0].we.
    ///< Counter input is connected to  22d0, tx_buf_mem_req[1][0].waddr .
    ///< <br/>  0x12 = Triggered by Tx Buffer 0 Read Enalbe signal, tx_buf_mem_req[0][0].re.
    ///< Counter input is connected to  22d0, tx_buf_mem_req[0][0].raddr .
    ///< <br/>  0x13 = Triggered by Tx Buffer 1 Read Enalbe signal, tx_buf_mem_req[1][0].re.
    ///< Counter input is connected to  22d0, tx_buf_mem_req[1][0].raddr .
    ///< <br/>  0x14 = Triggered by abc_v2d low priority interrupt signal,
    ///< o_av2d_intr_lo. Counter input is connected to 1. <br/>  0x15 = Triggered
    ///< by abc_v2d high priority interrupt signal, o_av2d_intr_hi. Counter
    ///< input is connected to 1. <br/>  0x16 = Triggered by NSIP 0 low priority
    ///< interrupt signal, o_nsip_intr_lo[0]. Counter input is connected to
    ///< 1. <br/>  0x17 = Triggered by NSIP 1 low priority interrupt signal,
    ///< o_nsip_intr_lo[1]. Counter input is connected to 1. <br/>  0x18 =
    ///< Triggered by NSIP 0 high priority interrupt signal, o_nsip_intr_hi[0].
    ///< Counter input is connected to 1. <br/>  0x19 = Triggered by NSIP 1
    ///< high priority interrupt signal, o_nsip_intr_hi[1]. Counter input is
    ///< connected to 1. <br/>
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MODE1 : 8;
    ///< select input signal for SMON1 engine. <br/>  0x0  = Triggered by NSIP
    ///< 0 B2H FIFO pop signal, b2h_ff_pop. Counter input is connected to b2h_ff_pop_data[31:0]
    ///< . <br/> 0x1  = Triggered by NSIP 0 B2H FIFO pop signal, b2h_ff_pop.
    ///< Counter input is connected to  22d0, b2h_ff_pop_data[521:512] . <br/>
    ///< 0x2  = Triggered by NSIP 1 B2H FIFO pop signal, b2h_ff_pop. Counter
    ///< input is connected to b2h_ff_pop_data[31:0] . <br/>  0x3  = Triggered
    ///< by NSIP 1 B2H FIFO pop signal, b2h_ff_pop. Counter input is connected
    ///< to  22d0, b2h_ff_pop_data[521:512] . <br/>  0x4  = Triggered by NSIP
    ///< 0 H2B FIFO push signal, h2b_ff_push. Counter input is connected to
    ///< h2b_ff_push_data[31:0] . <br/>  0x5  = Triggered by NSIP 0 H2B FIFO
    ///< push signal, h2b_ff_push. Counter input is connected to  22d0, h2b_ff_push_data[521:512]
    ///< . <br/>  0x6  = Triggered by NSIP 1 H2B FIFO push signal, h2b_ff_push.
    ///< Counter input is connected to h2b_ff_push_data[31:0] . <br/>  0x7
    ///< = Triggered by NSIP 1 H2B FIFO push signal, h2b_ff_push. Counter input
    ///< is connected to  22d0, h2b_ff_push_data[521:512] . <br/>  0x8  = Triggered
    ///< by NSIP 1 PDPD Coefficient data valid signal, hbi_coef_v. Counter
    ///< input is connected to hbi_coef_data[31:0]. <br/>  0x9  = Triggered
    ///< by NSIP 1 PDPD Coefficient data valid signal, hbi_coef_v. Counter
    ///< input is connected to  31d0, hbi_coef_idx . <br/>  0xA  = Triggered
    ///< by Coefficient AXI AW valid signal, i_axi4_m_awvalid. Counter input
    ///< is connected to  o_axi4_m_awready, 1d0, i_axi4_m_awid, i_axi4_m_awsize,
    ///< i_axi4_m_awaddr . <br/>  0xB  = Triggered by Coefficient AXI W valid
    ///< signal, i_axi4_m_wvalid. Counter input is connected to i_axi4_m_wdata[31:0].
    ///< <br/>  0xC  = Triggered by Coefficient AXI W valid signal, i_axi4_m_wvalid.
    ///< Counter input is connected to  o_axi4_m_wready, 14d0, i_axi4_m_w.last,
    ///< i_axi4_m_w.strb . <br/>  0xD  = Triggered by Coefficient AXI B valid
    ///< signal, i_axi4_m_bvalid. Counter input is connected to  i_axi4_m_bready,
    ///< 17d0, o_axi4_m_b.id, o_axi4_m_b.resp . <br/>  0xE  = Triggered by
    ///< Tx Buffer 0 Write Enalbe signal, tx_buf_mem_req[0][0].we. Counter
    ///< input is connected to tx_buf_mem_req[0][0].wdata[31:0]. <br/>  0xF
    ///< = Triggered by Tx Buffer 0 Write Enalbe signal, tx_buf_mem_req[0][0].we.
    ///< Counter input is connected to  22d0, tx_buf_mem_req[0][0].waddr .
    ///< <br/>  0x10 = Triggered by Tx Buffer 1 Write Enalbe signal, tx_buf_mem_req[1][0].we.
    ///< Counter input is connected to tx_buf_mem_req[1][0].wdata[31:0]. <br/>
    ///< 0x11 = Triggered by Tx Buffer 1 Write Enalbe signal, tx_buf_mem_req[1][0].we.
    ///< Counter input is connected to  22d0, tx_buf_mem_req[1][0].waddr .
    ///< <br/>  0x12 = Triggered by Tx Buffer 0 Read Enalbe signal, tx_buf_mem_req[0][0].re.
    ///< Counter input is connected to  22d0, tx_buf_mem_req[0][0].raddr .
    ///< <br/>  0x13 = Triggered by Tx Buffer 1 Read Enalbe signal, tx_buf_mem_req[1][0].re.
    ///< Counter input is connected to  22d0, tx_buf_mem_req[1][0].raddr .
    ///< <br/>  0x14 = Triggered by abc_v2d low priority interrupt signal,
    ///< o_av2d_intr_lo. Counter input is connected to 1. <br/>  0x15 = Triggered
    ///< by abc_v2d high priority interrupt signal, o_av2d_intr_hi. Counter
    ///< input is connected to 1. <br/>  0x16 = Triggered by NSIP 0 low priority
    ///< interrupt signal, o_nsip_intr_lo[0]. Counter input is connected to
    ///< 1. <br/>  0x17 = Triggered by NSIP 1 low priority interrupt signal,
    ///< o_nsip_intr_lo[1]. Counter input is connected to 1. <br/>  0x18 =
    ///< Triggered by NSIP 0 high priority interrupt signal, o_nsip_intr_hi[0].
    ///< Counter input is connected to 1. <br/>  0x19 = Triggered by NSIP 1
    ///< high priority interrupt signal, o_nsip_intr_hi[1]. Counter input is
    ///< connected to 1. <br/>
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t RSVD : 16;
    ///< reserved
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_smon_csr_smon_r1_reg_t;

#define AV2D_CSR_SMON_CSR_SMON_R1_DEFAULT (0x00000000U)
#define AV2D_CSR_SMON_CSR_SMON_R1_RD_MASK (0xffffffffU)
#define AV2D_CSR_SMON_CSR_SMON_R1_WR_MASK (0xffffffffU)


///< select input signal for SMON0 engine. <br/>  0x0  = Triggered by NSIP
///< 0 B2H FIFO pop signal, b2h_ff_pop. Counter input is connected to b2h_ff_pop_data[31:0]
///< . <br/> 0x1  = Triggered by NSIP 0 B2H FIFO pop signal, b2h_ff_pop.
///< Counter input is connected to  22d0, b2h_ff_pop_data[521:512] . <br/>
///< 0x2  = Triggered by NSIP 1 B2H FIFO pop signal, b2h_ff_pop. Counter
///< input is connected to b2h_ff_pop_data[31:0] . <br/>  0x3  = Triggered
///< by NSIP 1 B2H FIFO pop signal, b2h_ff_pop. Counter input is connected
///< to  22d0, b2h_ff_pop_data[521:512] . <br/>  0x4  = Triggered by NSIP
///< 0 H2B FIFO push signal, h2b_ff_push. Counter input is connected to
///< h2b_ff_push_data[31:0] . <br/>  0x5  = Triggered by NSIP 0 H2B FIFO
///< push signal, h2b_ff_push. Counter input is connected to  22d0, h2b_ff_push_data[521:512]
///< . <br/>  0x6  = Triggered by NSIP 1 H2B FIFO push signal, h2b_ff_push.
///< Counter input is connected to h2b_ff_push_data[31:0] . <br/>  0x7
///< = Triggered by NSIP 1 H2B FIFO push signal, h2b_ff_push. Counter input
///< is connected to  22d0, h2b_ff_push_data[521:512] . <br/>  0x8  = Triggered
///< by NSIP 1 PDPD Coefficient data valid signal, hbi_coef_v. Counter
///< input is connected to hbi_coef_data[31:0]. <br/>  0x9  = Triggered
///< by NSIP 1 PDPD Coefficient data valid signal, hbi_coef_v. Counter
///< input is connected to  31d0, hbi_coef_idx . <br/>  0xA  = Triggered
///< by Coefficient AXI AW valid signal, i_axi4_m_awvalid. Counter input
///< is connected to  o_axi4_m_awready, 1d0, i_axi4_m_awid, i_axi4_m_awsize,
///< i_axi4_m_awaddr . <br/>  0xB  = Triggered by Coefficient AXI W valid
///< signal, i_axi4_m_wvalid. Counter input is connected to i_axi4_m_wdata[31:0].
///< <br/>  0xC  = Triggered by Coefficient AXI W valid signal, i_axi4_m_wvalid.
///< Counter input is connected to  o_axi4_m_wready, 14d0, i_axi4_m_w.last,
///< i_axi4_m_w.strb . <br/>  0xD  = Triggered by Coefficient AXI B valid
///< signal, i_axi4_m_bvalid. Counter input is connected to  i_axi4_m_bready,
///< 17d0, o_axi4_m_b.id, o_axi4_m_b.resp . <br/>  0xE  = Triggered by
///< Tx Buffer 0 Write Enalbe signal, tx_buf_mem_req[0][0].we. Counter
///< input is connected to tx_buf_mem_req[0][0].wdata[31:0]. <br/>  0xF
///< = Triggered by Tx Buffer 0 Write Enalbe signal, tx_buf_mem_req[0][0].we.
///< Counter input is connected to  22d0, tx_buf_mem_req[0][0].waddr .
///< <br/>  0x10 = Triggered by Tx Buffer 1 Write Enalbe signal, tx_buf_mem_req[1][0].we.
///< Counter input is connected to tx_buf_mem_req[1][0].wdata[31:0]. <br/>
///< 0x11 = Triggered by Tx Buffer 1 Write Enalbe signal, tx_buf_mem_req[1][0].we.
///< Counter input is connected to  22d0, tx_buf_mem_req[1][0].waddr .
///< <br/>  0x12 = Triggered by Tx Buffer 0 Read Enalbe signal, tx_buf_mem_req[0][0].re.
///< Counter input is connected to  22d0, tx_buf_mem_req[0][0].raddr .
///< <br/>  0x13 = Triggered by Tx Buffer 1 Read Enalbe signal, tx_buf_mem_req[1][0].re.
///< Counter input is connected to  22d0, tx_buf_mem_req[1][0].raddr .
///< <br/>  0x14 = Triggered by abc_v2d low priority interrupt signal,
///< o_av2d_intr_lo. Counter input is connected to 1. <br/>  0x15 = Triggered
///< by abc_v2d high priority interrupt signal, o_av2d_intr_hi. Counter
///< input is connected to 1. <br/>  0x16 = Triggered by NSIP 0 low priority
///< interrupt signal, o_nsip_intr_lo[0]. Counter input is connected to
///< 1. <br/>  0x17 = Triggered by NSIP 1 low priority interrupt signal,
///< o_nsip_intr_lo[1]. Counter input is connected to 1. <br/>  0x18 =
///< Triggered by NSIP 0 high priority interrupt signal, o_nsip_intr_hi[0].
///< Counter input is connected to 1. <br/>  0x19 = Triggered by NSIP 1
///< high priority interrupt signal, o_nsip_intr_hi[1]. Counter input is
///< connected to 1. <br/>
#define AV2D_CSR_SMON_CSR_SMON_R1_MODE0_BF_OFF ( 0)
#define AV2D_CSR_SMON_CSR_SMON_R1_MODE0_BF_WID ( 8)
#define AV2D_CSR_SMON_CSR_SMON_R1_MODE0_BF_MSK (0x000000FF)
#define AV2D_CSR_SMON_CSR_SMON_R1_MODE0_BF_DEF (0x00000000)

///< select input signal for SMON1 engine. <br/>  0x0  = Triggered by NSIP
///< 0 B2H FIFO pop signal, b2h_ff_pop. Counter input is connected to b2h_ff_pop_data[31:0]
///< . <br/> 0x1  = Triggered by NSIP 0 B2H FIFO pop signal, b2h_ff_pop.
///< Counter input is connected to  22d0, b2h_ff_pop_data[521:512] . <br/>
///< 0x2  = Triggered by NSIP 1 B2H FIFO pop signal, b2h_ff_pop. Counter
///< input is connected to b2h_ff_pop_data[31:0] . <br/>  0x3  = Triggered
///< by NSIP 1 B2H FIFO pop signal, b2h_ff_pop. Counter input is connected
///< to  22d0, b2h_ff_pop_data[521:512] . <br/>  0x4  = Triggered by NSIP
///< 0 H2B FIFO push signal, h2b_ff_push. Counter input is connected to
///< h2b_ff_push_data[31:0] . <br/>  0x5  = Triggered by NSIP 0 H2B FIFO
///< push signal, h2b_ff_push. Counter input is connected to  22d0, h2b_ff_push_data[521:512]
///< . <br/>  0x6  = Triggered by NSIP 1 H2B FIFO push signal, h2b_ff_push.
///< Counter input is connected to h2b_ff_push_data[31:0] . <br/>  0x7
///< = Triggered by NSIP 1 H2B FIFO push signal, h2b_ff_push. Counter input
///< is connected to  22d0, h2b_ff_push_data[521:512] . <br/>  0x8  = Triggered
///< by NSIP 1 PDPD Coefficient data valid signal, hbi_coef_v. Counter
///< input is connected to hbi_coef_data[31:0]. <br/>  0x9  = Triggered
///< by NSIP 1 PDPD Coefficient data valid signal, hbi_coef_v. Counter
///< input is connected to  31d0, hbi_coef_idx . <br/>  0xA  = Triggered
///< by Coefficient AXI AW valid signal, i_axi4_m_awvalid. Counter input
///< is connected to  o_axi4_m_awready, 1d0, i_axi4_m_awid, i_axi4_m_awsize,
///< i_axi4_m_awaddr . <br/>  0xB  = Triggered by Coefficient AXI W valid
///< signal, i_axi4_m_wvalid. Counter input is connected to i_axi4_m_wdata[31:0].
///< <br/>  0xC  = Triggered by Coefficient AXI W valid signal, i_axi4_m_wvalid.
///< Counter input is connected to  o_axi4_m_wready, 14d0, i_axi4_m_w.last,
///< i_axi4_m_w.strb . <br/>  0xD  = Triggered by Coefficient AXI B valid
///< signal, i_axi4_m_bvalid. Counter input is connected to  i_axi4_m_bready,
///< 17d0, o_axi4_m_b.id, o_axi4_m_b.resp . <br/>  0xE  = Triggered by
///< Tx Buffer 0 Write Enalbe signal, tx_buf_mem_req[0][0].we. Counter
///< input is connected to tx_buf_mem_req[0][0].wdata[31:0]. <br/>  0xF
///< = Triggered by Tx Buffer 0 Write Enalbe signal, tx_buf_mem_req[0][0].we.
///< Counter input is connected to  22d0, tx_buf_mem_req[0][0].waddr .
///< <br/>  0x10 = Triggered by Tx Buffer 1 Write Enalbe signal, tx_buf_mem_req[1][0].we.
///< Counter input is connected to tx_buf_mem_req[1][0].wdata[31:0]. <br/>
///< 0x11 = Triggered by Tx Buffer 1 Write Enalbe signal, tx_buf_mem_req[1][0].we.
///< Counter input is connected to  22d0, tx_buf_mem_req[1][0].waddr .
///< <br/>  0x12 = Triggered by Tx Buffer 0 Read Enalbe signal, tx_buf_mem_req[0][0].re.
///< Counter input is connected to  22d0, tx_buf_mem_req[0][0].raddr .
///< <br/>  0x13 = Triggered by Tx Buffer 1 Read Enalbe signal, tx_buf_mem_req[1][0].re.
///< Counter input is connected to  22d0, tx_buf_mem_req[1][0].raddr .
///< <br/>  0x14 = Triggered by abc_v2d low priority interrupt signal,
///< o_av2d_intr_lo. Counter input is connected to 1. <br/>  0x15 = Triggered
///< by abc_v2d high priority interrupt signal, o_av2d_intr_hi. Counter
///< input is connected to 1. <br/>  0x16 = Triggered by NSIP 0 low priority
///< interrupt signal, o_nsip_intr_lo[0]. Counter input is connected to
///< 1. <br/>  0x17 = Triggered by NSIP 1 low priority interrupt signal,
///< o_nsip_intr_lo[1]. Counter input is connected to 1. <br/>  0x18 =
///< Triggered by NSIP 0 high priority interrupt signal, o_nsip_intr_hi[0].
///< Counter input is connected to 1. <br/>  0x19 = Triggered by NSIP 1
///< high priority interrupt signal, o_nsip_intr_hi[1]. Counter input is
///< connected to 1. <br/>
#define AV2D_CSR_SMON_CSR_SMON_R1_MODE1_BF_OFF ( 8)
#define AV2D_CSR_SMON_CSR_SMON_R1_MODE1_BF_WID ( 8)
#define AV2D_CSR_SMON_CSR_SMON_R1_MODE1_BF_MSK (0x0000FF00)
#define AV2D_CSR_SMON_CSR_SMON_R1_MODE1_BF_DEF (0x00000000)

///< reserved
#define AV2D_CSR_SMON_CSR_SMON_R1_RSVD_BF_OFF (16)
#define AV2D_CSR_SMON_CSR_SMON_R1_RSVD_BF_WID (16)
#define AV2D_CSR_SMON_CSR_SMON_R1_RSVD_BF_MSK (0xFFFF0000)
#define AV2D_CSR_SMON_CSR_SMON_R1_RSVD_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_SMON_CSR_SMON_R2 register description at address offset 0x108
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/SMON_CSR/SMON_r2
  * AW_smon SMON0_COMPARE register
  */

typedef union {
  struct {
    uint32_t COMPARE0 : 32;
    ///< Comparison value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_smon_csr_smon_r2_reg_t;

#define AV2D_CSR_SMON_CSR_SMON_R2_DEFAULT (0x00000000U)
#define AV2D_CSR_SMON_CSR_SMON_R2_RD_MASK (0xffffffffU)
#define AV2D_CSR_SMON_CSR_SMON_R2_WR_MASK (0xffffffffU)


///< Comparison value.
#define AV2D_CSR_SMON_CSR_SMON_R2_CMP0_BF_OFF ( 0)
#define AV2D_CSR_SMON_CSR_SMON_R2_CMP0_BF_WID (32)
#define AV2D_CSR_SMON_CSR_SMON_R2_CMP0_BF_MSK (0xFFFFFFFF)
#define AV2D_CSR_SMON_CSR_SMON_R2_CMP0_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_SMON_CSR_SMON_R3 register description at address offset 0x10c
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/SMON_CSR/SMON_r3
  * AW_smon SMON1_COMPARE register
  */

typedef union {
  struct {
    uint32_t COMPARE1 : 32;
    ///< Comparison value.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_smon_csr_smon_r3_reg_t;

#define AV2D_CSR_SMON_CSR_SMON_R3_DEFAULT (0x00000000U)
#define AV2D_CSR_SMON_CSR_SMON_R3_RD_MASK (0xffffffffU)
#define AV2D_CSR_SMON_CSR_SMON_R3_WR_MASK (0xffffffffU)


///< Comparison value.
#define AV2D_CSR_SMON_CSR_SMON_R3_CMP1_BF_OFF ( 0)
#define AV2D_CSR_SMON_CSR_SMON_R3_CMP1_BF_WID (32)
#define AV2D_CSR_SMON_CSR_SMON_R3_CMP1_BF_MSK (0xFFFFFFFF)
#define AV2D_CSR_SMON_CSR_SMON_R3_CMP1_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_SMON_CSR_SMON_R4 register description at address offset 0x110
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/SMON_CSR/SMON_r4
  * AW_smon SMON0_COUNT register
  */

typedef union {
  struct {
    uint32_t COUNTER0 : 32;
    ///< counter0
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_smon_csr_smon_r4_reg_t;

#define AV2D_CSR_SMON_CSR_SMON_R4_DEFAULT (0x00000000U)
#define AV2D_CSR_SMON_CSR_SMON_R4_RD_MASK (0xffffffffU)
#define AV2D_CSR_SMON_CSR_SMON_R4_WR_MASK (0xffffffffU)


///< counter0
#define AV2D_CSR_SMON_CSR_SMON_R4_CNTER0_BF_OFF ( 0)
#define AV2D_CSR_SMON_CSR_SMON_R4_CNTER0_BF_WID (32)
#define AV2D_CSR_SMON_CSR_SMON_R4_CNTER0_BF_MSK (0xFFFFFFFF)
#define AV2D_CSR_SMON_CSR_SMON_R4_CNTER0_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_SMON_CSR_SMON_R5 register description at address offset 0x114
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/SMON_CSR/SMON_r5
  * AW_smon SMON1_COUNT register
  */

typedef union {
  struct {
    uint32_t COUNTER1 : 32;
    ///< counter1
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_smon_csr_smon_r5_reg_t;

#define AV2D_CSR_SMON_CSR_SMON_R5_DEFAULT (0x00000000U)
#define AV2D_CSR_SMON_CSR_SMON_R5_RD_MASK (0xffffffffU)
#define AV2D_CSR_SMON_CSR_SMON_R5_WR_MASK (0xffffffffU)


///< counter1
#define AV2D_CSR_SMON_CSR_SMON_R5_CNTER1_BF_OFF ( 0)
#define AV2D_CSR_SMON_CSR_SMON_R5_CNTER1_BF_WID (32)
#define AV2D_CSR_SMON_CSR_SMON_R5_CNTER1_BF_MSK (0xFFFFFFFF)
#define AV2D_CSR_SMON_CSR_SMON_R5_CNTER1_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_SMON_CSR_SMON_R6 register description at address offset 0x118
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/SMON_CSR/SMON_r6
  * AW_smon TIMER register
  */

typedef union {
  struct {
    uint32_t TIMER : 32;
    ///< timer
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_smon_csr_smon_r6_reg_t;

#define AV2D_CSR_SMON_CSR_SMON_R6_DEFAULT (0x00000000U)
#define AV2D_CSR_SMON_CSR_SMON_R6_RD_MASK (0xffffffffU)
#define AV2D_CSR_SMON_CSR_SMON_R6_WR_MASK (0xffffffffU)


///< timer
#define AV2D_CSR_SMON_CSR_SMON_R6_TIMER_BF_OFF ( 0)
#define AV2D_CSR_SMON_CSR_SMON_R6_TIMER_BF_WID (32)
#define AV2D_CSR_SMON_CSR_SMON_R6_TIMER_BF_MSK (0xFFFFFFFF)
#define AV2D_CSR_SMON_CSR_SMON_R6_TIMER_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_SMON_CSR_SMON_R7 register description at address offset 0x11c
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/SMON_CSR/SMON_r7
  * AW_smon TIMERMAXVAL register
  */

typedef union {
  struct {
    uint32_t MAXVALUE : 32;
    ///< maxvalue
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} av2d_csr_smon_csr_smon_r7_reg_t;

#define AV2D_CSR_SMON_CSR_SMON_R7_DEFAULT (0x00000000U)
#define AV2D_CSR_SMON_CSR_SMON_R7_RD_MASK (0xffffffffU)
#define AV2D_CSR_SMON_CSR_SMON_R7_WR_MASK (0xffffffffU)


///< maxvalue
#define AV2D_CSR_SMON_CSR_SMON_R7_MAXVAL_BF_OFF ( 0)
#define AV2D_CSR_SMON_CSR_SMON_R7_MAXVAL_BF_WID (32)
#define AV2D_CSR_SMON_CSR_SMON_R7_MAXVAL_BF_MSK (0xFFFFFFFF)
#define AV2D_CSR_SMON_CSR_SMON_R7_MAXVAL_BF_DEF (0x00000000)


/** @brief AV2D_CSR_COM_REG_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO[2][8] register description at address offset 0x120
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_BUF_ECC_CSR/TX_BUF_ECC_ERR_INFO
  * TX Buffer ECC Error Information Register
  */

typedef union {
  struct {
    uint32_t ERR_ADDR : 10;
    ///< ECC Error Address. This is the captured memory address of the first
    ///< DBE or SBE, but DBE has higher priority and can overwrite captured
    ///< SBE address. It can be cleared by ERR_CLR bit in the corresponding
    ///< TX_BUF_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t  : 6;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
    uint32_t ERR_SYNDROME : 8;
    ///< ECC Error Syndrome. This is the captured ECC syndrome of the first
    ///< DBE or SBE, but DBE has higher priority and can overwrite captured
    ///< SBE syndrome. It can be cleared by ERR_CLR bit in the corresponding
    ///< TX_BUF_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t SBE_COUNT : 4;
    ///< SBE Count. This is the value of the SBE counter, which doesn't roll
    ///< over and can be cleared by CNT_CLR bit in the corresponding TX_BUF_ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="24" ResetValue="0x0"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t;

#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_RD_MASK (0x0fff03ffU)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_WR_MASK (0x00000000U)


///< ECC Error Address. This is the captured memory address of the first
///< DBE or SBE, but DBE has higher priority and can overwrite captured
///< SBE address. It can be cleared by ERR_CLR bit in the corresponding
///< TX_BUF_ECC_CTRL register.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ERR_ADDR_BF_OFF ( 0)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ERR_ADDR_BF_WID (10)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ERR_ADDR_BF_MSK (0x000003FF)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ERR_ADDR_BF_DEF (0x00000000)

///< ECC Error Syndrome. This is the captured ECC syndrome of the first
///< DBE or SBE, but DBE has higher priority and can overwrite captured
///< SBE syndrome. It can be cleared by ERR_CLR bit in the corresponding
///< TX_BUF_ECC_CTRL register.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ERR_SYNDROME_BF_OFF (16)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ERR_SYNDROME_BF_WID ( 8)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ERR_SYNDROME_BF_MSK (0x00FF0000)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ERR_SYNDROME_BF_DEF (0x00000000)

///< SBE Count. This is the value of the SBE counter, which doesn't roll
///< over and can be cleared by CNT_CLR bit in the corresponding TX_BUF_ECC_CTRL
///< register.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_SBE_CNT_BF_OFF (24)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_SBE_CNT_BF_WID ( 4)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_SBE_CNT_BF_MSK (0x0F000000)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_SBE_CNT_BF_DEF (0x00000000)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ARR_SZ0 (2)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ARRAY_STRIDE0 (0x0050)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ARR_SZ1 (8)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_INFO_ARRAY_STRIDE1 (0x0004)


/** @brief AV2D_CSR_COM_REG_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL[2][8] register description at address offset 0x140
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_BUF_ECC_CSR/TX_BUF_ECC_CTRL
  * TX Buffer ECC Control Register
  */

typedef union {
  struct {
    uint32_t FORCE_TYPE : 1;
    ///< Force Error Type. This bit indicates the type of ECC errors forced
    ///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FORCE_ERR : 1;
    ///< Force Error. When set to 1, this bit enables to insert one ECC error
    ///< determined by FORCE_TYPE. It's automatically cleared when the expected
    ///< ECC error is seen by hardware.
    ///< AccessType="RW/V" BitOffset="1" ResetValue="0x0"
    uint32_t ERR_CLR : 1;
    ///< Error Clear. Writing this bit to 1 clears SBE, DBE, ERR_ADDR and ERR_SYNDROME
    ///< status and information of the correponding memory slice. This bit
    ///< retains the last written value.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t CNT_CLR : 1;
    ///< Count Clear. Writing this bit to 1 clears SBE_COUNT and SBE_CNT_OVFL
    ///< status and information of the corresponding memory slice. This bit
    ///< retains the last written value.
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t CHK_DIS : 1;
    ///< Check and Correction Disable. When set, this bit disables ECC checking
    ///< and correction for the corresponding memory slice. It's used for debug
    ///< and testing purpose.
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t GEN_DIS : 1;
    ///< Generation Disable. When set, this bit disables ECC generation for
    ///< the corresponding memory slice. It's used for debug and testing purpose.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t;

#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_RD_MASK (0x0000003fU)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_WR_MASK (0x0000003fU)


///< Force Error Type. This bit indicates the type of ECC errors forced
///< to be inserted. 1=Double Bit Error(DBE), 0=Single Bit Error(SBE).
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_FORCE_TYPE_BF_OFF ( 0)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_FORCE_TYPE_BF_WID ( 1)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_FORCE_TYPE_BF_MSK (0x00000001)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_FORCE_TYPE_BF_DEF (0x00000000)

///< Force Error. When set to 1, this bit enables to insert one ECC error
///< determined by FORCE_TYPE. It's automatically cleared when the expected
///< ECC error is seen by hardware.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_FORCE_ERR_BF_OFF ( 1)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_FORCE_ERR_BF_WID ( 1)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_FORCE_ERR_BF_MSK (0x00000002)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_FORCE_ERR_BF_DEF (0x00000000)

///< Error Clear. Writing this bit to 1 clears SBE, DBE, ERR_ADDR and ERR_SYNDROME
///< status and information of the correponding memory slice. This bit
///< retains the last written value.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_ERR_CLR_BF_OFF ( 2)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_ERR_CLR_BF_WID ( 1)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_ERR_CLR_BF_MSK (0x00000004)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_ERR_CLR_BF_DEF (0x00000000)

///< Count Clear. Writing this bit to 1 clears SBE_COUNT and SBE_CNT_OVFL
///< status and information of the corresponding memory slice. This bit
///< retains the last written value.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_CNT_CLR_BF_OFF ( 3)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_CNT_CLR_BF_WID ( 1)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_CNT_CLR_BF_MSK (0x00000008)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_CNT_CLR_BF_DEF (0x00000000)

///< Check and Correction Disable. When set, this bit disables ECC checking
///< and correction for the corresponding memory slice. It's used for debug
///< and testing purpose.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_CHK_DIS_BF_OFF ( 4)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_CHK_DIS_BF_WID ( 1)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_CHK_DIS_BF_MSK (0x00000010)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_CHK_DIS_BF_DEF (0x00000000)

///< Generation Disable. When set, this bit disables ECC generation for
///< the corresponding memory slice. It's used for debug and testing purpose.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_GEN_DIS_BF_OFF ( 5)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_GEN_DIS_BF_WID ( 1)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_GEN_DIS_BF_MSK (0x00000020)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_GEN_DIS_BF_DEF (0x00000000)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_ARR_SZ0 (2)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_ARRAY_STRIDE0 (0x0050)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_ARR_SZ1 (8)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_CTRL_ARRAY_STRIDE1 (0x0004)


/** @brief AV2D_CSR_COM_REG_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_STAT[2] register description at address offset 0x160
  *
  * Register default value:        0x00000000
  * Register full path in IP: av2d_csr_com/reg/TX_BUF_ECC_CSR0/TX_BUF_ECC_ERR_STAT
  * TX Buffer ECC Error Status Register
  */

typedef union {
  struct {
    uint32_t SBE : 8;
    ///< ECC Single Bit Error. Each bit is for an ECC protected memory slice
    ///< in a Tx buffer, and when high, indicates an ECC single bit error was
    ///< detected, and can be cleared by ERR_CLR bit in corresponding TX_BUF_ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t DBE : 8;
    ///< ECC Double/Multi Bit Error. Each bit is for an ECC protected memory
    ///< slice in a Tx buffer, and when high, indicates an ECC double/multi
    ///< bit error was detected, and can be cleared by ERR_CLR bit in corresponding
    ///< TX_BUF_ECC_CTRL register.
    ///< AccessType="RO/V" BitOffset="8" ResetValue="0x0"
    uint32_t SBE_CNT_OVFL : 8;
    ///< SBE Count Overflow. Each bit is for an ECC protected memory slice
    ///< in a Tx buffer, and when high, indicates the SBE_COUNT[3:0] is overflowed.
    ///< It can be cleared by CNT_CLR bit in corresponding TX_BUF_ECC_CTRL
    ///< register.
    ///< AccessType="RO/V" BitOffset="16" ResetValue="0x0"
    uint32_t  : 8;
    ///< Reserved
    ///< AccessType="RO" BitOffset="24" ResetValue="None"
  } ;
  uint32_t value;
} av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_stat_reg_t;

#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_DEFAULT (0x00000000U)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_RD_MASK (0x00ffffffU)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_WR_MASK (0x00000000U)


///< ECC Single Bit Error. Each bit is for an ECC protected memory slice
///< in a Tx buffer, and when high, indicates an ECC single bit error was
///< detected, and can be cleared by ERR_CLR bit in corresponding TX_BUF_ECC_CTRL
///< register.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_SBE_BF_OFF ( 0)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_SBE_BF_WID ( 8)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_SBE_BF_MSK (0x000000FF)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_SBE_BF_DEF (0x00000000)

///< ECC Double/Multi Bit Error. Each bit is for an ECC protected memory
///< slice in a Tx buffer, and when high, indicates an ECC double/multi
///< bit error was detected, and can be cleared by ERR_CLR bit in corresponding
///< TX_BUF_ECC_CTRL register.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_DBE_BF_OFF ( 8)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_DBE_BF_WID ( 8)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_DBE_BF_MSK (0x0000FF00)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_DBE_BF_DEF (0x00000000)

///< SBE Count Overflow. Each bit is for an ECC protected memory slice
///< in a Tx buffer, and when high, indicates the SBE_COUNT[3:0] is overflowed.
///< It can be cleared by CNT_CLR bit in corresponding TX_BUF_ECC_CTRL
///< register.
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_SBE_CNT_OVFL_BF_OFF (16)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_SBE_CNT_OVFL_BF_WID ( 8)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_SBE_CNT_OVFL_BF_MSK (0x00FF0000)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_SBE_CNT_OVFL_BF_DEF (0x00000000)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_ARR_SZ0 (2)
#define AV2D_CSR_TX_BUF_ECC_CSR_TX_BUF_ECC_ERR_STAT_ARRAY_STRIDE0 (0x0050)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define AV2D_CSR_AV2D_SCRATCH_REG(_BASE) ((av2d_csr_av2d_scratch_reg_t*) AV2D_CSR_AV2D_SCRATCH_ADR(_BASE))
#define AV2D_CSR_APB_BRI_STAT_REG(_BASE) ((av2d_csr_apb_bri_stat_reg_t*) AV2D_CSR_APB_BRI_STAT_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_GNRL_CSR_REG(_BASE) ((av2d_csr_tx_csr_tx_gnrl_csr_reg_t*) AV2D_CSR_TX_CSR_TX_GNRL_CSR_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_SIF_CTRL_REG(_BASE) ((av2d_csr_tx_csr_tx_sif_ctrl_reg_t*) AV2D_CSR_TX_CSR_TX_SIF_CTRL_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_REG(_BASE) ((av2d_csr_tx_csr_tx_sif_smpl_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_SIF_SMPL_CNT_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_BUF_STAT_REG(_BASE) ((av2d_csr_tx_csr_tx_buf_stat_reg_t*) AV2D_CSR_TX_CSR_TX_BUF_STAT_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND0_REG(_BASE) ((av2d_csr_tx_csr_tx_ptr_bound_reg_t*) AV2D_CSR_TX_CSR_TX_PTR_BOUND0_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND1_REG(_BASE) ((av2d_csr_tx_csr_tx_ptr_bound_reg_t*) AV2D_CSR_TX_CSR_TX_PTR_BOUND1_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND2_REG(_BASE) ((av2d_csr_tx_csr_tx_ptr_bound_reg_t*) AV2D_CSR_TX_CSR_TX_PTR_BOUND2_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PTR_BOUND3_REG(_BASE) ((av2d_csr_tx_csr_tx_ptr_bound_reg_t*) AV2D_CSR_TX_CSR_TX_PTR_BOUND3_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND0_REG(_BASE) ((av2d_csr_tx_csr_tx_pd_ptr_bound_reg_t*) AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND0_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND1_REG(_BASE) ((av2d_csr_tx_csr_tx_pd_ptr_bound_reg_t*) AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND1_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND2_REG(_BASE) ((av2d_csr_tx_csr_tx_pd_ptr_bound_reg_t*) AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND2_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND3_REG(_BASE) ((av2d_csr_tx_csr_tx_pd_ptr_bound_reg_t*) AV2D_CSR_TX_CSR_TX_PD_PTR_BOUND3_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_STRM_CNT0_REG(_BASE) ((av2d_csr_tx_csr_tx_strm_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_STRM_CNT0_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_STRM_CNT1_REG(_BASE) ((av2d_csr_tx_csr_tx_strm_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_STRM_CNT1_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_STRM_CNT2_REG(_BASE) ((av2d_csr_tx_csr_tx_strm_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_STRM_CNT2_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_STRM_CNT3_REG(_BASE) ((av2d_csr_tx_csr_tx_strm_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_STRM_CNT3_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT0_REG(_BASE) ((av2d_csr_tx_csr_tx_pd_strm_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_PD_STRM_CNT0_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT1_REG(_BASE) ((av2d_csr_tx_csr_tx_pd_strm_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_PD_STRM_CNT1_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT2_REG(_BASE) ((av2d_csr_tx_csr_tx_pd_strm_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_PD_STRM_CNT2_ADR(_BASE))
#define AV2D_CSR_TX_CSR_TX_PD_STRM_CNT3_REG(_BASE) ((av2d_csr_tx_csr_tx_pd_strm_cnt_reg_t*) AV2D_CSR_TX_CSR_TX_PD_STRM_CNT3_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_GNRL_CSR_REG(_BASE) ((av2d_csr_rx_csr_rx_gnrl_csr_reg_t*) AV2D_CSR_RX_CSR_RX_GNRL_CSR_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_PACKET_SZ_REG(_BASE) ((av2d_csr_rx_csr_rx_packet_sz_reg_t*) AV2D_CSR_RX_CSR_RX_PACKET_SZ_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT0_REG(_BASE) ((av2d_csr_rx_csr_rx_in_smpl_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT0_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT1_REG(_BASE) ((av2d_csr_rx_csr_rx_in_smpl_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_IN_SMPL_CNT1_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_STRM_CNT0_REG(_BASE) ((av2d_csr_rx_csr_rx_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_STRM_CNT0_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_STRM_CNT1_REG(_BASE) ((av2d_csr_rx_csr_rx_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_STRM_CNT1_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_STRM_CNT2_REG(_BASE) ((av2d_csr_rx_csr_rx_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_STRM_CNT2_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_STRM_CNT3_REG(_BASE) ((av2d_csr_rx_csr_rx_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_STRM_CNT3_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT0_REG(_BASE) ((av2d_csr_rx_csr_rx_pd_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_PD_STRM_CNT0_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT1_REG(_BASE) ((av2d_csr_rx_csr_rx_pd_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_PD_STRM_CNT1_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT2_REG(_BASE) ((av2d_csr_rx_csr_rx_pd_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_PD_STRM_CNT2_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT3_REG(_BASE) ((av2d_csr_rx_csr_rx_pd_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_PD_STRM_CNT3_ADR(_BASE))
#define AV2D_CSR_RX_CSR_RX_PD_STRM_CNT4_REG(_BASE) ((av2d_csr_rx_csr_rx_pd_strm_cnt_reg_t*) AV2D_CSR_RX_CSR_RX_PD_STRM_CNT4_ADR(_BASE))
#define AV2D_CSR_PIF_CTRL_REG(_BASE) ((av2d_csr_pif_ctrl_reg_t*) AV2D_CSR_PIF_CTRL_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START0_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_start_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START0_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START1_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_start_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START1_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START2_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_start_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START2_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START3_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_start_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_START3_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO0_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO0_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO1_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO1_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO2_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO2_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO3_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO3_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO4_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO4_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO5_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO5_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO6_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO6_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO7_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t*) AV2D_CSR_TX_BUF_WM_TX_BUF_WM_HILO7_ADR(_BASE))
#define AV2D_CSR_TX_BUF_WM_TX_START_WM_REG(_BASE) ((av2d_csr_tx_buf_wm_tx_start_wm_reg_t*) AV2D_CSR_TX_BUF_WM_TX_START_WM_ADR(_BASE))
#define AV2D_CSR_INT_CSR_INT_STAT_REG(_BASE) ((av2d_csr_int_csr_int_stat_reg_t*) AV2D_CSR_INT_CSR_INT_STAT_ADR(_BASE))
#define AV2D_CSR_INT_CSR_INT_HIGH_EN_REG(_BASE) ((av2d_csr_int_csr_int_high_en_reg_t*) AV2D_CSR_INT_CSR_INT_HIGH_EN_ADR(_BASE))
#define AV2D_CSR_INT_CSR_INT_LOW_EN_REG(_BASE) ((av2d_csr_int_csr_int_low_en_reg_t*) AV2D_CSR_INT_CSR_INT_LOW_EN_ADR(_BASE))
#define AV2D_CSR_INT_CSR_INT_CLR_REG(_BASE) ((av2d_csr_int_csr_int_clr_reg_t*) AV2D_CSR_INT_CSR_INT_CLR_ADR(_BASE))
#define AV2D_CSR_INT_CSR_INT_FORCE_REG(_BASE) ((av2d_csr_int_csr_int_force_reg_t*) AV2D_CSR_INT_CSR_INT_FORCE_ADR(_BASE))
#define AV2D_CSR_SMON_CSR_SMON_R0_REG(_BASE) ((av2d_csr_smon_csr_smon_r0_reg_t*) AV2D_CSR_SMON_CSR_SMON_R0_ADR(_BASE))
#define AV2D_CSR_SMON_CSR_SMON_R1_REG(_BASE) ((av2d_csr_smon_csr_smon_r1_reg_t*) AV2D_CSR_SMON_CSR_SMON_R1_ADR(_BASE))
#define AV2D_CSR_SMON_CSR_SMON_R2_REG(_BASE) ((av2d_csr_smon_csr_smon_r2_reg_t*) AV2D_CSR_SMON_CSR_SMON_R2_ADR(_BASE))
#define AV2D_CSR_SMON_CSR_SMON_R3_REG(_BASE) ((av2d_csr_smon_csr_smon_r3_reg_t*) AV2D_CSR_SMON_CSR_SMON_R3_ADR(_BASE))
#define AV2D_CSR_SMON_CSR_SMON_R4_REG(_BASE) ((av2d_csr_smon_csr_smon_r4_reg_t*) AV2D_CSR_SMON_CSR_SMON_R4_ADR(_BASE))
#define AV2D_CSR_SMON_CSR_SMON_R5_REG(_BASE) ((av2d_csr_smon_csr_smon_r5_reg_t*) AV2D_CSR_SMON_CSR_SMON_R5_ADR(_BASE))
#define AV2D_CSR_SMON_CSR_SMON_R6_REG(_BASE) ((av2d_csr_smon_csr_smon_r6_reg_t*) AV2D_CSR_SMON_CSR_SMON_R6_ADR(_BASE))
#define AV2D_CSR_SMON_CSR_SMON_R7_REG(_BASE) ((av2d_csr_smon_csr_smon_r7_reg_t*) AV2D_CSR_SMON_CSR_SMON_R7_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO0_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO0_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO1_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO1_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO2_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO2_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO3_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO3_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO4_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO4_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO5_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO5_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO6_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO6_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO7_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO7_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL0_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL0_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL1_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL1_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL2_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL2_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL3_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL3_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL4_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL4_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL5_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL5_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL6_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL6_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL7_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL7_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_STAT_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_stat_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_STAT_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO0_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO0_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO1_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO1_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO2_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO2_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO3_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO3_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO4_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO4_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO5_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO5_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO6_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO6_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO7_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO7_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL0_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL0_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL1_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL1_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL2_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL2_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL3_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL3_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL4_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL4_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL5_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL5_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL6_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL6_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL7_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL7_ADR(_BASE))
#define AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_STAT_REG(_BASE) ((av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_stat_reg_t*) AV2D_CSR_TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_STAT_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    av2d_csr_av2d_scratch_reg_t AV2D_SCRATCH;    /*< Address offset = 0x0 */
    av2d_csr_apb_bri_stat_reg_t APB_BRI_STAT;  /*< Address offset = 0x4 */
    const uint8_t        reservedArea0 [8];   /*< Address offset = 0x8 */
    av2d_csr_tx_csr_tx_gnrl_csr_reg_t TX_CSR_TX_GNRL_CSR; /*< Address offset = 0x10 */
    av2d_csr_tx_csr_tx_sif_ctrl_reg_t TX_CSR_TX_SIF_CTRL; /*< Address offset = 0x14 */
    av2d_csr_tx_csr_tx_sif_smpl_cnt_reg_t TX_CSR_TX_SIF_SMPL_CNT; /*< Address offset = 0x18 */
    av2d_csr_tx_csr_tx_buf_stat_reg_t TX_CSR_TX_BUF_STAT; /*< Address offset = 0x1c */
    av2d_csr_tx_csr_tx_ptr_bound_reg_t TX_CSR_TX_PTR_BOUND[4]; /*< Address offset = 0x20 */
    av2d_csr_tx_csr_tx_pd_ptr_bound_reg_t TX_CSR_TX_PD_PTR_BOUND[4]; /*< Address offset = 0x30 */
    av2d_csr_tx_csr_tx_strm_cnt_reg_t TX_CSR_TX_STRM_CNT[4]; /*< Address offset = 0x40 */
    av2d_csr_tx_csr_tx_pd_strm_cnt_reg_t TX_CSR_TX_PD_STRM_CNT[4]; /*< Address offset = 0x50 */
    av2d_csr_rx_csr_rx_gnrl_csr_reg_t RX_CSR_RX_GNRL_CSR; /*< Address offset = 0x60 */
    av2d_csr_rx_csr_rx_packet_sz_reg_t RX_CSR_RX_PACKET_SZ; /*< Address offset = 0x64 */
    av2d_csr_rx_csr_rx_in_smpl_cnt_reg_t RX_CSR_RX_IN_SMPL_CNT[2]; /*< Address offset = 0x68 */
    av2d_csr_rx_csr_rx_strm_cnt_reg_t RX_CSR_RX_STRM_CNT[4]; /*< Address offset = 0x70 */
    av2d_csr_rx_csr_rx_pd_strm_cnt_reg_t RX_CSR_RX_PD_STRM_CNT[5]; /*< Address offset = 0x80 */
    av2d_csr_pif_ctrl_reg_t PIF_CTRL;        /*< Address offset = 0x94 */
    const uint8_t        reservedArea1 [8];   /*< Address offset = 0x98 */
    av2d_csr_tx_buf_wm_tx_buf_wm_start_reg_t TX_BUF_WM_TX_BUF_WM_START[4]; /*< Address offset = 0xa0 */
    av2d_csr_tx_buf_wm_tx_buf_wm_hilo_reg_t TX_BUF_WM_TX_BUF_WM_HILO[8]; /*< Address offset = 0xb0 */
    av2d_csr_tx_buf_wm_tx_start_wm_reg_t TX_BUF_WM_TX_START_WM; /*< Address offset = 0xd0 */
    const uint8_t        reservedArea2 [12];  /*< Address offset = 0xd4 */
    av2d_csr_int_csr_int_stat_reg_t INT_CSR_INT_STAT; /*< Address offset = 0xe0 */
    av2d_csr_int_csr_int_high_en_reg_t INT_CSR_INT_HIGH_EN; /*< Address offset = 0xe4 */
    av2d_csr_int_csr_int_low_en_reg_t INT_CSR_INT_LOW_EN; /*< Address offset = 0xe8 */
    av2d_csr_int_csr_int_clr_reg_t INT_CSR_INT_CLR; /*< Address offset = 0xec */
    av2d_csr_int_csr_int_force_reg_t INT_CSR_INT_FORCE; /*< Address offset = 0xf0 */
    const uint8_t        reservedArea3 [12];  /*< Address offset = 0xf4 */
    av2d_csr_smon_csr_smon_r0_reg_t SMON_CSR_SMON_R0; /*< Address offset = 0x100 */
    av2d_csr_smon_csr_smon_r1_reg_t SMON_CSR_SMON_R1; /*< Address offset = 0x104 */
    av2d_csr_smon_csr_smon_r2_reg_t SMON_CSR_SMON_R2; /*< Address offset = 0x108 */
    av2d_csr_smon_csr_smon_r3_reg_t SMON_CSR_SMON_R3; /*< Address offset = 0x10c */
    av2d_csr_smon_csr_smon_r4_reg_t SMON_CSR_SMON_R4; /*< Address offset = 0x110 */
    av2d_csr_smon_csr_smon_r5_reg_t SMON_CSR_SMON_R5; /*< Address offset = 0x114 */
    av2d_csr_smon_csr_smon_r6_reg_t SMON_CSR_SMON_R6; /*< Address offset = 0x118 */
    av2d_csr_smon_csr_smon_r7_reg_t SMON_CSR_SMON_R7; /*< Address offset = 0x11c */
    av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_INFO[8]; /*< Address offset = 0x120 */
    av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t TX_BUF_ECC_CSR0_TX_BUF_ECC_CTRL[8]; /*< Address offset = 0x140 */
    av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_stat_reg_t TX_BUF_ECC_CSR0_TX_BUF_ECC_ERR_STAT; /*< Address offset = 0x160 */
    const uint8_t        reservedArea4 [12];  /*< Address offset = 0x164 */
    av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_info_reg_t TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_INFO[8]; /*< Address offset = 0x170 */
    av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_ctrl_reg_t TX_BUF_ECC_CSR1_TX_BUF_ECC_CTRL[8]; /*< Address offset = 0x190 */
    av2d_csr_tx_buf_ecc_csr_tx_buf_ecc_err_stat_reg_t TX_BUF_ECC_CSR1_TX_BUF_ECC_ERR_STAT; /*< Address offset = 0x1b0 */
} av2d_csr_t;     // size: 0x0098

// AddressSpace struct pointer
//
#define V2D0_AV2D_APB_0_CSR  ((av2d_csr_t*) V2D0_AV2D_APB_0_CSR_BASE)
#define V2D0_AV2D_APB_1_CSR  ((av2d_csr_t*) V2D0_AV2D_APB_1_CSR_BASE)
#define V2D1_AV2D_APB_0_CSR  ((av2d_csr_t*) V2D1_AV2D_APB_0_CSR_BASE)
#define V2D1_AV2D_APB_1_CSR  ((av2d_csr_t*) V2D1_AV2D_APB_1_CSR_BASE)
#define V2D2_AV2D_APB_0_CSR  ((av2d_csr_t*) V2D2_AV2D_APB_0_CSR_BASE)
#define V2D2_AV2D_APB_1_CSR  ((av2d_csr_t*) V2D2_AV2D_APB_1_CSR_BASE)
#define V2D3_AV2D_APB_0_CSR  ((av2d_csr_t*) V2D3_AV2D_APB_0_CSR_BASE)
#define V2D3_AV2D_APB_1_CSR  ((av2d_csr_t*) V2D3_AV2D_APB_1_CSR_BASE)
#define V2D4_AV2D_APB_0_CSR  ((av2d_csr_t*) V2D4_AV2D_APB_0_CSR_BASE)
#define V2D4_AV2D_APB_1_CSR  ((av2d_csr_t*) V2D4_AV2D_APB_1_CSR_BASE)
#define V2D5_AV2D_APB_0_CSR  ((av2d_csr_t*) V2D5_AV2D_APB_0_CSR_BASE)
#define V2D5_AV2D_APB_1_CSR  ((av2d_csr_t*) V2D5_AV2D_APB_1_CSR_BASE)
#define V2D6_AV2D_APB_0_CSR  ((av2d_csr_t*) V2D6_AV2D_APB_0_CSR_BASE)
#define V2D6_AV2D_APB_1_CSR  ((av2d_csr_t*) V2D6_AV2D_APB_1_CSR_BASE)
#define V2D7_AV2D_APB_0_CSR  ((av2d_csr_t*) V2D7_AV2D_APB_0_CSR_BASE)
#define V2D7_AV2D_APB_1_CSR  ((av2d_csr_t*) V2D7_AV2D_APB_1_CSR_BASE)

// ******************************************* /Address Space

#endif      // _AV2D_CSR_H_

