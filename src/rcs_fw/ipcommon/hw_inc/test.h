#ifndef _TEST_H_
#define _TEST_H_

// ******************************************************************************
// ------------------------------------------------------------------------------
//                               INTEL CONFIDENTIAL
// ------------------------------------------------------------------------------
//    Copyright (c) 2018 - 2024 Intel Corporation
//
//    This software and the related documents are Intel copyrighted materials,
//    and your use of them is governed by the express license under which they
//    were provided to you ("License").
//    Unless the License provides otherwise, you may not use, modify, copy, publish,
//    distribute, disclose or transmit this software or the related documents
//    without Intel's prior written permission.
//
//    This software and the related documents are provided as is, with no express or
//    implied warranties, other than those that are expressly stated in the License.
// ------------------------------------------------------------------------------
//
//    DO NOT EDIT THIS FILE !!!
//
//    This file has been automatically generated by OneSource
//
// ******************************************************************************

#ifndef __KERNEL__
#include <stdint.h>
#endif // __KERNEL__
// ******************************************* Base address macros

#define MEM_CAP0_TEST_BASE    ( 0x041f0800 )
#define MEM_CAP1_TEST_BASE    ( 0x043f0800 )

// ******************************************* /Base address macros


// ******************************************* Register offset macros

#define TEST_MEM_SCRATCH_OFFSET ( 0x00000000U )
#define TEST_MEM_MSI_ACTIVE_OFFSET ( 0x00000004U )
#define TEST_MEM_RD_EN_OFFSET ( 0x00000008U )
#define TEST_MEM_WR_EN_OFFSET ( 0x0000000cU )
#define TEST_MEM_RXBAR_SEL0_OFFSET ( 0x00000020U )
#define TEST_MEM_RXBAR_SEL1_OFFSET ( 0x00000024U )
#define TEST_MEM_RXBAR_SEL2_OFFSET ( 0x00000028U )
#define TEST_MEM_RXBAR_SEL3_OFFSET ( 0x0000002cU )
#define TEST_MEM_RXBAR_SEL4_OFFSET ( 0x00000030U )
#define TEST_MEM_MSO_FIFO_WM0_OFFSET ( 0x00000060U )
#define TEST_MEM_MSO_FIFO_WM1_OFFSET ( 0x00000064U )
#define TEST_MEM_MSO_FIFO_WM2_OFFSET ( 0x00000068U )
#define TEST_MEM_BIST_ADC_MODE_OFFSET ( 0x00000070U )
#define TEST_MEM_BIST_ADC_CTRL_OFFSET ( 0x00000074U )
#define TEST_MEM_BIST_STAT_OFFSET ( 0x00000078U )
#define TEST_MEM_BIST_WAIT_TIME_OFFSET ( 0x0000007cU )
#define TEST_MEM_BIST_TEST_TIME_OFFSET ( 0x00000080U )
#define TEST_MEM_BIST_PLL_BYP_PHASE_OFFSET ( 0x00000084U )
#define TEST_MEM_BIST_PLL_BYP_MULT_OFFSET ( 0x00000088U )
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_OFFSET ( 0x0000008cU )
#define TEST_MEM_TPACK_FIFO_WM_OFFSET ( 0x000000e8U )
#define TEST_MEM_TDPACK_CFG_OFFSET ( 0x000000f0U )
#define TEST_MEM_MSO_FIFO_STAT0_OFFSET ( 0x00000100U )
#define TEST_MEM_MSO_FIFO_STAT1_OFFSET ( 0x00000104U )
#define TEST_MEM_MSO_FIFO_STAT2_OFFSET ( 0x00000108U )
#define TEST_MEM_PLL_DBGM_FIFO_STAT_OFFSET ( 0x00000110U )
#define TEST_MEM_TPACK_FIFO_STAT_OFFSET ( 0x00000124U )
#define TEST_MEM_FIFO_FLUSH_OFFSET ( 0x00000128U )
#define TEST_MEM_TEST_ERR_OFFSET ( 0x0000012cU )
#define TEST_MEM_PACKER_CFG_OFFSET ( 0x00000130U )
#define TEST_MEM_INT_STAT_OFFSET ( 0x00000180U )
#define TEST_MEM_INT_HIGH_EN_OFFSET ( 0x00000184U )
#define TEST_MEM_INT_LOW_EN_OFFSET ( 0x00000188U )
#define TEST_MEM_INT_CLR_OFFSET ( 0x0000018cU )
#define TEST_MEM_INT_FORCE_OFFSET ( 0x00000190U )
#define TEST_MEM_TTSG_EN0_OFFSET ( 0x000001f0U )
#define TEST_MEM_TTSG_EN1_OFFSET ( 0x000001f4U )
#define TEST_MEM_TTSG_MODE_OFFSET ( 0x000001f8U )
#define TEST_MEM_CDAC_CFG_OFFSET ( 0x000001fcU )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER0_OFFSET ( 0x00000200U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER1_OFFSET ( 0x00000204U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER2_OFFSET ( 0x00000208U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER3_OFFSET ( 0x0000020cU )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER4_OFFSET ( 0x00000210U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER5_OFFSET ( 0x00000214U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER6_OFFSET ( 0x00000218U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER7_OFFSET ( 0x0000021cU )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER8_OFFSET ( 0x00000220U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER9_OFFSET ( 0x00000224U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER10_OFFSET ( 0x00000228U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER11_OFFSET ( 0x0000022cU )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER12_OFFSET ( 0x00000230U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER13_OFFSET ( 0x00000234U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER14_OFFSET ( 0x00000238U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER15_OFFSET ( 0x0000023cU )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER16_OFFSET ( 0x00000240U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER17_OFFSET ( 0x00000244U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER18_OFFSET ( 0x00000248U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER19_OFFSET ( 0x0000024cU )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER20_OFFSET ( 0x00000250U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER21_OFFSET ( 0x00000254U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER22_OFFSET ( 0x00000258U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER23_OFFSET ( 0x0000025cU )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER24_OFFSET ( 0x00000260U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER25_OFFSET ( 0x00000264U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER26_OFFSET ( 0x00000268U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER27_OFFSET ( 0x0000026cU )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER28_OFFSET ( 0x00000270U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER29_OFFSET ( 0x00000274U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER30_OFFSET ( 0x00000278U )
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER31_OFFSET ( 0x0000027cU )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER0_OFFSET ( 0x00000280U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER1_OFFSET ( 0x00000284U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER2_OFFSET ( 0x00000288U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER3_OFFSET ( 0x0000028cU )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER4_OFFSET ( 0x00000290U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER5_OFFSET ( 0x00000294U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER6_OFFSET ( 0x00000298U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER7_OFFSET ( 0x0000029cU )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER8_OFFSET ( 0x000002a0U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER9_OFFSET ( 0x000002a4U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER10_OFFSET ( 0x000002a8U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER11_OFFSET ( 0x000002acU )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER12_OFFSET ( 0x000002b0U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER13_OFFSET ( 0x000002b4U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER14_OFFSET ( 0x000002b8U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER15_OFFSET ( 0x000002bcU )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER16_OFFSET ( 0x000002c0U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER17_OFFSET ( 0x000002c4U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER18_OFFSET ( 0x000002c8U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER19_OFFSET ( 0x000002ccU )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER20_OFFSET ( 0x000002d0U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER21_OFFSET ( 0x000002d4U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER22_OFFSET ( 0x000002d8U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER23_OFFSET ( 0x000002dcU )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER24_OFFSET ( 0x000002e0U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER25_OFFSET ( 0x000002e4U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER26_OFFSET ( 0x000002e8U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER27_OFFSET ( 0x000002ecU )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER28_OFFSET ( 0x000002f0U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER29_OFFSET ( 0x000002f4U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER30_OFFSET ( 0x000002f8U )
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER31_OFFSET ( 0x000002fcU )
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER0_OFFSET ( 0x00000300U )
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER1_OFFSET ( 0x00000304U )
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER0_OFFSET ( 0x00000308U )
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER1_OFFSET ( 0x0000030cU )
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER0_OFFSET ( 0x00000310U )
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER1_OFFSET ( 0x00000314U )
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER0_OFFSET ( 0x00000318U )
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER1_OFFSET ( 0x0000031cU )
#define TEST_MEM_MSI_FIFO_WM0_OFFSET ( 0x00000320U )
#define TEST_MEM_MSI_FIFO_WM1_OFFSET ( 0x00000324U )
#define TEST_MEM_MSI_FIFO_WM2_OFFSET ( 0x00000328U )
#define TEST_MEM_MSI_FIFO_WM3_OFFSET ( 0x0000032cU )
#define TEST_MEM_MSI_FIFO_WM4_OFFSET ( 0x00000330U )
#define TEST_MEM_MSI_FIFO_STAT0_OFFSET ( 0x00000340U )
#define TEST_MEM_MSI_FIFO_STAT1_OFFSET ( 0x00000344U )
#define TEST_MEM_MSI_FIFO_STAT2_OFFSET ( 0x00000348U )
#define TEST_MEM_MSI_FIFO_STAT3_OFFSET ( 0x0000034cU )
#define TEST_MEM_MSI_FIFO_STAT4_OFFSET ( 0x00000350U )
#define TEST_MEM_ERR_PHASE_OFFSET ( 0x00000360U )
#define TEST_MEM_ERR_AMPL_OFFSET ( 0x00000364U )
#define TEST_MEM_TEST_TX_CFG_OFFSET ( 0x00000368U )
#define TEST_MEM_DUAL_FCW_CFG0_OFFSET ( 0x00000380U )
#define TEST_MEM_DUAL_FCW_CFG1_OFFSET ( 0x00000384U )
#define TEST_MEM_APB_BRDG_STAT_OFFSET ( 0x000003fcU )
#define TEST_MEM_PLL_FUNCTION_OFFSET ( 0x00000460U )
#define TEST_MEM_PLL_STAT_OFFSET ( 0x00000464U )
#define TEST_MEM_PLL_CNTER_OFFSET ( 0x00000468U )
#define TEST_MEM_PLL_WAIT_CNT_OFFSET ( 0x0000046cU )
#define TEST_MEM_PLL_CNT_HIGH_OFFSET ( 0x00000470U )
#define TEST_MEM_PLL_CNT_LOW_OFFSET ( 0x00000474U )
#define TEST_MEM_APB_BRDG_STAT_PLL_OFFSET ( 0x000007fcU )

// ******************************************* /Register offset macros


// ******************************************* AddressSpace macros
#define TEST_MEM_SCRATCH_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_SCRATCH_OFFSET ) ))
#define TEST_MEM_MSI_ACTIVE_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_ACTIVE_OFFSET ) ))
#define TEST_MEM_RD_EN_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_RD_EN_OFFSET ) ))
#define TEST_MEM_WR_EN_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_WR_EN_OFFSET ) ))
#define TEST_MEM_RXBAR_SEL0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_RXBAR_SEL0_OFFSET ) ))
#define TEST_MEM_RXBAR_SEL1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_RXBAR_SEL1_OFFSET ) ))
#define TEST_MEM_RXBAR_SEL2_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_RXBAR_SEL2_OFFSET ) ))
#define TEST_MEM_RXBAR_SEL3_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_RXBAR_SEL3_OFFSET ) ))
#define TEST_MEM_RXBAR_SEL4_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_RXBAR_SEL4_OFFSET ) ))
#define TEST_MEM_MSO_FIFO_WM0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSO_FIFO_WM0_OFFSET ) ))
#define TEST_MEM_MSO_FIFO_WM1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSO_FIFO_WM1_OFFSET ) ))
#define TEST_MEM_MSO_FIFO_WM2_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSO_FIFO_WM2_OFFSET ) ))
#define TEST_MEM_BIST_ADC_MODE_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_BIST_ADC_MODE_OFFSET ) ))
#define TEST_MEM_BIST_ADC_CTRL_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_BIST_ADC_CTRL_OFFSET ) ))
#define TEST_MEM_BIST_STAT_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_BIST_STAT_OFFSET ) ))
#define TEST_MEM_BIST_WAIT_TIME_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_BIST_WAIT_TIME_OFFSET ) ))
#define TEST_MEM_BIST_TEST_TIME_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_BIST_TEST_TIME_OFFSET ) ))
#define TEST_MEM_BIST_PLL_BYP_PHASE_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_BIST_PLL_BYP_PHASE_OFFSET ) ))
#define TEST_MEM_BIST_PLL_BYP_MULT_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_BIST_PLL_BYP_MULT_OFFSET ) ))
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_OFFSET ) ))
#define TEST_MEM_TPACK_FIFO_WM_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TPACK_FIFO_WM_OFFSET ) ))
#define TEST_MEM_TDPACK_CFG_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TDPACK_CFG_OFFSET ) ))
#define TEST_MEM_MSO_FIFO_STAT0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSO_FIFO_STAT0_OFFSET ) ))
#define TEST_MEM_MSO_FIFO_STAT1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSO_FIFO_STAT1_OFFSET ) ))
#define TEST_MEM_MSO_FIFO_STAT2_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSO_FIFO_STAT2_OFFSET ) ))
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_PLL_DBGM_FIFO_STAT_OFFSET ) ))
#define TEST_MEM_TPACK_FIFO_STAT_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TPACK_FIFO_STAT_OFFSET ) ))
#define TEST_MEM_FIFO_FLUSH_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_FIFO_FLUSH_OFFSET ) ))
#define TEST_MEM_TEST_ERR_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TEST_ERR_OFFSET ) ))
#define TEST_MEM_PACKER_CFG_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_PACKER_CFG_OFFSET ) ))
#define TEST_MEM_INT_STAT_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_INT_STAT_OFFSET ) ))
#define TEST_MEM_INT_HIGH_EN_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_INT_HIGH_EN_OFFSET ) ))
#define TEST_MEM_INT_LOW_EN_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_INT_LOW_EN_OFFSET ) ))
#define TEST_MEM_INT_CLR_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_INT_CLR_OFFSET ) ))
#define TEST_MEM_INT_FORCE_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_INT_FORCE_OFFSET ) ))
#define TEST_MEM_TTSG_EN0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_EN0_OFFSET ) ))
#define TEST_MEM_TTSG_EN1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_EN1_OFFSET ) ))
#define TEST_MEM_TTSG_MODE_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_MODE_OFFSET ) ))
#define TEST_MEM_CDAC_CFG_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_CDAC_CFG_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER0_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER1_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER2_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER2_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER3_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER3_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER4_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER4_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER5_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER5_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER6_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER6_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER7_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER7_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER8_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER8_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER9_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER9_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER10_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER10_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER11_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER11_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER12_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER12_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER13_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER13_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER14_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER14_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER15_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER15_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER16_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER16_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER17_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER17_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER18_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER18_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER19_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER19_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER20_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER20_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER21_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER21_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER22_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER22_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER23_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER23_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER24_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER24_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER25_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER25_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER26_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER26_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER27_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER27_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER28_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER28_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER29_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER29_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER30_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER30_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER31_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_UPPER31_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER0_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER1_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER2_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER2_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER3_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER3_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER4_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER4_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER5_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER5_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER6_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER6_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER7_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER7_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER8_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER8_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER9_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER9_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER10_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER10_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER11_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER11_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER12_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER12_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER13_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER13_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER14_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER14_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER15_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER15_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER16_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER16_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER17_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER17_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER18_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER18_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER19_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER19_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER20_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER20_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER21_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER21_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER22_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER22_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER23_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER23_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER24_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER24_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER25_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER25_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER26_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER26_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER27_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER27_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER28_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER28_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER29_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER29_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER30_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER30_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER31_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INIT_LOWER31_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INCR_UPPER0_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INCR_UPPER1_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INCR_LOWER0_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INCR_LOWER1_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INCR1_UPPER0_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INCR1_UPPER1_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INCR1_LOWER0_OFFSET ) ))
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TTSG_CORDIC_INCR1_LOWER1_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_WM0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_WM0_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_WM1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_WM1_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_WM2_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_WM2_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_WM3_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_WM3_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_WM4_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_WM4_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_STAT0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_STAT0_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_STAT1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_STAT1_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_STAT2_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_STAT2_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_STAT3_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_STAT3_OFFSET ) ))
#define TEST_MEM_MSI_FIFO_STAT4_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_MSI_FIFO_STAT4_OFFSET ) ))
#define TEST_MEM_ERR_PHASE_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_ERR_PHASE_OFFSET ) ))
#define TEST_MEM_ERR_AMPL_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_ERR_AMPL_OFFSET ) ))
#define TEST_MEM_TEST_TX_CFG_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_TEST_TX_CFG_OFFSET ) ))
#define TEST_MEM_DUAL_FCW_CFG0_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_DUAL_FCW_CFG0_OFFSET ) ))
#define TEST_MEM_DUAL_FCW_CFG1_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_DUAL_FCW_CFG1_OFFSET ) ))
#define TEST_MEM_APB_BRDG_STAT_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_APB_BRDG_STAT_OFFSET ) ))
#define TEST_MEM_PLL_FUNCTION_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_PLL_FUNCTION_OFFSET ) ))
#define TEST_MEM_PLL_STAT_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_PLL_STAT_OFFSET ) ))
#define TEST_MEM_PLL_CNTER_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_PLL_CNTER_OFFSET ) ))
#define TEST_MEM_PLL_WAIT_CNT_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_PLL_WAIT_CNT_OFFSET ) ))
#define TEST_MEM_PLL_CNT_HIGH_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_PLL_CNT_HIGH_OFFSET ) ))
#define TEST_MEM_PLL_CNT_LOW_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_PLL_CNT_LOW_OFFSET ) ))
#define TEST_MEM_APB_BRDG_STAT_PLL_ADR(_BASE) (( ( _BASE ) + ( TEST_MEM_APB_BRDG_STAT_PLL_OFFSET ) ))

// ******************************************* /Address Space

//************************************************ RegisterStructs


/** @brief TEST_MAP_MEM_TEST_MAP_SCRATCH register description at address offset 0x0
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/SCRATCH
  * Scratch Register
  */

typedef union {
  struct {
    uint32_t SCRATCHPAD : 32;
    ///< Scratch pad
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_scratch_reg_t;

#define TEST_MEM_SCRATCH_DEFAULT (0x00000000U)
#define TEST_MEM_SCRATCH_RD_MASK (0xffffffffU)
#define TEST_MEM_SCRATCH_WR_MASK (0xffffffffU)


///< Scratch pad
#define TEST_MEM_SCRATCH_SCRATCHPAD_BF_OFF ( 0)
#define TEST_MEM_SCRATCH_SCRATCHPAD_BF_WID (32)
#define TEST_MEM_SCRATCH_SCRATCHPAD_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_SCRATCH_SCRATCHPAD_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_MSI_ACTIVE register description at address offset 0x4
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/MSI_ACTIVE
  * MSI Enable Register
  */

typedef union {
  struct {
    uint32_t ENABLE : 5;
    ///< MSI Enable
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t BYP_BFN : 5;
    ///< Bypass BFN. When bit is set, the BFN triggered enable for MSI is bypassed
    ///< and the logic uses the corresponding value in the ENABLE field to
    ///< drive the MSI's enable bit.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t GROUP_MSI_SYNC : 5;
    ///< Group MSI sync. Allows the user to synchronize the enabling of multiple
    ///< MSIs to ensure that select MSIs are all enabled at the same exact
    ///< clock cycle.  The 5 MSI enables are generated in the 1/1.5 GHz clock
    ///< domain and then are each individually synchronized into MEM_CAP's
    ///< clk_div_2 domain.  As such, even if multipl enables are triggered
    ///< in same clk_core (1/1.5 GHz) domain clock cycle, the synchronized
    ///< enables in the clk_div_2 domain can be asserted at different times
    ///< depending on the exact transfer behavior in each individual synchronizer.
    ///< This feature allows all the selected MSIs to be enabled at the same
    ///< time. The MSIs chosen by the asserted bit in the GROUP_MSI_SYNC field
    ///< will be OR-ed together. As such, all the selected MSIs will be enabled
    ///< when the earliest synchronized output is asserted. This feature is
    ///< normally enabled when capture 16 samples of 27-bit data at the pre-ASC
    ///< capture point. This feature ensures that the 16 27-bit samples split
    ///< across 2 memory sectors are properly aligned.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t  : 17;
    ///< Reserved
    ///< AccessType="RO" BitOffset="15" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_msi_active_reg_t;

#define TEST_MEM_MSI_ACTIVE_DEFAULT (0x00000000U)
#define TEST_MEM_MSI_ACTIVE_RD_MASK (0x00007fffU)
#define TEST_MEM_MSI_ACTIVE_WR_MASK (0x00007fffU)


///< MSI Enable
#define TEST_MEM_MSI_ACTIVE_EN_BF_OFF ( 0)
#define TEST_MEM_MSI_ACTIVE_EN_BF_WID ( 5)
#define TEST_MEM_MSI_ACTIVE_EN_BF_MSK (0x0000001F)
#define TEST_MEM_MSI_ACTIVE_EN_BF_DEF (0x00000000)

///< Bypass BFN. When bit is set, the BFN triggered enable for MSI is bypassed
///< and the logic uses the corresponding value in the ENABLE field to
///< drive the MSI's enable bit.
#define TEST_MEM_MSI_ACTIVE_BYP_BFN_BF_OFF ( 5)
#define TEST_MEM_MSI_ACTIVE_BYP_BFN_BF_WID ( 5)
#define TEST_MEM_MSI_ACTIVE_BYP_BFN_BF_MSK (0x000003E0)
#define TEST_MEM_MSI_ACTIVE_BYP_BFN_BF_DEF (0x00000000)

///< Group MSI sync. Allows the user to synchronize the enabling of multiple
///< MSIs to ensure that select MSIs are all enabled at the same exact
///< clock cycle.  The 5 MSI enables are generated in the 1/1.5 GHz clock
///< domain and then are each individually synchronized into MEM_CAP's
///< clk_div_2 domain.  As such, even if multipl enables are triggered
///< in same clk_core (1/1.5 GHz) domain clock cycle, the synchronized
///< enables in the clk_div_2 domain can be asserted at different times
///< depending on the exact transfer behavior in each individual synchronizer.
///< This feature allows all the selected MSIs to be enabled at the same
///< time. The MSIs chosen by the asserted bit in the GROUP_MSI_SYNC field
///< will be OR-ed together. As such, all the selected MSIs will be enabled
///< when the earliest synchronized output is asserted. This feature is
///< normally enabled when capture 16 samples of 27-bit data at the pre-ASC
///< capture point. This feature ensures that the 16 27-bit samples split
///< across 2 memory sectors are properly aligned.
#define TEST_MEM_MSI_ACTIVE_GRP_MSI_SYNC_BF_OFF (10)
#define TEST_MEM_MSI_ACTIVE_GRP_MSI_SYNC_BF_WID ( 5)
#define TEST_MEM_MSI_ACTIVE_GRP_MSI_SYNC_BF_MSK (0x00007C00)
#define TEST_MEM_MSI_ACTIVE_GRP_MSI_SYNC_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_MEM_RD_EN register description at address offset 0x8
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/MEM_RD_EN
  * Memory Read Function Enable SRegister
  */

typedef union {
  struct {
    uint32_t ENABLE : 4;
    ///< Read Function Enable
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t BYP_BFN : 4;
    ///< Bypass BFN
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_rd_en_reg_t;

#define TEST_MEM_RD_EN_DEFAULT (0x00000000U)
#define TEST_MEM_RD_EN_RD_MASK (0x000000ffU)
#define TEST_MEM_RD_EN_WR_MASK (0x000000ffU)


///< Read Function Enable
#define TEST_MEM_RD_EN_BF_OFF ( 0)
#define TEST_MEM_RD_EN_BF_WID ( 4)
#define TEST_MEM_RD_EN_BF_MSK (0x0000000F)
#define TEST_MEM_RD_EN_BF_DEF (0x00000000)

///< Bypass BFN
#define TEST_MEM_RD_EN_BYP_BFN_BF_OFF ( 4)
#define TEST_MEM_RD_EN_BYP_BFN_BF_WID ( 4)
#define TEST_MEM_RD_EN_BYP_BFN_BF_MSK (0x000000F0)
#define TEST_MEM_RD_EN_BYP_BFN_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_MEM_WR_EN register description at address offset 0xc
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/MEM_WR_EN
  * Memory Write Function Enable SRegister
  */

typedef union {
  struct {
    uint32_t ENABLE : 5;
    ///< Write Function Enable
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 27;
    ///< Reserved
    ///< AccessType="RO" BitOffset="5" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_wr_en_reg_t;

#define TEST_MEM_WR_EN_DEFAULT (0x00000000U)
#define TEST_MEM_WR_EN_RD_MASK (0x0000001fU)
#define TEST_MEM_WR_EN_WR_MASK (0x0000001fU)


///< Write Function Enable
#define TEST_MEM_WR_EN_BF_OFF ( 0)
#define TEST_MEM_WR_EN_BF_WID ( 5)
#define TEST_MEM_WR_EN_BF_MSK (0x0000001F)
#define TEST_MEM_WR_EN_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_RXBAR_SEL[5] register description at address offset 0x20
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/RXBAR_SEL
  * Capture Memory Input RX Crossbar Mux Select
  */

typedef union {
  struct {
    uint32_t SEL : 4;
    ///< Input Select
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_rxbar_sel_reg_t;

#define TEST_MEM_RXBAR_SEL_DEFAULT (0x00000000U)
#define TEST_MEM_RXBAR_SEL_RD_MASK (0x0000000fU)
#define TEST_MEM_RXBAR_SEL_WR_MASK (0x0000000fU)


///< Input Select
#define TEST_MEM_RXBAR_SEL_BF_OFF ( 0)
#define TEST_MEM_RXBAR_SEL_BF_WID ( 4)
#define TEST_MEM_RXBAR_SEL_BF_MSK (0x0000000F)
#define TEST_MEM_RXBAR_SEL_BF_DEF (0x00000000)
#define TEST_MEM_RXBAR_SEL_ARR_SZ0 (5)
#define TEST_MEM_RXBAR_SEL_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_MSO_FIFO_WM[3] register description at address offset 0x60
  *
  * Register default value:        0x00000144
  * Register full path in IP: test_map_MEM/test_map/MSO_FIFO_WM
  * 16-Entry Clock Crossing FIFO Watermarks Register for MSO FIFOs
  */

typedef union {
  struct {
    uint32_t LOW_WM : 5;
    ///< FIFO Low Watermark
    ///< AccessType="RW" BitOffset="0" ResetValue="0x4"
    uint32_t HIGH_WM : 5;
    ///< FIFO High Watermark
    ///< AccessType="RW" BitOffset="5" ResetValue="0xA"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_mso_fifo_wm_reg_t;

#define TEST_MEM_MSO_FIFO_WM_DEFAULT (0x00000144U)
#define TEST_MEM_MSO_FIFO_WM_RD_MASK (0x000003ffU)
#define TEST_MEM_MSO_FIFO_WM_WR_MASK (0x000003ffU)


///< FIFO Low Watermark
#define TEST_MEM_MSO_FIFO_WM_LOW_WM_BF_OFF ( 0)
#define TEST_MEM_MSO_FIFO_WM_LOW_WM_BF_WID ( 5)
#define TEST_MEM_MSO_FIFO_WM_LOW_WM_BF_MSK (0x0000001F)
#define TEST_MEM_MSO_FIFO_WM_LOW_WM_BF_DEF (0x00000004)

///< FIFO High Watermark
#define TEST_MEM_MSO_FIFO_WM_HIGH_WM_BF_OFF ( 5)
#define TEST_MEM_MSO_FIFO_WM_HIGH_WM_BF_WID ( 5)
#define TEST_MEM_MSO_FIFO_WM_HIGH_WM_BF_MSK (0x000003E0)
#define TEST_MEM_MSO_FIFO_WM_HIGH_WM_BF_DEF (0x00000140)
#define TEST_MEM_MSO_FIFO_WM_ARR_SZ0 (3)
#define TEST_MEM_MSO_FIFO_WM_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_BIST_ADC_MODE register description at address offset 0x70
  *
  * Register default value:        0x00000190
  * Register full path in IP: test_map_MEM/test_map/BIST_ADC_MODE
  * BIST ADC Mode Register
  */

typedef union {
  struct {
    uint32_t MODE : 2;
    ///< BIST Mode.  When set to 0 - use all 16 samples for error comparison.
    ///< The 16 sample source will be a) i_test_bist_in (a source external
    ///< to the TEST module originating at the output of the ASC submodule)
    ///< if BIST_LOOPBACK = 0, or b) TTSG sig_out[1] if BIST_LOOPBACK = 1;
    ///< When set to  1, uses the same set of samples as when set to 1 (i.e.
    ///< i_test_bist_in or i_test_loopback_in), but the 16 valid samples are
    ///< processed such that  only 1 of 16 samples are valid. The position
    ///< of the one hot bit is determined used a random number generator. When
    ///< set to 2, i_test_obs (the SSAR output of the analogi logic) is the
    ///< test source for the BIST logic.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t BIST_MAX_ALLOW_ERROR : 16;
    ///< BIST maximum allowable error
    ///< AccessType="RW" BitOffset="2" ResetValue="0x64"
    uint32_t BIST_PLL_FEEDBACK : 3;
    ///< BIST feedback constant for PLL. 0 = 2^10, 1 = 2^8, 2 = 2^6, 3 = 2^4,
    ///< 4 = 2^3, 5,6,7 = 2^2
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t BIST_AMP_FEEDBACK : 3;
    ///< BIST initial value for Amplitude lock/adjust multiplier. 0 = 2^10,
    ///< 1 = 2^8, 2 = 2^6, 3 = 2^4, 4 = 2^3, 5,6,7 = 2^2
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t BIST_LOOPBACK : 1;
    ///< When set to 1 and bist_adc_mode.mode = 0 or 1, the BIST logic will
    ///< choose the internally generated TTSG sig_out[1] signal as its test
    ///< signal. This allows the user to test the BIST logic completely within
    ///< the TEST module without the need to use any of the analog components
    ///< (DAC, ADC, power amplifiiers) or any external loopbacks outside of
    ///< the TEST module. When set to 0, the loopback feature is disable, and
    ///< the BIST logic will use the TEST module's i_test_bist_in or i_test_obs
    ///< inputs as the test source for the BIST logic.
    ///< AccessType="RW" BitOffset="24" ResetValue="0x0"
    uint32_t BIST_CAPTURE_EN : 1;
    ///< When set to 0, capturing of BIST debug signals into the MEM_CAP capture
    ///< memory is disabled. When set to 1, capturing of the BIST debug signals
    ///< into the MEM_CAP capture memory is enabled. Any other capture programming
    ///< is overridden by the bist_capture enable signal.
    ///< AccessType="RW" BitOffset="25" ResetValue="0x0"
    uint32_t BIST_PLL_BYPASS : 1;
    ///< When set to 1, the phase lock portion of the BIST feedback control
    ///< logic is disable and the internal phase offset is set to a value programmed
    ///< in by the user. When set to 0, the BIST feedback control logic is
    ///< enabled and the BIST algorithm operates in normal fashion.
    ///< AccessType="RW" BitOffset="26" ResetValue="0x0"
    uint32_t BIST_AMP_BYPASS : 1;
    ///< When set to 1, the amplitude lock loop portion of the BIST feedback
    ///< control logic is disable and the internal amplitude multiplier is
    ///< set to a value programmed in by the user. When set to 0, the BIST
    ///< amplitude control logic is enabled and the BIST algorithm operates
    ///< in normal fashion.
    ///< AccessType="RW" BitOffset="27" ResetValue="0x0"
    uint32_t BIST_NLEQ : 1;
    ///< When set to 1 and bist_adc_mode.mode = 0 or 1 (i.e. the BIST logic
    ///< is configure to operate in 16 sample mode), the BIST logic will use
    ///< the output of the NLEQ module as the test signal.
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t BIST_NLEQ_ODD : 1;
    ///< When set to 1 and BIST_NLEQ = 1 and bist_adc_mode.mode = 0 or 1, then
    ///< NLEQ data from even odd numbered NLEQs is routed to the BIST logic.
    ///< Otherwise, NLEQ data from even numbered NLEQs are routed. In addition
    ///< to properly configuring the BIST_NLEQ and BIST_NDLEQ_ODD configuration
    ///< bits, the user must still properly configure the TEST MUX configuration
    ///< in all the TRX_SYSs and FB_SYS to ensure that the desired NLEQ is
    ///< routed to MEM_CAP via the 2 capture pipelines.
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t  : 2;
    ///< Reserved
    ///< AccessType="RO" BitOffset="30" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_bist_adc_mode_reg_t;

#define TEST_MEM_BIST_ADC_MODE_DEFAULT (0x00000190U)
#define TEST_MEM_BIST_ADC_MODE_RD_MASK (0x3fffffffU)
#define TEST_MEM_BIST_ADC_MODE_WR_MASK (0x3fffffffU)


///< BIST Mode.  When set to 0 - use all 16 samples for error comparison.
///< The 16 sample source will be a) i_test_bist_in (a source external
///< to the TEST module originating at the output of the ASC submodule)
///< if BIST_LOOPBACK = 0, or b) TTSG sig_out[1] if BIST_LOOPBACK = 1;
///< When set to  1, uses the same set of samples as when set to 1 (i.e.
///< i_test_bist_in or i_test_loopback_in), but the 16 valid samples are
///< processed such that  only 1 of 16 samples are valid. The position
///< of the one hot bit is determined used a random number generator. When
///< set to 2, i_test_obs (the SSAR output of the analogi logic) is the
///< test source for the BIST logic.
#define TEST_MEM_BIST_ADC_MODE_BF_OFF ( 0)
#define TEST_MEM_BIST_ADC_MODE_BF_WID ( 2)
#define TEST_MEM_BIST_ADC_MODE_BF_MSK (0x00000003)
#define TEST_MEM_BIST_ADC_MODE_BF_DEF (0x00000000)

///< BIST maximum allowable error
#define TEST_MEM_BIST_ADC_MODE_BIST_MAX_ALLOW_ERR_BF_OFF ( 2)
#define TEST_MEM_BIST_ADC_MODE_BIST_MAX_ALLOW_ERR_BF_WID (16)
#define TEST_MEM_BIST_ADC_MODE_BIST_MAX_ALLOW_ERR_BF_MSK (0x0003FFFC)
#define TEST_MEM_BIST_ADC_MODE_BIST_MAX_ALLOW_ERR_BF_DEF (0x00000190)

///< BIST feedback constant for PLL. 0 = 2^10, 1 = 2^8, 2 = 2^6, 3 = 2^4,
///< 4 = 2^3, 5,6,7 = 2^2
#define TEST_MEM_BIST_ADC_MODE_BIST_PLL_FEEDBACK_BF_OFF (18)
#define TEST_MEM_BIST_ADC_MODE_BIST_PLL_FEEDBACK_BF_WID ( 3)
#define TEST_MEM_BIST_ADC_MODE_BIST_PLL_FEEDBACK_BF_MSK (0x001C0000)
#define TEST_MEM_BIST_ADC_MODE_BIST_PLL_FEEDBACK_BF_DEF (0x00000000)

///< BIST initial value for Amplitude lock/adjust multiplier. 0 = 2^10,
///< 1 = 2^8, 2 = 2^6, 3 = 2^4, 4 = 2^3, 5,6,7 = 2^2
#define TEST_MEM_BIST_ADC_MODE_BIST_AMP_FEEDBACK_BF_OFF (21)
#define TEST_MEM_BIST_ADC_MODE_BIST_AMP_FEEDBACK_BF_WID ( 3)
#define TEST_MEM_BIST_ADC_MODE_BIST_AMP_FEEDBACK_BF_MSK (0x00E00000)
#define TEST_MEM_BIST_ADC_MODE_BIST_AMP_FEEDBACK_BF_DEF (0x00000000)

///< When set to 1 and bist_adc_mode.mode = 0 or 1, the BIST logic will
///< choose the internally generated TTSG sig_out[1] signal as its test
///< signal. This allows the user to test the BIST logic completely within
///< the TEST module without the need to use any of the analog components
///< (DAC, ADC, power amplifiiers) or any external loopbacks outside of
///< the TEST module. When set to 0, the loopback feature is disable, and
///< the BIST logic will use the TEST module's i_test_bist_in or i_test_obs
///< inputs as the test source for the BIST logic.
#define TEST_MEM_BIST_ADC_MODE_BIST_LOOPBACK_BF_OFF (24)
#define TEST_MEM_BIST_ADC_MODE_BIST_LOOPBACK_BF_WID ( 1)
#define TEST_MEM_BIST_ADC_MODE_BIST_LOOPBACK_BF_MSK (0x01000000)
#define TEST_MEM_BIST_ADC_MODE_BIST_LOOPBACK_BF_DEF (0x00000000)

///< When set to 0, capturing of BIST debug signals into the MEM_CAP capture
///< memory is disabled. When set to 1, capturing of the BIST debug signals
///< into the MEM_CAP capture memory is enabled. Any other capture programming
///< is overridden by the bist_capture enable signal.
#define TEST_MEM_BIST_ADC_MODE_BIST_CAP_EN_BF_OFF (25)
#define TEST_MEM_BIST_ADC_MODE_BIST_CAP_EN_BF_WID ( 1)
#define TEST_MEM_BIST_ADC_MODE_BIST_CAP_EN_BF_MSK (0x02000000)
#define TEST_MEM_BIST_ADC_MODE_BIST_CAP_EN_BF_DEF (0x00000000)

///< When set to 1, the phase lock portion of the BIST feedback control
///< logic is disable and the internal phase offset is set to a value programmed
///< in by the user. When set to 0, the BIST feedback control logic is
///< enabled and the BIST algorithm operates in normal fashion.
#define TEST_MEM_BIST_ADC_MODE_BIST_PLL_BYP_BF_OFF (26)
#define TEST_MEM_BIST_ADC_MODE_BIST_PLL_BYP_BF_WID ( 1)
#define TEST_MEM_BIST_ADC_MODE_BIST_PLL_BYP_BF_MSK (0x04000000)
#define TEST_MEM_BIST_ADC_MODE_BIST_PLL_BYP_BF_DEF (0x00000000)

///< When set to 1, the amplitude lock loop portion of the BIST feedback
///< control logic is disable and the internal amplitude multiplier is
///< set to a value programmed in by the user. When set to 0, the BIST
///< amplitude control logic is enabled and the BIST algorithm operates
///< in normal fashion.
#define TEST_MEM_BIST_ADC_MODE_BIST_AMP_BYP_BF_OFF (27)
#define TEST_MEM_BIST_ADC_MODE_BIST_AMP_BYP_BF_WID ( 1)
#define TEST_MEM_BIST_ADC_MODE_BIST_AMP_BYP_BF_MSK (0x08000000)
#define TEST_MEM_BIST_ADC_MODE_BIST_AMP_BYP_BF_DEF (0x00000000)

///< When set to 1 and bist_adc_mode.mode = 0 or 1 (i.e. the BIST logic
///< is configure to operate in 16 sample mode), the BIST logic will use
///< the output of the NLEQ module as the test signal.
#define TEST_MEM_BIST_ADC_MODE_BIST_NLEQ_BF_OFF (28)
#define TEST_MEM_BIST_ADC_MODE_BIST_NLEQ_BF_WID ( 1)
#define TEST_MEM_BIST_ADC_MODE_BIST_NLEQ_BF_MSK (0x10000000)
#define TEST_MEM_BIST_ADC_MODE_BIST_NLEQ_BF_DEF (0x00000000)

///< When set to 1 and BIST_NLEQ = 1 and bist_adc_mode.mode = 0 or 1, then
///< NLEQ data from even odd numbered NLEQs is routed to the BIST logic.
///< Otherwise, NLEQ data from even numbered NLEQs are routed. In addition
///< to properly configuring the BIST_NLEQ and BIST_NDLEQ_ODD configuration
///< bits, the user must still properly configure the TEST MUX configuration
///< in all the TRX_SYSs and FB_SYS to ensure that the desired NLEQ is
///< routed to MEM_CAP via the 2 capture pipelines.
#define TEST_MEM_BIST_ADC_MODE_BIST_NLEQ_ODD_BF_OFF (29)
#define TEST_MEM_BIST_ADC_MODE_BIST_NLEQ_ODD_BF_WID ( 1)
#define TEST_MEM_BIST_ADC_MODE_BIST_NLEQ_ODD_BF_MSK (0x20000000)
#define TEST_MEM_BIST_ADC_MODE_BIST_NLEQ_ODD_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_BIST_ADC_CTRL register description at address offset 0x74
  *
  * Register default value:        0x00000014
  * Register full path in IP: test_map_MEM/test_map/BIST_ADC_CTRL
  * BIST ADC Control SRegister
  */

typedef union {
  struct {
    uint32_t START : 1;
    ///< BIST ADC start bit.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RESET : 1;
    ///< BIST ADC reset
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t ANT : 4;
    ///< BIST ADC ANT. 0-7 = normal traffic channel. 8-9 = feedback channel.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x5"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_bist_adc_ctrl_reg_t;

#define TEST_MEM_BIST_ADC_CTRL_DEFAULT (0x00000014U)
#define TEST_MEM_BIST_ADC_CTRL_RD_MASK (0x0000003fU)
#define TEST_MEM_BIST_ADC_CTRL_WR_MASK (0x0000003fU)


///< BIST ADC start bit.
#define TEST_MEM_BIST_ADC_CTRL_START_BF_OFF ( 0)
#define TEST_MEM_BIST_ADC_CTRL_START_BF_WID ( 1)
#define TEST_MEM_BIST_ADC_CTRL_START_BF_MSK (0x00000001)
#define TEST_MEM_BIST_ADC_CTRL_START_BF_DEF (0x00000000)

///< BIST ADC reset
#define TEST_MEM_BIST_ADC_CTRL_RST_BF_OFF ( 1)
#define TEST_MEM_BIST_ADC_CTRL_RST_BF_WID ( 1)
#define TEST_MEM_BIST_ADC_CTRL_RST_BF_MSK (0x00000002)
#define TEST_MEM_BIST_ADC_CTRL_RST_BF_DEF (0x00000000)

///< BIST ADC ANT. 0-7 = normal traffic channel. 8-9 = feedback channel.
#define TEST_MEM_BIST_ADC_CTRL_ANT_BF_OFF ( 2)
#define TEST_MEM_BIST_ADC_CTRL_ANT_BF_WID ( 4)
#define TEST_MEM_BIST_ADC_CTRL_ANT_BF_MSK (0x0000003C)
#define TEST_MEM_BIST_ADC_CTRL_ANT_BF_DEF (0x00000014)


/** @brief TEST_MAP_MEM_TEST_MAP_BIST_STAT register description at address offset 0x78
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/BIST_STAT
  * BIST Status Register
  */

typedef union {
  struct {
    uint32_t DONE : 1;
    ///< BIST test complete indicator
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t PASS : 10;
    ///< BIST PASS/FAIL Indicator. Bit i corresponds to the ith transmit or
    ///< ith receive path element being tested. 1 = PASS, FAIL = 0.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_bist_stat_reg_t;

#define TEST_MEM_BIST_STAT_DEFAULT (0x00000000U)
#define TEST_MEM_BIST_STAT_RD_MASK (0x000007ffU)
#define TEST_MEM_BIST_STAT_WR_MASK (0x000007ffU)


///< BIST test complete indicator
#define TEST_MEM_BIST_STAT_DONE_BF_OFF ( 0)
#define TEST_MEM_BIST_STAT_DONE_BF_WID ( 1)
#define TEST_MEM_BIST_STAT_DONE_BF_MSK (0x00000001)
#define TEST_MEM_BIST_STAT_DONE_BF_DEF (0x00000000)

///< BIST PASS/FAIL Indicator. Bit i corresponds to the ith transmit or
///< ith receive path element being tested. 1 = PASS, FAIL = 0.
#define TEST_MEM_BIST_STAT_PASS_BF_OFF ( 1)
#define TEST_MEM_BIST_STAT_PASS_BF_WID (10)
#define TEST_MEM_BIST_STAT_PASS_BF_MSK (0x000007FE)
#define TEST_MEM_BIST_STAT_PASS_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_BIST_WAIT_TIME register description at address offset 0x7c
  *
  * Register default value:        0x000003E8
  * Register full path in IP: test_map_MEM/test_map/BIST_WAIT_TIME
  * BIST Wait to Test Time Register
  */

typedef union {
  struct {
    uint32_t WAIT_TIME : 20;
    ///< Number of clock cycles that BIST logic waits after starting a test
    ///< before the logic starts to verify that error is withing bound
    ///< AccessType="RW" BitOffset="0" ResetValue="0x3E8"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_bist_wait_time_reg_t;

#define TEST_MEM_BIST_WAIT_TIME_DEFAULT (0x000003e8U)
#define TEST_MEM_BIST_WAIT_TIME_RD_MASK (0x000fffffU)
#define TEST_MEM_BIST_WAIT_TIME_WR_MASK (0x000fffffU)


///< Number of clock cycles that BIST logic waits after starting a test
///< before the logic starts to verify that error is withing bound
#define TEST_MEM_BIST_WAIT_TIME_WAIT_TIME_BF_OFF ( 0)
#define TEST_MEM_BIST_WAIT_TIME_WAIT_TIME_BF_WID (20)
#define TEST_MEM_BIST_WAIT_TIME_WAIT_TIME_BF_MSK (0x000FFFFF)
#define TEST_MEM_BIST_WAIT_TIME_WAIT_TIME_BF_DEF (0x000003E8)


/** @brief TEST_MAP_MEM_TEST_MAP_BIST_TEST_TIME register description at address offset 0x80
  *
  * Register default value:        0x000003E8
  * Register full path in IP: test_map_MEM/test_map/BIST_TEST_TIME
  * BIST Test Time Register
  */

typedef union {
  struct {
    uint32_t TEST_TIME : 20;
    ///< Number of clock cycles that BIST logic tests the error signal for
    ///< prior to determining the PASS/FAIL status.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x3E8"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_bist_test_time_reg_t;

#define TEST_MEM_BIST_TEST_TIME_DEFAULT (0x000003e8U)
#define TEST_MEM_BIST_TEST_TIME_RD_MASK (0x000fffffU)
#define TEST_MEM_BIST_TEST_TIME_WR_MASK (0x000fffffU)


///< Number of clock cycles that BIST logic tests the error signal for
///< prior to determining the PASS/FAIL status.
#define TEST_MEM_BIST_TEST_TIME_TEST_TIME_BF_OFF ( 0)
#define TEST_MEM_BIST_TEST_TIME_TEST_TIME_BF_WID (20)
#define TEST_MEM_BIST_TEST_TIME_TEST_TIME_BF_MSK (0x000FFFFF)
#define TEST_MEM_BIST_TEST_TIME_TEST_TIME_BF_DEF (0x000003E8)


/** @brief TEST_MAP_MEM_TEST_MAP_BIST_PLL_BYPASS_PHASE register description at address offset 0x84
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/BIST_PLL_BYPASS_PHASE
  * BIST Pll Bypass Phase Register
  */

typedef union {
  struct {
    uint32_t PHASE : 32;
    ///< Scratch pad
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_bist_pll_byp_phase_reg_t;

#define TEST_MEM_BIST_PLL_BYP_PHASE_DEFAULT (0x00000000U)
#define TEST_MEM_BIST_PLL_BYP_PHASE_RD_MASK (0xffffffffU)
#define TEST_MEM_BIST_PLL_BYP_PHASE_WR_MASK (0xffffffffU)


///< Scratch pad
#define TEST_MEM_BIST_PLL_BYP_PHASE_BF_OFF ( 0)
#define TEST_MEM_BIST_PLL_BYP_PHASE_BF_WID (32)
#define TEST_MEM_BIST_PLL_BYP_PHASE_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_BIST_PLL_BYP_PHASE_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_BIST_PLL_BYPASS_MULT register description at address offset 0x88
  *
  * Register default value:        0x40000000
  * Register full path in IP: test_map_MEM/test_map/BIST_PLL_BYPASS_MULT
  * BIST Amp Bypass Mult Register
  */

typedef union {
  struct {
    uint32_t MULTIPLIER : 32;
    ///< Scratch pad
    ///< AccessType="RW" BitOffset="0" ResetValue="0x40000000"
  } ;
  uint32_t value;
} test_mem_bist_pll_byp_mult_reg_t;

#define TEST_MEM_BIST_PLL_BYP_MULT_DEFAULT (0x40000000U)
#define TEST_MEM_BIST_PLL_BYP_MULT_RD_MASK (0xffffffffU)
#define TEST_MEM_BIST_PLL_BYP_MULT_WR_MASK (0xffffffffU)


///< Scratch pad
#define TEST_MEM_BIST_PLL_BYP_MULT_MULTIPLIER_BF_OFF ( 0)
#define TEST_MEM_BIST_PLL_BYP_MULT_MULTIPLIER_BF_WID (32)
#define TEST_MEM_BIST_PLL_BYP_MULT_MULTIPLIER_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_BIST_PLL_BYP_MULT_MULTIPLIER_BF_DEF (0x40000000)


/** @brief TEST_MAP_MEM_TEST_MAP_BIST_AMPLITUDE_MULTIPLIER register description at address offset 0x8c
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/BIST_AMPLITUDE_MULTIPLIER
  * BIST Amplitude Multiplier Register
  */

typedef union {
  struct {
    uint32_t MULTIPLIER : 32;
    ///< Scratch pad
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_bist_amplitude_multiplier_reg_t;

#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_DEFAULT (0x00000000U)
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_RD_MASK (0xffffffffU)
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_WR_MASK (0x00000000U)


///< Scratch pad
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_BF_OFF ( 0)
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_BF_WID (32)
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_TPACK_FIFO_WM register description at address offset 0xe8
  *
  * Register default value:        0x00000005
  * Register full path in IP: test_map_MEM/test_map/TPACK_FIFO_WM
  * 16-Entry Clock Crossing FIFO Watermarks Register
  */

typedef union {
  struct {
    uint32_t LOW_WM : 2;
    ///< FIFO Low Watermark
    ///< AccessType="RW" BitOffset="0" ResetValue="0x1"
    uint32_t HIGH_WM : 2;
    ///< FIFO High Watermark
    ///< AccessType="RW" BitOffset="2" ResetValue="0x1"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_tpack_fifo_wm_reg_t;

#define TEST_MEM_TPACK_FIFO_WM_DEFAULT (0x00000005U)
#define TEST_MEM_TPACK_FIFO_WM_RD_MASK (0x0000000fU)
#define TEST_MEM_TPACK_FIFO_WM_WR_MASK (0x0000000fU)


///< FIFO Low Watermark
#define TEST_MEM_TPACK_FIFO_WM_LOW_WM_BF_OFF ( 0)
#define TEST_MEM_TPACK_FIFO_WM_LOW_WM_BF_WID ( 2)
#define TEST_MEM_TPACK_FIFO_WM_LOW_WM_BF_MSK (0x00000003)
#define TEST_MEM_TPACK_FIFO_WM_LOW_WM_BF_DEF (0x00000001)

///< FIFO High Watermark
#define TEST_MEM_TPACK_FIFO_WM_HIGH_WM_BF_OFF ( 2)
#define TEST_MEM_TPACK_FIFO_WM_HIGH_WM_BF_WID ( 2)
#define TEST_MEM_TPACK_FIFO_WM_HIGH_WM_BF_MSK (0x0000000C)
#define TEST_MEM_TPACK_FIFO_WM_HIGH_WM_BF_DEF (0x00000004)


/** @brief TEST_MAP_MEM_TEST_MAP_TDPACK_CFG register description at address offset 0xf0
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TDPACK_CFG
  * TDPACK Configuration Register
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< Enable Tester Read function
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 31;
    ///< Reserved
    ///< AccessType="RO" BitOffset="1" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_tdpack_cfg_reg_t;

#define TEST_MEM_TDPACK_CFG_DEFAULT (0x00000000U)
#define TEST_MEM_TDPACK_CFG_RD_MASK (0x00000001U)
#define TEST_MEM_TDPACK_CFG_WR_MASK (0x00000001U)


///< Enable Tester Read function
#define TEST_MEM_TDPACK_CFG_EN_BF_OFF ( 0)
#define TEST_MEM_TDPACK_CFG_EN_BF_WID ( 1)
#define TEST_MEM_TDPACK_CFG_EN_BF_MSK (0x00000001)
#define TEST_MEM_TDPACK_CFG_EN_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_MSO_FIFO_STAT[3] register description at address offset 0x100
  *
  * Register default value:        0x0000000C
  * Register full path in IP: test_map_MEM/test_map/MSO_FIFO_STAT
  * 16-Entry Clock Crossing FIFO Status Register
  */

typedef union {
  struct {
    uint32_t FIFO_UNDERFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_OVERFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t ALMOST_EMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t ALMOST_FULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 5;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_mso_fifo_stat_reg_t;

#define TEST_MEM_MSO_FIFO_STAT_DEFAULT (0x0000000cU)
#define TEST_MEM_MSO_FIFO_STAT_RD_MASK (0x000007ffU)
#define TEST_MEM_MSO_FIFO_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define TEST_MEM_MSO_FIFO_STAT_UNDERFLOW_BF_OFF ( 0)
#define TEST_MEM_MSO_FIFO_STAT_UNDERFLOW_BF_WID ( 1)
#define TEST_MEM_MSO_FIFO_STAT_UNDERFLOW_BF_MSK (0x00000001)
#define TEST_MEM_MSO_FIFO_STAT_UNDERFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define TEST_MEM_MSO_FIFO_STAT_OVERFLOW_BF_OFF ( 1)
#define TEST_MEM_MSO_FIFO_STAT_OVERFLOW_BF_WID ( 1)
#define TEST_MEM_MSO_FIFO_STAT_OVERFLOW_BF_MSK (0x00000002)
#define TEST_MEM_MSO_FIFO_STAT_OVERFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define TEST_MEM_MSO_FIFO_STAT_EMPTY_BF_OFF ( 2)
#define TEST_MEM_MSO_FIFO_STAT_EMPTY_BF_WID ( 1)
#define TEST_MEM_MSO_FIFO_STAT_EMPTY_BF_MSK (0x00000004)
#define TEST_MEM_MSO_FIFO_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define TEST_MEM_MSO_FIFO_STAT_ALMOST_EMPTY_BF_OFF ( 3)
#define TEST_MEM_MSO_FIFO_STAT_ALMOST_EMPTY_BF_WID ( 1)
#define TEST_MEM_MSO_FIFO_STAT_ALMOST_EMPTY_BF_MSK (0x00000008)
#define TEST_MEM_MSO_FIFO_STAT_ALMOST_EMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define TEST_MEM_MSO_FIFO_STAT_ALMOST_FULL_BF_OFF ( 4)
#define TEST_MEM_MSO_FIFO_STAT_ALMOST_FULL_BF_WID ( 1)
#define TEST_MEM_MSO_FIFO_STAT_ALMOST_FULL_BF_MSK (0x00000010)
#define TEST_MEM_MSO_FIFO_STAT_ALMOST_FULL_BF_DEF (0x00000000)

///< FIFO Full
#define TEST_MEM_MSO_FIFO_STAT_FULL_BF_OFF ( 5)
#define TEST_MEM_MSO_FIFO_STAT_FULL_BF_WID ( 1)
#define TEST_MEM_MSO_FIFO_STAT_FULL_BF_MSK (0x00000020)
#define TEST_MEM_MSO_FIFO_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define TEST_MEM_MSO_FIFO_STAT_DEPTH_BF_OFF ( 6)
#define TEST_MEM_MSO_FIFO_STAT_DEPTH_BF_WID ( 5)
#define TEST_MEM_MSO_FIFO_STAT_DEPTH_BF_MSK (0x000007C0)
#define TEST_MEM_MSO_FIFO_STAT_DEPTH_BF_DEF (0x00000000)
#define TEST_MEM_MSO_FIFO_STAT_ARR_SZ0 (3)
#define TEST_MEM_MSO_FIFO_STAT_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_PLL_DBGM_FIFO_STAT register description at address offset 0x110
  *
  * Register default value:        0x0000000C
  * Register full path in IP: test_map_MEM/test_map/PLL_DBGM_FIFO_STAT
  * 16-Entry Clock Crossing FIFO Status Register
  */

typedef union {
  struct {
    uint32_t FIFO_UNDERFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_OVERFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t ALMOST_EMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t ALMOST_FULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 5;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_pll_dbgm_fifo_stat_reg_t;

#define TEST_MEM_PLL_DBGM_FIFO_STAT_DEFAULT (0x0000000cU)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_RD_MASK (0x000007ffU)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define TEST_MEM_PLL_DBGM_FIFO_STAT_UNDERFLOW_BF_OFF ( 0)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_UNDERFLOW_BF_WID ( 1)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_UNDERFLOW_BF_MSK (0x00000001)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_UNDERFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define TEST_MEM_PLL_DBGM_FIFO_STAT_OVERFLOW_BF_OFF ( 1)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_OVERFLOW_BF_WID ( 1)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_OVERFLOW_BF_MSK (0x00000002)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_OVERFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define TEST_MEM_PLL_DBGM_FIFO_STAT_EMPTY_BF_OFF ( 2)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_EMPTY_BF_WID ( 1)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_EMPTY_BF_MSK (0x00000004)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ALMOST_EMPTY_BF_OFF ( 3)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ALMOST_EMPTY_BF_WID ( 1)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ALMOST_EMPTY_BF_MSK (0x00000008)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ALMOST_EMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ALMOST_FULL_BF_OFF ( 4)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ALMOST_FULL_BF_WID ( 1)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ALMOST_FULL_BF_MSK (0x00000010)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_ALMOST_FULL_BF_DEF (0x00000000)

///< FIFO Full
#define TEST_MEM_PLL_DBGM_FIFO_STAT_FULL_BF_OFF ( 5)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_FULL_BF_WID ( 1)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_FULL_BF_MSK (0x00000020)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define TEST_MEM_PLL_DBGM_FIFO_STAT_DEPTH_BF_OFF ( 6)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_DEPTH_BF_WID ( 5)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_DEPTH_BF_MSK (0x000007C0)
#define TEST_MEM_PLL_DBGM_FIFO_STAT_DEPTH_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_TPACK_FIFO_STAT register description at address offset 0x124
  *
  * Register default value:        0x0000000C
  * Register full path in IP: test_map_MEM/test_map/TPACK_FIFO_STAT
  * 16-Entry Clock Crossing FIFO Status Register
  */

typedef union {
  struct {
    uint32_t FIFO_UNDERFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_OVERFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t ALMOST_EMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t ALMOST_FULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 2;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 24;
    ///< Reserved
    ///< AccessType="RO" BitOffset="8" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_tpack_fifo_stat_reg_t;

#define TEST_MEM_TPACK_FIFO_STAT_DEFAULT (0x0000000cU)
#define TEST_MEM_TPACK_FIFO_STAT_RD_MASK (0x000000ffU)
#define TEST_MEM_TPACK_FIFO_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define TEST_MEM_TPACK_FIFO_STAT_UNDERFLOW_BF_OFF ( 0)
#define TEST_MEM_TPACK_FIFO_STAT_UNDERFLOW_BF_WID ( 1)
#define TEST_MEM_TPACK_FIFO_STAT_UNDERFLOW_BF_MSK (0x00000001)
#define TEST_MEM_TPACK_FIFO_STAT_UNDERFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define TEST_MEM_TPACK_FIFO_STAT_OVERFLOW_BF_OFF ( 1)
#define TEST_MEM_TPACK_FIFO_STAT_OVERFLOW_BF_WID ( 1)
#define TEST_MEM_TPACK_FIFO_STAT_OVERFLOW_BF_MSK (0x00000002)
#define TEST_MEM_TPACK_FIFO_STAT_OVERFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define TEST_MEM_TPACK_FIFO_STAT_EMPTY_BF_OFF ( 2)
#define TEST_MEM_TPACK_FIFO_STAT_EMPTY_BF_WID ( 1)
#define TEST_MEM_TPACK_FIFO_STAT_EMPTY_BF_MSK (0x00000004)
#define TEST_MEM_TPACK_FIFO_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define TEST_MEM_TPACK_FIFO_STAT_ALMOST_EMPTY_BF_OFF ( 3)
#define TEST_MEM_TPACK_FIFO_STAT_ALMOST_EMPTY_BF_WID ( 1)
#define TEST_MEM_TPACK_FIFO_STAT_ALMOST_EMPTY_BF_MSK (0x00000008)
#define TEST_MEM_TPACK_FIFO_STAT_ALMOST_EMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define TEST_MEM_TPACK_FIFO_STAT_ALMOST_FULL_BF_OFF ( 4)
#define TEST_MEM_TPACK_FIFO_STAT_ALMOST_FULL_BF_WID ( 1)
#define TEST_MEM_TPACK_FIFO_STAT_ALMOST_FULL_BF_MSK (0x00000010)
#define TEST_MEM_TPACK_FIFO_STAT_ALMOST_FULL_BF_DEF (0x00000000)

///< FIFO Full
#define TEST_MEM_TPACK_FIFO_STAT_FULL_BF_OFF ( 5)
#define TEST_MEM_TPACK_FIFO_STAT_FULL_BF_WID ( 1)
#define TEST_MEM_TPACK_FIFO_STAT_FULL_BF_MSK (0x00000020)
#define TEST_MEM_TPACK_FIFO_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define TEST_MEM_TPACK_FIFO_STAT_DEPTH_BF_OFF ( 6)
#define TEST_MEM_TPACK_FIFO_STAT_DEPTH_BF_WID ( 2)
#define TEST_MEM_TPACK_FIFO_STAT_DEPTH_BF_MSK (0x000000C0)
#define TEST_MEM_TPACK_FIFO_STAT_DEPTH_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_FIFO_FLUSH register description at address offset 0x128
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/FIFO_FLUSH
  * FIFO Flush Register
  */

typedef union {
  struct {
    uint32_t MSI_0 : 1;
    ///< If set to 1, then flush the sync FIFO in MSI_0
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MSI_1 : 1;
    ///< If set to 1, then flush the sync FIFO in MSI_1
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t MSI_2 : 1;
    ///< If set to 1, then flush the sync FIFO in MSI_2
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t MSI_3 : 1;
    ///< If set to 1, then flush the sync FIFO in MSI_3
    ///< AccessType="RW" BitOffset="3" ResetValue="0x0"
    uint32_t MSI_4 : 1;
    ///< If set to 1, then flush the sync FIFO in MSI_4
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t MSO_0 : 1;
    ///< If set to 1, then flush the sync FIFO in MSO_0
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t MSO_1 : 1;
    ///< If set to 1, then flush the sync FIFO in MSO_1
    ///< AccessType="RW" BitOffset="6" ResetValue="0x0"
    uint32_t MSO_2 : 1;
    ///< If set to 1, then flush the sync FIFO in MSO_2
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t TPACK : 1;
    ///< If set to 1, then flush the sync FIFO in TPACK
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t TDPACK : 1;
    ///< If set to 1, then flush the sync FIFO in TDPACK
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_fifo_flush_reg_t;

#define TEST_MEM_FIFO_FLUSH_DEFAULT (0x00000000U)
#define TEST_MEM_FIFO_FLUSH_RD_MASK (0x000003ffU)
#define TEST_MEM_FIFO_FLUSH_WR_MASK (0x000003ffU)


///< If set to 1, then flush the sync FIFO in MSI_0
#define TEST_MEM_FIFO_FLUSH_MSI_0_BF_OFF ( 0)
#define TEST_MEM_FIFO_FLUSH_MSI_0_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_MSI_0_BF_MSK (0x00000001)
#define TEST_MEM_FIFO_FLUSH_MSI_0_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in MSI_1
#define TEST_MEM_FIFO_FLUSH_MSI_1_BF_OFF ( 1)
#define TEST_MEM_FIFO_FLUSH_MSI_1_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_MSI_1_BF_MSK (0x00000002)
#define TEST_MEM_FIFO_FLUSH_MSI_1_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in MSI_2
#define TEST_MEM_FIFO_FLUSH_MSI_2_BF_OFF ( 2)
#define TEST_MEM_FIFO_FLUSH_MSI_2_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_MSI_2_BF_MSK (0x00000004)
#define TEST_MEM_FIFO_FLUSH_MSI_2_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in MSI_3
#define TEST_MEM_FIFO_FLUSH_MSI_3_BF_OFF ( 3)
#define TEST_MEM_FIFO_FLUSH_MSI_3_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_MSI_3_BF_MSK (0x00000008)
#define TEST_MEM_FIFO_FLUSH_MSI_3_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in MSI_4
#define TEST_MEM_FIFO_FLUSH_MSI_4_BF_OFF ( 4)
#define TEST_MEM_FIFO_FLUSH_MSI_4_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_MSI_4_BF_MSK (0x00000010)
#define TEST_MEM_FIFO_FLUSH_MSI_4_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in MSO_0
#define TEST_MEM_FIFO_FLUSH_MSO_0_BF_OFF ( 5)
#define TEST_MEM_FIFO_FLUSH_MSO_0_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_MSO_0_BF_MSK (0x00000020)
#define TEST_MEM_FIFO_FLUSH_MSO_0_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in MSO_1
#define TEST_MEM_FIFO_FLUSH_MSO_1_BF_OFF ( 6)
#define TEST_MEM_FIFO_FLUSH_MSO_1_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_MSO_1_BF_MSK (0x00000040)
#define TEST_MEM_FIFO_FLUSH_MSO_1_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in MSO_2
#define TEST_MEM_FIFO_FLUSH_MSO_2_BF_OFF ( 7)
#define TEST_MEM_FIFO_FLUSH_MSO_2_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_MSO_2_BF_MSK (0x00000080)
#define TEST_MEM_FIFO_FLUSH_MSO_2_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in TPACK
#define TEST_MEM_FIFO_FLUSH_TPACK_BF_OFF ( 8)
#define TEST_MEM_FIFO_FLUSH_TPACK_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_TPACK_BF_MSK (0x00000100)
#define TEST_MEM_FIFO_FLUSH_TPACK_BF_DEF (0x00000000)

///< If set to 1, then flush the sync FIFO in TDPACK
#define TEST_MEM_FIFO_FLUSH_TDPACK_BF_OFF ( 9)
#define TEST_MEM_FIFO_FLUSH_TDPACK_BF_WID ( 1)
#define TEST_MEM_FIFO_FLUSH_TDPACK_BF_MSK (0x00000200)
#define TEST_MEM_FIFO_FLUSH_TDPACK_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_TEST_ERR register description at address offset 0x12c
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TEST_ERR
  * Test Error Indication
  */

typedef union {
  struct {
    uint32_t FIFO_OF_ERR : 10;
    ///< Indicates overflow error occured in one the MEM_CAP's internal fifos.
    ///< Bit i indicates overflow status of FIFOs listed below.  0 - MSI FIFO
    ///< #0 1 - MSI FIFO #1 2 - MSI FIFO #2 3 - MSI FIFO #3 4 - MSI FIFO #4
    ///< 5 - MS0 FIFO #0 6 - MS0 FIFO #1 7 - MS0 FIFO #2 8 - MS0 FIFO #3 9
    ///< - TPACK FIFO
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_UF_ERR : 10;
    ///< Indicates underflow error occured in one the MEM_CAP's internal fifos.
    ///< Bit i indicates underflow status of FIFOs listed below.  0 - MSI FIFO
    ///< #0 1 - MSI FIFO #1 2 - MSI FIFO #2 3 - MSI FIFO #3 4 - MSI FIFO #4
    ///< 5 - MS0 FIFO #0 6 - MS0 FIFO #1 7 - MS0 FIFO #2 8 - MS0 FIFO #3 9
    ///< - TPACK FIFO
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_test_err_reg_t;

#define TEST_MEM_TEST_ERR_DEFAULT (0x00000000U)
#define TEST_MEM_TEST_ERR_RD_MASK (0x000fffffU)
#define TEST_MEM_TEST_ERR_WR_MASK (0x000fffffU)


///< Indicates overflow error occured in one the MEM_CAP's internal fifos.
///< Bit i indicates overflow status of FIFOs listed below.  0 - MSI FIFO
///< #0 1 - MSI FIFO #1 2 - MSI FIFO #2 3 - MSI FIFO #3 4 - MSI FIFO #4
///< 5 - MS0 FIFO #0 6 - MS0 FIFO #1 7 - MS0 FIFO #2 8 - MS0 FIFO #3 9
///< - TPACK FIFO
#define TEST_MEM_TEST_ERR_FIFO_OF_ERR_BF_OFF ( 0)
#define TEST_MEM_TEST_ERR_FIFO_OF_ERR_BF_WID (10)
#define TEST_MEM_TEST_ERR_FIFO_OF_ERR_BF_MSK (0x000003FF)
#define TEST_MEM_TEST_ERR_FIFO_OF_ERR_BF_DEF (0x00000000)

///< Indicates underflow error occured in one the MEM_CAP's internal fifos.
///< Bit i indicates underflow status of FIFOs listed below.  0 - MSI FIFO
///< #0 1 - MSI FIFO #1 2 - MSI FIFO #2 3 - MSI FIFO #3 4 - MSI FIFO #4
///< 5 - MS0 FIFO #0 6 - MS0 FIFO #1 7 - MS0 FIFO #2 8 - MS0 FIFO #3 9
///< - TPACK FIFO
#define TEST_MEM_TEST_ERR_FIFO_UF_ERR_BF_OFF (10)
#define TEST_MEM_TEST_ERR_FIFO_UF_ERR_BF_WID (10)
#define TEST_MEM_TEST_ERR_FIFO_UF_ERR_BF_MSK (0x000FFC00)
#define TEST_MEM_TEST_ERR_FIFO_UF_ERR_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_PACKER_CFG register description at address offset 0x130
  *
  * Register default value:        0x0FC00000
  * Register full path in IP: test_map_MEM/test_map/PACKER_CFG
  * Real Packer Configuration
  */

typedef union {
  struct {
    uint32_t RPACK0_EN : 1;
    ///< Enable for Real Packer 0. When set to 1, enables the corresponding
    ///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
    ///< is disabled and no valid is asserted.
    ///< AccessType="RW/V" BitOffset="0" ResetValue="0x0"
    uint32_t RPACK0_USE_UPPER : 1;
    ///< Use Upper for Real Packer 0.  This control bit is only valid when
    ///< operating at an antenna rate of 8 GSPS or less for capturing ASC Post
    ///< data.  The system must also be operating in FDD mode, where half of
    ///< the 16 lanes of data is used for calibration purposes. When set to
    ///< 1, the real packer will use data in lanes 15-8 as the source of data
    ///< for the packing operation. When set to 0, the real packer will use
    ///< data in lanes 7-0. Lane usage as a function of ant_rate when USE_UPPER
    ///< = 1 8:  15-8 6:  13-8 4:  11-8 3:  10-8 Otherwise, the real packer
    ///< packs data as follows: 16: 15-0 12: 11-0 8:  7-0 6:  5-0 4:  3-0 3:
    ///< 2-0
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t RPACK0_ASC_PRE : 1;
    ///< ASC PRE for Real Packer 0. When set to 1, indicates to the respective
    ///< packer that the data arriving on the corresponding input data bus
    ///< is from a PRE_ASC Capture point. When set to 0, the data arriving
    ///< on the input but is from a POST_ASC capture point.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t RPACK1_EN : 1;
    ///< Enable for Real Packer 1. When set to 1, enables the corresponding
    ///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
    ///< is disabled and no valid is asserted.
    ///< AccessType="RW/V" BitOffset="3" ResetValue="0x0"
    uint32_t RPACK1_USE_UPPER : 1;
    ///< Use Upper for Real Packer 1.  This control bit is only valid when
    ///< operating at an antenna rate of 8 GSPS or less for capturing ASC Post
    ///< data.  The system must also be operating in FDD mode, where half of
    ///< the 16 lanes of data is used for calibration purposes. When set to
    ///< 1, the real packer will use data in lanes 15-8 as the source of data
    ///< for the packing operation. When set to 0, the real packer will use
    ///< data in lanes 7-0. Lane usage as a function of ant_rate when USE_UPPER
    ///< = 1 8:  15-8 6:  13-8 4:  11-8 3:  10-8 Otherwise, the real packer
    ///< packs data as follows: 16: 15-0 12: 11-0 8:  7-0 6:  5-0 4:  3-0 3:
    ///< 2-0
    ///< AccessType="RW" BitOffset="4" ResetValue="0x0"
    uint32_t RPACK1_ASC_PRE : 1;
    ///< ASC PRE for Real Packer 1. When set to 1, indicates to the respective
    ///< packer that the data arriving on the corresponding input data bus
    ///< is from a PRE_ASC Capture point. When set to 0, the data arriving
    ///< on the input but is from a POST_ASC capture point.
    ///< AccessType="RW" BitOffset="5" ResetValue="0x0"
    uint32_t RPACK2_EN : 1;
    ///< Enable for Real Packer 2. When set to 1, enables the corresponding
    ///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
    ///< is disabled and no valid is asserted.
    ///< AccessType="RW/V" BitOffset="6" ResetValue="0x0"
    uint32_t RPACK2_USE_UPPER : 1;
    ///< Use Upper for Real Packer 2.  This control bit is only valid when
    ///< operating at an antenna rate of 8 GSPS or less for capturing ASC Post
    ///< data.  The system must also be operating in FDD mode, where half of
    ///< the 16 lanes of data is used for calibration purposes. When set to
    ///< 1, the real packer will use data in lanes 15-8 as the source of data
    ///< for the packing operation. When set to 0, the real packer will use
    ///< data in lanes 7-0. Lane usage as a function of ant_rate when USE_UPPER
    ///< = 1 8:  15-8 6:  13-8 4:  11-8 3:  10-8 Otherwise, the real packer
    ///< packs data as follows: 16: 15-0 12: 11-0 8:  7-0 6:  5-0 4:  3-0 3:
    ///< 2-0
    ///< AccessType="RW" BitOffset="7" ResetValue="0x0"
    uint32_t RPACK2_ASC_PRE : 1;
    ///< ASC PRE for Real Packer 2. When set to 1, indicates to the respective
    ///< packer that the data arriving on the corresponding input data bus
    ///< is from a PRE_ASC Capture point. When set to 0, the data arriving
    ///< on the input but is from a POST_ASC capture point.
    ///< AccessType="RW" BitOffset="8" ResetValue="0x0"
    uint32_t RPACK3_EN : 1;
    ///< Enable for Real Packer 3. When set to 1, enables the corresponding
    ///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
    ///< is disabled and no valid is asserted.
    ///< AccessType="RW/V" BitOffset="9" ResetValue="0x0"
    uint32_t RPACK3_USE_UPPER : 1;
    ///< Use Upper for Real Packer 3.  This control bit is only valid when
    ///< operating at an antenna rate of 8 GSPS or less for capturing ASC Post
    ///< data.  The system must also be operating in FDD mode, where half of
    ///< the 16 lanes of data is used for calibration purposes. When set to
    ///< 1, the real packer will use data in lanes 15-8 as the source of data
    ///< for the packing operation. When set to 0, the real packer will use
    ///< data in lanes 7-0. Lane usage as a function of ant_rate when USE_UPPER
    ///< = 1 8:  15-8 6:  13-8 4:  11-8 3:  10-8 Otherwise, the real packer
    ///< packs data as follows: 16: 15-0 12: 11-0 8:  7-0 6:  5-0 4:  3-0 3:
    ///< 2-0
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t RPACK3_ASC_PRE : 1;
    ///< ASC PRE for Real Packer 3. When set to 1, indicates to the respective
    ///< packer that the data arriving on the corresponding input data bus
    ///< is from a PRE_ASC Capture point. When set to 0, the data arriving
    ///< on the input but is from a POST_ASC capture point.
    ///< AccessType="RW" BitOffset="11" ResetValue="0x0"
    uint32_t SPACK0_EN : 1;
    ///< Enable for SSAR Packer 0. When set to 1, enables the corresponding
    ///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
    ///< is disabled and no valid is asserted.
    ///< AccessType="RW/V" BitOffset="12" ResetValue="0x0"
    uint32_t SPACK0_POST_IN : 1;
    ///< POST_IN for SSAR Packer 0.  When set to 1, the packer is configured
    ///< to process data at the ASC output. When set to 0, the packer is configured
    ///< to process data arriving at the ASC input.
    ///< AccessType="RW" BitOffset="13" ResetValue="0x0"
    uint32_t SPACK0_PLL_IN : 1;
    ///< PLL_IN for SSAR Packer 0. When set to 1, the packer is configured
    ///< to process PLL test data. This data is 64 bits wide. The packer packs
    ///< 4 clock cycles worth of PLL debug data into a 256-bit word prior to
    ///< passing the packer output to the MEM_CAP's RXBAR submodule. When set
    ///< to 0, the packer assumes it is processig other data per how the other
    ///< configuration bits are set.
    ///< AccessType="RW" BitOffset="14" ResetValue="0x0"
    uint32_t SPACK0_BOOLEAN_EN : 1;
    ///< BOOLEAN EN for SSAR Packer 0. When set to 1, the packer converts the
    ///< 4-bit index and valid bit into a one-hot vector with bit[index] asserted
    ///< to  a 1 when the valid bit = 1, or to 16'b0 if the valid bit = 0.
    ///< Otherwise, when set to 0, the packer packs the 4-bit index and valid
    ///< bit as indicated by the MAS.
    ///< AccessType="RW" BitOffset="15" ResetValue="0x0"
    uint32_t SPACK0_SIMPLE_PACK : 1;
    ///< SIMPLE_PACK SSAR Packer 0. When set to 1, the SSAR packer operates
    ///< in simple pack mode, i.e. packs 32'd0 when valid=0,  and  data[15:0],
    ///< index[15:0]  when valid = 1. When set to 0, the SSAR packer operates
    ///< efficient, it packs 16'd0 when valid = 0, and   data[15:0], index[15:0]
    ///< when valid = 1.
    ///< AccessType="RW" BitOffset="16" ResetValue="0x0"
    uint32_t SPACK1_EN : 1;
    ///< Enable for SSAR Packer 1. When set to 1, enables the corresponding
    ///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
    ///< is disabled and no valid is asserted.
    ///< AccessType="RW/V" BitOffset="17" ResetValue="0x0"
    uint32_t SPACK1_POST_IN : 1;
    ///< POST_IN for SSAR Packer 1.  When set to 1, the packer is configured
    ///< to process data at the ASC output. When set to 0, the packer is configured
    ///< to process data arriving at the ASC input.
    ///< AccessType="RW" BitOffset="18" ResetValue="0x0"
    uint32_t SPACK1_PLL_IN : 1;
    ///< PLL_IN for SSAR Packer 1. When set to 1, the packer is configured
    ///< to process PLL test data. This data is 64 bits wide. The packer packs
    ///< 4 clock cycles worth of PLL debug data into a 256-bit word prior to
    ///< passing the packer output to the MEM_CAP's RXBAR submodule. When set
    ///< to 0, the packer assumes it is processig other data per how the other
    ///< configuration bits are set.
    ///< AccessType="RW" BitOffset="19" ResetValue="0x0"
    uint32_t SPACK1_BOOLEAN_EN : 1;
    ///< BOOLEAN EN for SSAR Packer 1. When set to 1, the packer converts the
    ///< 4-bit index and valid bit into a one-hot vector with bit[index] asserted
    ///< to  a 1 when the valid bit = 1, or to 16'b0 if the valid bit = 0.
    ///< Otherwise, when set to 0, the packer packs the 4-bit index and valid
    ///< bit as indicated by the MAS.
    ///< AccessType="RW" BitOffset="20" ResetValue="0x0"
    uint32_t SPACK1_SIMPLE_PACK : 1;
    ///< SIMPLE_PACK SSAR Packer 1. When set to 1, the SSAR packer operates
    ///< in simple pack mode, i.e. packs 32'd0 when valid=0,  and  data[15:0],
    ///< index[15:0]  when valid = 1. When set to 0, the SSAR packer operates
    ///< efficient, it packs 16'd0 when valid = 0, and   data[15:0], index[15:0]
    ///< when valid = 1.
    ///< AccessType="RW" BitOffset="21" ResetValue="0x0"
    uint32_t BYP_BFN : 6;
    ///< Bypass BFN
    ///< AccessType="RW" BitOffset="22" ResetValue="0x3F"
    uint32_t  : 4;
    ///< Reserved
    ///< AccessType="RO" BitOffset="28" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_packer_cfg_reg_t;

#define TEST_MEM_PACKER_CFG_DEFAULT (0x0fc00000U)
#define TEST_MEM_PACKER_CFG_RD_MASK (0x0fffffffU)
#define TEST_MEM_PACKER_CFG_WR_MASK (0x0fffffffU)


///< Enable for Real Packer 0. When set to 1, enables the corresponding
///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
///< is disabled and no valid is asserted.
#define TEST_MEM_PACKER_CFG_RPACK0_EN_BF_OFF ( 0)
#define TEST_MEM_PACKER_CFG_RPACK0_EN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK0_EN_BF_MSK (0x00000001)
#define TEST_MEM_PACKER_CFG_RPACK0_EN_BF_DEF (0x00000000)

///< Use Upper for Real Packer 0.  This control bit is only valid when
///< operating at an antenna rate of 8 GSPS or less for capturing ASC Post
///< data.  The system must also be operating in FDD mode, where half of
///< the 16 lanes of data is used for calibration purposes. When set to
///< 1, the real packer will use data in lanes 15-8 as the source of data
///< for the packing operation. When set to 0, the real packer will use
///< data in lanes 7-0. Lane usage as a function of ant_rate when USE_UPPER
///< = 1 8:  15-8 6:  13-8 4:  11-8 3:  10-8 Otherwise, the real packer
///< packs data as follows: 16: 15-0 12: 11-0 8:  7-0 6:  5-0 4:  3-0 3:
///< 2-0
#define TEST_MEM_PACKER_CFG_RPACK0_USE_UPPER_BF_OFF ( 1)
#define TEST_MEM_PACKER_CFG_RPACK0_USE_UPPER_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK0_USE_UPPER_BF_MSK (0x00000002)
#define TEST_MEM_PACKER_CFG_RPACK0_USE_UPPER_BF_DEF (0x00000000)

///< ASC PRE for Real Packer 0. When set to 1, indicates to the respective
///< packer that the data arriving on the corresponding input data bus
///< is from a PRE_ASC Capture point. When set to 0, the data arriving
///< on the input but is from a POST_ASC capture point.
#define TEST_MEM_PACKER_CFG_RPACK0_ASC_PRE_BF_OFF ( 2)
#define TEST_MEM_PACKER_CFG_RPACK0_ASC_PRE_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK0_ASC_PRE_BF_MSK (0x00000004)
#define TEST_MEM_PACKER_CFG_RPACK0_ASC_PRE_BF_DEF (0x00000000)

///< Enable for Real Packer 1. When set to 1, enables the corresponding
///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
///< is disabled and no valid is asserted.
#define TEST_MEM_PACKER_CFG_RPACK1_EN_BF_OFF ( 3)
#define TEST_MEM_PACKER_CFG_RPACK1_EN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK1_EN_BF_MSK (0x00000008)
#define TEST_MEM_PACKER_CFG_RPACK1_EN_BF_DEF (0x00000000)

///< Use Upper for Real Packer 1.  This control bit is only valid when
///< operating at an antenna rate of 8 GSPS or less for capturing ASC Post
///< data.  The system must also be operating in FDD mode, where half of
///< the 16 lanes of data is used for calibration purposes. When set to
///< 1, the real packer will use data in lanes 15-8 as the source of data
///< for the packing operation. When set to 0, the real packer will use
///< data in lanes 7-0. Lane usage as a function of ant_rate when USE_UPPER
///< = 1 8:  15-8 6:  13-8 4:  11-8 3:  10-8 Otherwise, the real packer
///< packs data as follows: 16: 15-0 12: 11-0 8:  7-0 6:  5-0 4:  3-0 3:
///< 2-0
#define TEST_MEM_PACKER_CFG_RPACK1_USE_UPPER_BF_OFF ( 4)
#define TEST_MEM_PACKER_CFG_RPACK1_USE_UPPER_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK1_USE_UPPER_BF_MSK (0x00000010)
#define TEST_MEM_PACKER_CFG_RPACK1_USE_UPPER_BF_DEF (0x00000000)

///< ASC PRE for Real Packer 1. When set to 1, indicates to the respective
///< packer that the data arriving on the corresponding input data bus
///< is from a PRE_ASC Capture point. When set to 0, the data arriving
///< on the input but is from a POST_ASC capture point.
#define TEST_MEM_PACKER_CFG_RPACK1_ASC_PRE_BF_OFF ( 5)
#define TEST_MEM_PACKER_CFG_RPACK1_ASC_PRE_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK1_ASC_PRE_BF_MSK (0x00000020)
#define TEST_MEM_PACKER_CFG_RPACK1_ASC_PRE_BF_DEF (0x00000000)

///< Enable for Real Packer 2. When set to 1, enables the corresponding
///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
///< is disabled and no valid is asserted.
#define TEST_MEM_PACKER_CFG_RPACK2_EN_BF_OFF ( 6)
#define TEST_MEM_PACKER_CFG_RPACK2_EN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK2_EN_BF_MSK (0x00000040)
#define TEST_MEM_PACKER_CFG_RPACK2_EN_BF_DEF (0x00000000)

///< Use Upper for Real Packer 2.  This control bit is only valid when
///< operating at an antenna rate of 8 GSPS or less for capturing ASC Post
///< data.  The system must also be operating in FDD mode, where half of
///< the 16 lanes of data is used for calibration purposes. When set to
///< 1, the real packer will use data in lanes 15-8 as the source of data
///< for the packing operation. When set to 0, the real packer will use
///< data in lanes 7-0. Lane usage as a function of ant_rate when USE_UPPER
///< = 1 8:  15-8 6:  13-8 4:  11-8 3:  10-8 Otherwise, the real packer
///< packs data as follows: 16: 15-0 12: 11-0 8:  7-0 6:  5-0 4:  3-0 3:
///< 2-0
#define TEST_MEM_PACKER_CFG_RPACK2_USE_UPPER_BF_OFF ( 7)
#define TEST_MEM_PACKER_CFG_RPACK2_USE_UPPER_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK2_USE_UPPER_BF_MSK (0x00000080)
#define TEST_MEM_PACKER_CFG_RPACK2_USE_UPPER_BF_DEF (0x00000000)

///< ASC PRE for Real Packer 2. When set to 1, indicates to the respective
///< packer that the data arriving on the corresponding input data bus
///< is from a PRE_ASC Capture point. When set to 0, the data arriving
///< on the input but is from a POST_ASC capture point.
#define TEST_MEM_PACKER_CFG_RPACK2_ASC_PRE_BF_OFF ( 8)
#define TEST_MEM_PACKER_CFG_RPACK2_ASC_PRE_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK2_ASC_PRE_BF_MSK (0x00000100)
#define TEST_MEM_PACKER_CFG_RPACK2_ASC_PRE_BF_DEF (0x00000000)

///< Enable for Real Packer 3. When set to 1, enables the corresponding
///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
///< is disabled and no valid is asserted.
#define TEST_MEM_PACKER_CFG_RPACK3_EN_BF_OFF ( 9)
#define TEST_MEM_PACKER_CFG_RPACK3_EN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK3_EN_BF_MSK (0x00000200)
#define TEST_MEM_PACKER_CFG_RPACK3_EN_BF_DEF (0x00000000)

///< Use Upper for Real Packer 3.  This control bit is only valid when
///< operating at an antenna rate of 8 GSPS or less for capturing ASC Post
///< data.  The system must also be operating in FDD mode, where half of
///< the 16 lanes of data is used for calibration purposes. When set to
///< 1, the real packer will use data in lanes 15-8 as the source of data
///< for the packing operation. When set to 0, the real packer will use
///< data in lanes 7-0. Lane usage as a function of ant_rate when USE_UPPER
///< = 1 8:  15-8 6:  13-8 4:  11-8 3:  10-8 Otherwise, the real packer
///< packs data as follows: 16: 15-0 12: 11-0 8:  7-0 6:  5-0 4:  3-0 3:
///< 2-0
#define TEST_MEM_PACKER_CFG_RPACK3_USE_UPPER_BF_OFF (10)
#define TEST_MEM_PACKER_CFG_RPACK3_USE_UPPER_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK3_USE_UPPER_BF_MSK (0x00000400)
#define TEST_MEM_PACKER_CFG_RPACK3_USE_UPPER_BF_DEF (0x00000000)

///< ASC PRE for Real Packer 3. When set to 1, indicates to the respective
///< packer that the data arriving on the corresponding input data bus
///< is from a PRE_ASC Capture point. When set to 0, the data arriving
///< on the input but is from a POST_ASC capture point.
#define TEST_MEM_PACKER_CFG_RPACK3_ASC_PRE_BF_OFF (11)
#define TEST_MEM_PACKER_CFG_RPACK3_ASC_PRE_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_RPACK3_ASC_PRE_BF_MSK (0x00000800)
#define TEST_MEM_PACKER_CFG_RPACK3_ASC_PRE_BF_DEF (0x00000000)

///< Enable for SSAR Packer 0. When set to 1, enables the corresponding
///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
///< is disabled and no valid is asserted.
#define TEST_MEM_PACKER_CFG_SPACK0_EN_BF_OFF (12)
#define TEST_MEM_PACKER_CFG_SPACK0_EN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK0_EN_BF_MSK (0x00001000)
#define TEST_MEM_PACKER_CFG_SPACK0_EN_BF_DEF (0x00000000)

///< POST_IN for SSAR Packer 0.  When set to 1, the packer is configured
///< to process data at the ASC output. When set to 0, the packer is configured
///< to process data arriving at the ASC input.
#define TEST_MEM_PACKER_CFG_SPACK0_POST_IN_BF_OFF (13)
#define TEST_MEM_PACKER_CFG_SPACK0_POST_IN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK0_POST_IN_BF_MSK (0x00002000)
#define TEST_MEM_PACKER_CFG_SPACK0_POST_IN_BF_DEF (0x00000000)

///< PLL_IN for SSAR Packer 0. When set to 1, the packer is configured
///< to process PLL test data. This data is 64 bits wide. The packer packs
///< 4 clock cycles worth of PLL debug data into a 256-bit word prior to
///< passing the packer output to the MEM_CAP's RXBAR submodule. When set
///< to 0, the packer assumes it is processig other data per how the other
///< configuration bits are set.
#define TEST_MEM_PACKER_CFG_SPACK0_PLL_IN_BF_OFF (14)
#define TEST_MEM_PACKER_CFG_SPACK0_PLL_IN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK0_PLL_IN_BF_MSK (0x00004000)
#define TEST_MEM_PACKER_CFG_SPACK0_PLL_IN_BF_DEF (0x00000000)

///< BOOLEAN EN for SSAR Packer 0. When set to 1, the packer converts the
///< 4-bit index and valid bit into a one-hot vector with bit[index] asserted
///< to  a 1 when the valid bit = 1, or to 16'b0 if the valid bit = 0.
///< Otherwise, when set to 0, the packer packs the 4-bit index and valid
///< bit as indicated by the MAS.
#define TEST_MEM_PACKER_CFG_SPACK0_BOOLEAN_EN_BF_OFF (15)
#define TEST_MEM_PACKER_CFG_SPACK0_BOOLEAN_EN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK0_BOOLEAN_EN_BF_MSK (0x00008000)
#define TEST_MEM_PACKER_CFG_SPACK0_BOOLEAN_EN_BF_DEF (0x00000000)

///< SIMPLE_PACK SSAR Packer 0. When set to 1, the SSAR packer operates
///< in simple pack mode, i.e. packs 32'd0 when valid=0,  and  data[15:0],
///< index[15:0]  when valid = 1. When set to 0, the SSAR packer operates
///< efficient, it packs 16'd0 when valid = 0, and   data[15:0], index[15:0]
///< when valid = 1.
#define TEST_MEM_PACKER_CFG_SPACK0_SIMPLE_PACK_BF_OFF (16)
#define TEST_MEM_PACKER_CFG_SPACK0_SIMPLE_PACK_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK0_SIMPLE_PACK_BF_MSK (0x00010000)
#define TEST_MEM_PACKER_CFG_SPACK0_SIMPLE_PACK_BF_DEF (0x00000000)

///< Enable for SSAR Packer 1. When set to 1, enables the corresponding
///< real packer in the MEM_CAP's capture path.  When set to 0, the packer
///< is disabled and no valid is asserted.
#define TEST_MEM_PACKER_CFG_SPACK1_EN_BF_OFF (17)
#define TEST_MEM_PACKER_CFG_SPACK1_EN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK1_EN_BF_MSK (0x00020000)
#define TEST_MEM_PACKER_CFG_SPACK1_EN_BF_DEF (0x00000000)

///< POST_IN for SSAR Packer 1.  When set to 1, the packer is configured
///< to process data at the ASC output. When set to 0, the packer is configured
///< to process data arriving at the ASC input.
#define TEST_MEM_PACKER_CFG_SPACK1_POST_IN_BF_OFF (18)
#define TEST_MEM_PACKER_CFG_SPACK1_POST_IN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK1_POST_IN_BF_MSK (0x00040000)
#define TEST_MEM_PACKER_CFG_SPACK1_POST_IN_BF_DEF (0x00000000)

///< PLL_IN for SSAR Packer 1. When set to 1, the packer is configured
///< to process PLL test data. This data is 64 bits wide. The packer packs
///< 4 clock cycles worth of PLL debug data into a 256-bit word prior to
///< passing the packer output to the MEM_CAP's RXBAR submodule. When set
///< to 0, the packer assumes it is processig other data per how the other
///< configuration bits are set.
#define TEST_MEM_PACKER_CFG_SPACK1_PLL_IN_BF_OFF (19)
#define TEST_MEM_PACKER_CFG_SPACK1_PLL_IN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK1_PLL_IN_BF_MSK (0x00080000)
#define TEST_MEM_PACKER_CFG_SPACK1_PLL_IN_BF_DEF (0x00000000)

///< BOOLEAN EN for SSAR Packer 1. When set to 1, the packer converts the
///< 4-bit index and valid bit into a one-hot vector with bit[index] asserted
///< to  a 1 when the valid bit = 1, or to 16'b0 if the valid bit = 0.
///< Otherwise, when set to 0, the packer packs the 4-bit index and valid
///< bit as indicated by the MAS.
#define TEST_MEM_PACKER_CFG_SPACK1_BOOLEAN_EN_BF_OFF (20)
#define TEST_MEM_PACKER_CFG_SPACK1_BOOLEAN_EN_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK1_BOOLEAN_EN_BF_MSK (0x00100000)
#define TEST_MEM_PACKER_CFG_SPACK1_BOOLEAN_EN_BF_DEF (0x00000000)

///< SIMPLE_PACK SSAR Packer 1. When set to 1, the SSAR packer operates
///< in simple pack mode, i.e. packs 32'd0 when valid=0,  and  data[15:0],
///< index[15:0]  when valid = 1. When set to 0, the SSAR packer operates
///< efficient, it packs 16'd0 when valid = 0, and   data[15:0], index[15:0]
///< when valid = 1.
#define TEST_MEM_PACKER_CFG_SPACK1_SIMPLE_PACK_BF_OFF (21)
#define TEST_MEM_PACKER_CFG_SPACK1_SIMPLE_PACK_BF_WID ( 1)
#define TEST_MEM_PACKER_CFG_SPACK1_SIMPLE_PACK_BF_MSK (0x00200000)
#define TEST_MEM_PACKER_CFG_SPACK1_SIMPLE_PACK_BF_DEF (0x00000000)

///< Bypass BFN
#define TEST_MEM_PACKER_CFG_BYP_BFN_BF_OFF (22)
#define TEST_MEM_PACKER_CFG_BYP_BFN_BF_WID ( 6)
#define TEST_MEM_PACKER_CFG_BYP_BFN_BF_MSK (0x0FC00000)
#define TEST_MEM_PACKER_CFG_BYP_BFN_BF_DEF (0x0FC00000)


/** @brief TEST_MAP_MEM_TEST_MAP_INT_STATUS register description at address offset 0x180
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/INT_STATUS
  * TEST Interrupt Status Register
  */

typedef union {
  struct {
    uint32_t FIFO_OVERFLOW_ERROR : 10;
    ///< Indicates overflow error occured in one the MEM_CAP's internal fifos.
    ///< Bit i indicates overflow status of FIFOs listed below.  0 - MSI FIFO
    ///< #0 1 - MSI FIFO #1 2 - MSI FIFO #2 3 - MSI FIFO #3 4 - MSI FIFO #4
    ///< 5 - MS0 FIFO #0 6 - MS0 FIFO #1 7 - MS0 FIFO #2 8 - Reserved    9
    ///< - TPACK FIFO
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_UNDERFLOW_ERROR : 10;
    ///< Indicates underflow error occured in one the MEM_CAP's internal fifos.
    ///< Bit i indicates underflow status of FIFOs listed below.  0 - MSI FIFO
    ///< #0 1 - MSI FIFO #1 2 - MSI FIFO #2 3 - MSI FIFO #3 4 - MSI FIFO #4
    ///< 5 - MS0 FIFO #0 6 - MS0 FIFO #1 7 - MS0 FIFO #2 8 - Reserved     9
    ///< - TPACK FIFO
    ///< AccessType="RO/V" BitOffset="10" ResetValue="0x0"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_int_stat_reg_t;

#define TEST_MEM_INT_STAT_DEFAULT (0x00000000U)
#define TEST_MEM_INT_STAT_RD_MASK (0x000fffffU)
#define TEST_MEM_INT_STAT_WR_MASK (0x00000000U)


///< Indicates overflow error occured in one the MEM_CAP's internal fifos.
///< Bit i indicates overflow status of FIFOs listed below.  0 - MSI FIFO
///< #0 1 - MSI FIFO #1 2 - MSI FIFO #2 3 - MSI FIFO #3 4 - MSI FIFO #4
///< 5 - MS0 FIFO #0 6 - MS0 FIFO #1 7 - MS0 FIFO #2 8 - Reserved    9
///< - TPACK FIFO
#define TEST_MEM_INT_STAT_FIFO_OVERFLOW_ERR_BF_OFF ( 0)
#define TEST_MEM_INT_STAT_FIFO_OVERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_STAT_FIFO_OVERFLOW_ERR_BF_MSK (0x000003FF)
#define TEST_MEM_INT_STAT_FIFO_OVERFLOW_ERR_BF_DEF (0x00000000)

///< Indicates underflow error occured in one the MEM_CAP's internal fifos.
///< Bit i indicates underflow status of FIFOs listed below.  0 - MSI FIFO
///< #0 1 - MSI FIFO #1 2 - MSI FIFO #2 3 - MSI FIFO #3 4 - MSI FIFO #4
///< 5 - MS0 FIFO #0 6 - MS0 FIFO #1 7 - MS0 FIFO #2 8 - Reserved     9
///< - TPACK FIFO
#define TEST_MEM_INT_STAT_FIFO_UNDERFLOW_ERR_BF_OFF (10)
#define TEST_MEM_INT_STAT_FIFO_UNDERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_STAT_FIFO_UNDERFLOW_ERR_BF_MSK (0x000FFC00)
#define TEST_MEM_INT_STAT_FIFO_UNDERFLOW_ERR_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_INT_HIGH_EN register description at address offset 0x184
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/INT_HIGH_EN
  * High Priority Interrupt Enable Register
  */

typedef union {
  struct {
    uint32_t FIFO_OVERFLOW_ERROR : 10;
    ///< High Priority interrupt enable.Bit assigned per table in INT_STATUS
    ///< register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_UNDERFLOW_ERROR : 10;
    ///< High Priority interrupt enable.Bit assigned per table in INT_STATUS
    ///< register.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_int_high_en_reg_t;

#define TEST_MEM_INT_HIGH_EN_DEFAULT (0x00000000U)
#define TEST_MEM_INT_HIGH_EN_RD_MASK (0x000fffffU)
#define TEST_MEM_INT_HIGH_EN_WR_MASK (0x000fffffU)


///< High Priority interrupt enable.Bit assigned per table in INT_STATUS
///< register.
#define TEST_MEM_INT_HIGH_EN_FIFO_OVERFLOW_ERR_BF_OFF ( 0)
#define TEST_MEM_INT_HIGH_EN_FIFO_OVERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_HIGH_EN_FIFO_OVERFLOW_ERR_BF_MSK (0x000003FF)
#define TEST_MEM_INT_HIGH_EN_FIFO_OVERFLOW_ERR_BF_DEF (0x00000000)

///< High Priority interrupt enable.Bit assigned per table in INT_STATUS
///< register.
#define TEST_MEM_INT_HIGH_EN_FIFO_UNDERFLOW_ERR_BF_OFF (10)
#define TEST_MEM_INT_HIGH_EN_FIFO_UNDERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_HIGH_EN_FIFO_UNDERFLOW_ERR_BF_MSK (0x000FFC00)
#define TEST_MEM_INT_HIGH_EN_FIFO_UNDERFLOW_ERR_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_INT_LOW_EN register description at address offset 0x188
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/INT_LOW_EN
  * Low Priority Interrupt Enable Register
  */

typedef union {
  struct {
    uint32_t FIFO_OVERFLOW_ERROR : 10;
    ///< Low Priority interrupt enable. Bits assigned per table in INT_STATUS
    ///< register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_UNDERFLOW_ERROR : 10;
    ///< Low Priority interrupt enable. Bits assigned per table in INT_STATUS
    ///< register.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_int_low_en_reg_t;

#define TEST_MEM_INT_LOW_EN_DEFAULT (0x00000000U)
#define TEST_MEM_INT_LOW_EN_RD_MASK (0x000fffffU)
#define TEST_MEM_INT_LOW_EN_WR_MASK (0x000fffffU)


///< Low Priority interrupt enable. Bits assigned per table in INT_STATUS
///< register.
#define TEST_MEM_INT_LOW_EN_FIFO_OVERFLOW_ERR_BF_OFF ( 0)
#define TEST_MEM_INT_LOW_EN_FIFO_OVERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_LOW_EN_FIFO_OVERFLOW_ERR_BF_MSK (0x000003FF)
#define TEST_MEM_INT_LOW_EN_FIFO_OVERFLOW_ERR_BF_DEF (0x00000000)

///< Low Priority interrupt enable. Bits assigned per table in INT_STATUS
///< register.
#define TEST_MEM_INT_LOW_EN_FIFO_UNDERFLOW_ERR_BF_OFF (10)
#define TEST_MEM_INT_LOW_EN_FIFO_UNDERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_LOW_EN_FIFO_UNDERFLOW_ERR_BF_MSK (0x000FFC00)
#define TEST_MEM_INT_LOW_EN_FIFO_UNDERFLOW_ERR_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_INT_CLEAR register description at address offset 0x18c
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/INT_CLEAR
  * Interrupt Clear Register
  */

typedef union {
  struct {
    uint32_t FIFO_OVERFLOW_ERROR : 10;
    ///< Register error interrupt clear. Bits assigned per table in INT_STATUS
    ///< register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_UNDERFLOW_ERROR : 10;
    ///< Register error interrupt clear. Bits assigned per table in INT_STATUS
    ///< register.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_int_clr_reg_t;

#define TEST_MEM_INT_CLR_DEFAULT (0x00000000U)
#define TEST_MEM_INT_CLR_RD_MASK (0x000fffffU)
#define TEST_MEM_INT_CLR_WR_MASK (0x000fffffU)


///< Register error interrupt clear. Bits assigned per table in INT_STATUS
///< register.
#define TEST_MEM_INT_CLR_FIFO_OVERFLOW_ERR_BF_OFF ( 0)
#define TEST_MEM_INT_CLR_FIFO_OVERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_CLR_FIFO_OVERFLOW_ERR_BF_MSK (0x000003FF)
#define TEST_MEM_INT_CLR_FIFO_OVERFLOW_ERR_BF_DEF (0x00000000)

///< Register error interrupt clear. Bits assigned per table in INT_STATUS
///< register.
#define TEST_MEM_INT_CLR_FIFO_UNDERFLOW_ERR_BF_OFF (10)
#define TEST_MEM_INT_CLR_FIFO_UNDERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_CLR_FIFO_UNDERFLOW_ERR_BF_MSK (0x000FFC00)
#define TEST_MEM_INT_CLR_FIFO_UNDERFLOW_ERR_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_INT_FORCE register description at address offset 0x190
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/INT_FORCE
  * Interrupt Force Register
  */

typedef union {
  struct {
    uint32_t FIFO_OVERFLOW_ERROR : 10;
    ///< Force interrupt error. Bits assigned per table in INT_STATUS register.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_UNDERFLOW_ERROR : 10;
    ///< Force interrupt error. Bits assigned per table in INT_STATUS register.
    ///< AccessType="RW" BitOffset="10" ResetValue="0x0"
    uint32_t  : 12;
    ///< Reserved
    ///< AccessType="RO" BitOffset="20" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_int_force_reg_t;

#define TEST_MEM_INT_FORCE_DEFAULT (0x00000000U)
#define TEST_MEM_INT_FORCE_RD_MASK (0x000fffffU)
#define TEST_MEM_INT_FORCE_WR_MASK (0x000fffffU)


///< Force interrupt error. Bits assigned per table in INT_STATUS register.
#define TEST_MEM_INT_FORCE_FIFO_OVERFLOW_ERR_BF_OFF ( 0)
#define TEST_MEM_INT_FORCE_FIFO_OVERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_FORCE_FIFO_OVERFLOW_ERR_BF_MSK (0x000003FF)
#define TEST_MEM_INT_FORCE_FIFO_OVERFLOW_ERR_BF_DEF (0x00000000)

///< Force interrupt error. Bits assigned per table in INT_STATUS register.
#define TEST_MEM_INT_FORCE_FIFO_UNDERFLOW_ERR_BF_OFF (10)
#define TEST_MEM_INT_FORCE_FIFO_UNDERFLOW_ERR_BF_WID (10)
#define TEST_MEM_INT_FORCE_FIFO_UNDERFLOW_ERR_BF_MSK (0x000FFC00)
#define TEST_MEM_INT_FORCE_FIFO_UNDERFLOW_ERR_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_TTSG_ENABLE[2] register description at address offset 0x1f0
  *
  * Register default value:        0x00008000
  * Register full path in IP: test_map_MEM/test_map/TTSG_ENABLE
  * TTSG Function Enable
  */

typedef union {
  struct {
    uint32_t CORDIC_EN : 1;
    ///< CORDIC Enable
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t SCALE : 16;
    ///< Scale. This will scale the output by the value = scale/2^15. Setting
    ///< scale = 16'h7FFF is equivalent of scaling the N-phase CORDIC's cosine
    ///< or sine output by a factor of 1.0. Setting scale = 16'h4000 is equivalent
    ///< of scaling the N-phase CORDIC's cosine or sine output by a factor
    ///< of 0.5. Setting scale = 16'h2000 is equivalent of scaling the N-phase
    ///< CORDIC's cosine or sine output by a factor of 0.25. When the TTSG
    ///< is operatinng in TTSG_SUM mode, the maximum allowed value of sum of
    ///< scale[0] + scale[1] = 16'h7FFF.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x4000"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_ttsg_en_reg_t;

#define TEST_MEM_TTSG_EN_DEFAULT (0x00008000U)
#define TEST_MEM_TTSG_EN_RD_MASK (0x0001ffffU)
#define TEST_MEM_TTSG_EN_WR_MASK (0x0001ffffU)


///< CORDIC Enable
#define TEST_MEM_TTSG_EN_CORDIC_EN_BF_OFF ( 0)
#define TEST_MEM_TTSG_EN_CORDIC_EN_BF_WID ( 1)
#define TEST_MEM_TTSG_EN_CORDIC_EN_BF_MSK (0x00000001)
#define TEST_MEM_TTSG_EN_CORDIC_EN_BF_DEF (0x00000000)

///< Scale. This will scale the output by the value = scale/2^15. Setting
///< scale = 16'h7FFF is equivalent of scaling the N-phase CORDIC's cosine
///< or sine output by a factor of 1.0. Setting scale = 16'h4000 is equivalent
///< of scaling the N-phase CORDIC's cosine or sine output by a factor
///< of 0.5. Setting scale = 16'h2000 is equivalent of scaling the N-phase
///< CORDIC's cosine or sine output by a factor of 0.25. When the TTSG
///< is operatinng in TTSG_SUM mode, the maximum allowed value of sum of
///< scale[0] + scale[1] = 16'h7FFF.
#define TEST_MEM_TTSG_EN_SCALE_BF_OFF ( 1)
#define TEST_MEM_TTSG_EN_SCALE_BF_WID (16)
#define TEST_MEM_TTSG_EN_SCALE_BF_MSK (0x0001FFFE)
#define TEST_MEM_TTSG_EN_SCALE_BF_DEF (0x00008000)
#define TEST_MEM_TTSG_EN_ARR_SZ0 (2)
#define TEST_MEM_TTSG_EN_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_TTSG_MODE register description at address offset 0x1f8
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TTSG_MODE
  * TTSG Mode
  */

typedef union {
  struct {
    uint32_t MODE : 3;
    ///< Mode.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_ttsg_mode_reg_t;

#define TEST_MEM_TTSG_MODE_DEFAULT (0x00000000U)
#define TEST_MEM_TTSG_MODE_RD_MASK (0x00000007U)
#define TEST_MEM_TTSG_MODE_WR_MASK (0x00000007U)


///< Mode.
#define TEST_MEM_TTSG_MODE_BF_OFF ( 0)
#define TEST_MEM_TTSG_MODE_BF_WID ( 3)
#define TEST_MEM_TTSG_MODE_BF_MSK (0x00000007)
#define TEST_MEM_TTSG_MODE_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_CDAC_CFG register description at address offset 0x1fc
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/CDAC_CFG
  * CDAC Insertion Control Register
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< Enable. When set to 1, this interface will transmit data from the
    ///< TEST module to the Test Module's Insertion Point in the CDAC.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MUX_SEL : 2;
    ///< Mux_sel
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 29;
    ///< Reserved
    ///< AccessType="RO" BitOffset="3" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_cdac_cfg_reg_t;

#define TEST_MEM_CDAC_CFG_DEFAULT (0x00000000U)
#define TEST_MEM_CDAC_CFG_RD_MASK (0x00000007U)
#define TEST_MEM_CDAC_CFG_WR_MASK (0x00000007U)


///< Enable. When set to 1, this interface will transmit data from the
///< TEST module to the Test Module's Insertion Point in the CDAC.
#define TEST_MEM_CDAC_CFG_EN_BF_OFF ( 0)
#define TEST_MEM_CDAC_CFG_EN_BF_WID ( 1)
#define TEST_MEM_CDAC_CFG_EN_BF_MSK (0x00000001)
#define TEST_MEM_CDAC_CFG_EN_BF_DEF (0x00000000)

///< Mux_sel
#define TEST_MEM_CDAC_CFG_MUX_SEL_BF_OFF ( 1)
#define TEST_MEM_CDAC_CFG_MUX_SEL_BF_WID ( 2)
#define TEST_MEM_CDAC_CFG_MUX_SEL_BF_MSK (0x00000006)
#define TEST_MEM_CDAC_CFG_MUX_SEL_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_TTSG_CORDIC_INIT_UPPER[32] register description at address offset 0x200
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TTSG_CORDIC_INIT_UPPER
  * CORDIC Initial Upper
  */

typedef union {
  struct {
    uint32_t INIT_VAL : 6;
    ///< CORDIC Init Val Upper
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_ttsg_cordic_init_upper_reg_t;

#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_DEFAULT (0x00000000U)
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_RD_MASK (0x0000003fU)
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_WR_MASK (0x0000003fU)


///< CORDIC Init Val Upper
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_INIT_VAL_BF_OFF ( 0)
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_INIT_VAL_BF_WID ( 6)
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_INIT_VAL_BF_MSK (0x0000003F)
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_INIT_VAL_BF_DEF (0x00000000)
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_ARR_SZ0 (32)
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_TTSG_CORDIC_INIT_LOWER[32] register description at address offset 0x280
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TTSG_CORDIC_INIT_LOWER
  * CORDIC Initial Lower
  */

typedef union {
  struct {
    uint32_t INIT_VAL : 32;
    ///< CORDIC Init Val Lower
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_ttsg_cordic_init_lower_reg_t;

#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_DEFAULT (0x00000000U)
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_RD_MASK (0xffffffffU)
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_WR_MASK (0xffffffffU)


///< CORDIC Init Val Lower
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_INIT_VAL_BF_OFF ( 0)
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_INIT_VAL_BF_WID (32)
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_INIT_VAL_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_INIT_VAL_BF_DEF (0x00000000)
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_ARR_SZ0 (32)
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_TTSG_CORDIC_INCR_UPPER[2] register description at address offset 0x300
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TTSG_CORDIC_INCR_UPPER
  * CORDIC Incr Upper
  */

typedef union {
  struct {
    uint32_t INCR_VAL : 6;
    ///< CORDIC Incr Val Upper
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_ttsg_cordic_incr_upper_reg_t;

#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_DEFAULT (0x00000000U)
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_RD_MASK (0x0000003fU)
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_WR_MASK (0x0000003fU)


///< CORDIC Incr Val Upper
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_INCR_VAL_BF_OFF ( 0)
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_INCR_VAL_BF_WID ( 6)
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_INCR_VAL_BF_MSK (0x0000003F)
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_INCR_VAL_BF_DEF (0x00000000)
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_ARR_SZ0 (2)
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_TTSG_CORDIC_INCR_LOWER[2] register description at address offset 0x308
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TTSG_CORDIC_INCR_LOWER
  * CORDIC Incr Lower
  */

typedef union {
  struct {
    uint32_t INCR_VAL : 32;
    ///< CORDIC Incr Val Lower
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_ttsg_cordic_incr_lower_reg_t;

#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_DEFAULT (0x00000000U)
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_RD_MASK (0xffffffffU)
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_WR_MASK (0xffffffffU)


///< CORDIC Incr Val Lower
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_INCR_VAL_BF_OFF ( 0)
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_INCR_VAL_BF_WID (32)
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_INCR_VAL_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_INCR_VAL_BF_DEF (0x00000000)
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_ARR_SZ0 (2)
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_TTSG_CORDIC_INCR1_UPPER[2] register description at address offset 0x310
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TTSG_CORDIC_INCR1_UPPER
  * CORDIC Incr Upper
  */

typedef union {
  struct {
    uint32_t INCR_VAL : 6;
    ///< CORDIC Incr Val Upper
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 26;
    ///< Reserved
    ///< AccessType="RO" BitOffset="6" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_ttsg_cordic_incr1_upper_reg_t;

#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_DEFAULT (0x00000000U)
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_RD_MASK (0x0000003fU)
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_WR_MASK (0x0000003fU)


///< CORDIC Incr Val Upper
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_INCR_VAL_BF_OFF ( 0)
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_INCR_VAL_BF_WID ( 6)
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_INCR_VAL_BF_MSK (0x0000003F)
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_INCR_VAL_BF_DEF (0x00000000)
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_ARR_SZ0 (2)
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_TTSG_CORDIC_INCR1_LOWER[2] register description at address offset 0x318
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TTSG_CORDIC_INCR1_LOWER
  * CORDIC Incr Lower
  */

typedef union {
  struct {
    uint32_t INCR_VAL : 32;
    ///< CORDIC Incr Val Lower
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_ttsg_cordic_incr1_lower_reg_t;

#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_DEFAULT (0x00000000U)
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_RD_MASK (0xffffffffU)
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_WR_MASK (0xffffffffU)


///< CORDIC Incr Val Lower
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_INCR_VAL_BF_OFF ( 0)
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_INCR_VAL_BF_WID (32)
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_INCR_VAL_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_INCR_VAL_BF_DEF (0x00000000)
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_ARR_SZ0 (2)
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_MSI_FIFO_WM[5] register description at address offset 0x320
  *
  * Register default value:        0x00000180
  * Register full path in IP: test_map_MEM/test_map/MSI_FIFO_WM
  * 16-Entry Clock Crossing FIFO Watermarks Register
  */

typedef union {
  struct {
    uint32_t LOW_WM : 5;
    ///< FIFO Low Watermark
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t HIGH_WM : 5;
    ///< FIFO High Watermark
    ///< AccessType="RW" BitOffset="5" ResetValue="0xC"
    uint32_t  : 22;
    ///< Reserved
    ///< AccessType="RO" BitOffset="10" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_msi_fifo_wm_reg_t;

#define TEST_MEM_MSI_FIFO_WM_DEFAULT (0x00000180U)
#define TEST_MEM_MSI_FIFO_WM_RD_MASK (0x000003ffU)
#define TEST_MEM_MSI_FIFO_WM_WR_MASK (0x000003ffU)


///< FIFO Low Watermark
#define TEST_MEM_MSI_FIFO_WM_LOW_WM_BF_OFF ( 0)
#define TEST_MEM_MSI_FIFO_WM_LOW_WM_BF_WID ( 5)
#define TEST_MEM_MSI_FIFO_WM_LOW_WM_BF_MSK (0x0000001F)
#define TEST_MEM_MSI_FIFO_WM_LOW_WM_BF_DEF (0x00000000)

///< FIFO High Watermark
#define TEST_MEM_MSI_FIFO_WM_HIGH_WM_BF_OFF ( 5)
#define TEST_MEM_MSI_FIFO_WM_HIGH_WM_BF_WID ( 5)
#define TEST_MEM_MSI_FIFO_WM_HIGH_WM_BF_MSK (0x000003E0)
#define TEST_MEM_MSI_FIFO_WM_HIGH_WM_BF_DEF (0x00000180)
#define TEST_MEM_MSI_FIFO_WM_ARR_SZ0 (5)
#define TEST_MEM_MSI_FIFO_WM_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_MSI_FIFO_STAT[5] register description at address offset 0x340
  *
  * Register default value:        0x0000000C
  * Register full path in IP: test_map_MEM/test_map/MSI_FIFO_STAT
  * 16-Entry Clock Crossing FIFO Status Register
  */

typedef union {
  struct {
    uint32_t FIFO_UNDERFLOW : 1;
    ///< FIFO Underflow
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t FIFO_OVERFLOW : 1;
    ///< FIFO Overflow
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t EMPTY : 1;
    ///< FIFO Empty
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t ALMOST_EMPTY : 1;
    ///< FIFO Almost Empty
    ///< AccessType="RO/V" BitOffset="3" ResetValue="0x1"
    uint32_t ALMOST_FULL : 1;
    ///< FIFO Almost Full
    ///< AccessType="RO/V" BitOffset="4" ResetValue="0x0"
    uint32_t FULL : 1;
    ///< FIFO Full
    ///< AccessType="RO/V" BitOffset="5" ResetValue="0x0"
    uint32_t DEPTH : 5;
    ///< FIFO Depth
    ///< AccessType="RO/V" BitOffset="6" ResetValue="0x0"
    uint32_t  : 21;
    ///< Reserved
    ///< AccessType="RO" BitOffset="11" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_msi_fifo_stat_reg_t;

#define TEST_MEM_MSI_FIFO_STAT_DEFAULT (0x0000000cU)
#define TEST_MEM_MSI_FIFO_STAT_RD_MASK (0x000007ffU)
#define TEST_MEM_MSI_FIFO_STAT_WR_MASK (0x00000000U)


///< FIFO Underflow
#define TEST_MEM_MSI_FIFO_STAT_UNDERFLOW_BF_OFF ( 0)
#define TEST_MEM_MSI_FIFO_STAT_UNDERFLOW_BF_WID ( 1)
#define TEST_MEM_MSI_FIFO_STAT_UNDERFLOW_BF_MSK (0x00000001)
#define TEST_MEM_MSI_FIFO_STAT_UNDERFLOW_BF_DEF (0x00000000)

///< FIFO Overflow
#define TEST_MEM_MSI_FIFO_STAT_OVERFLOW_BF_OFF ( 1)
#define TEST_MEM_MSI_FIFO_STAT_OVERFLOW_BF_WID ( 1)
#define TEST_MEM_MSI_FIFO_STAT_OVERFLOW_BF_MSK (0x00000002)
#define TEST_MEM_MSI_FIFO_STAT_OVERFLOW_BF_DEF (0x00000000)

///< FIFO Empty
#define TEST_MEM_MSI_FIFO_STAT_EMPTY_BF_OFF ( 2)
#define TEST_MEM_MSI_FIFO_STAT_EMPTY_BF_WID ( 1)
#define TEST_MEM_MSI_FIFO_STAT_EMPTY_BF_MSK (0x00000004)
#define TEST_MEM_MSI_FIFO_STAT_EMPTY_BF_DEF (0x00000004)

///< FIFO Almost Empty
#define TEST_MEM_MSI_FIFO_STAT_ALMOST_EMPTY_BF_OFF ( 3)
#define TEST_MEM_MSI_FIFO_STAT_ALMOST_EMPTY_BF_WID ( 1)
#define TEST_MEM_MSI_FIFO_STAT_ALMOST_EMPTY_BF_MSK (0x00000008)
#define TEST_MEM_MSI_FIFO_STAT_ALMOST_EMPTY_BF_DEF (0x00000008)

///< FIFO Almost Full
#define TEST_MEM_MSI_FIFO_STAT_ALMOST_FULL_BF_OFF ( 4)
#define TEST_MEM_MSI_FIFO_STAT_ALMOST_FULL_BF_WID ( 1)
#define TEST_MEM_MSI_FIFO_STAT_ALMOST_FULL_BF_MSK (0x00000010)
#define TEST_MEM_MSI_FIFO_STAT_ALMOST_FULL_BF_DEF (0x00000000)

///< FIFO Full
#define TEST_MEM_MSI_FIFO_STAT_FULL_BF_OFF ( 5)
#define TEST_MEM_MSI_FIFO_STAT_FULL_BF_WID ( 1)
#define TEST_MEM_MSI_FIFO_STAT_FULL_BF_MSK (0x00000020)
#define TEST_MEM_MSI_FIFO_STAT_FULL_BF_DEF (0x00000000)

///< FIFO Depth
#define TEST_MEM_MSI_FIFO_STAT_DEPTH_BF_OFF ( 6)
#define TEST_MEM_MSI_FIFO_STAT_DEPTH_BF_WID ( 5)
#define TEST_MEM_MSI_FIFO_STAT_DEPTH_BF_MSK (0x000007C0)
#define TEST_MEM_MSI_FIFO_STAT_DEPTH_BF_DEF (0x00000000)
#define TEST_MEM_MSI_FIFO_STAT_ARR_SZ0 (5)
#define TEST_MEM_MSI_FIFO_STAT_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_ERROR_PHASE register description at address offset 0x360
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/ERROR_PHASE
  * BIST ADC Phase Error Register
  */

typedef union {
  struct {
    uint32_t ERROR_PHASE : 32;
    ///< Sum of the phase error of 16 samples
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_err_phase_reg_t;

#define TEST_MEM_ERR_PHASE_DEFAULT (0x00000000U)
#define TEST_MEM_ERR_PHASE_RD_MASK (0xffffffffU)
#define TEST_MEM_ERR_PHASE_WR_MASK (0x00000000U)


///< Sum of the phase error of 16 samples
#define TEST_MEM_ERR_PHASE_ERR_PHASE_BF_OFF ( 0)
#define TEST_MEM_ERR_PHASE_ERR_PHASE_BF_WID (32)
#define TEST_MEM_ERR_PHASE_ERR_PHASE_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_ERR_PHASE_ERR_PHASE_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_ERROR_AMPL register description at address offset 0x364
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/ERROR_AMPL
  * BIST ADC Amplitude Error Register
  */

typedef union {
  struct {
    uint32_t ERROR_AMPL : 32;
    ///< Sum of the amplitude error of 16 samples
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_err_ampl_reg_t;

#define TEST_MEM_ERR_AMPL_DEFAULT (0x00000000U)
#define TEST_MEM_ERR_AMPL_RD_MASK (0xffffffffU)
#define TEST_MEM_ERR_AMPL_WR_MASK (0x00000000U)


///< Sum of the amplitude error of 16 samples
#define TEST_MEM_ERR_AMPL_ERR_AMPL_BF_OFF ( 0)
#define TEST_MEM_ERR_AMPL_ERR_AMPL_BF_WID (32)
#define TEST_MEM_ERR_AMPL_ERR_AMPL_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_ERR_AMPL_ERR_AMPL_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_TEST_TX_CFG register description at address offset 0x368
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/TEST_TX_CFG
  * TEST TX Insertion Control Register
  */

typedef union {
  struct {
    uint32_t EN : 1;
    ///< Enable. When set to 1, this interface will transmit data from the
    ///< TTSG module to the insertion point at the beginning of the TX digital
    ///< filter chain.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t MUX_SEL : 1;
    ///< Mux_sel
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t  : 30;
    ///< Reserved
    ///< AccessType="RO" BitOffset="2" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_test_tx_cfg_reg_t;

#define TEST_MEM_TEST_TX_CFG_DEFAULT (0x00000000U)
#define TEST_MEM_TEST_TX_CFG_RD_MASK (0x00000003U)
#define TEST_MEM_TEST_TX_CFG_WR_MASK (0x00000003U)


///< Enable. When set to 1, this interface will transmit data from the
///< TTSG module to the insertion point at the beginning of the TX digital
///< filter chain.
#define TEST_MEM_TEST_TX_CFG_EN_BF_OFF ( 0)
#define TEST_MEM_TEST_TX_CFG_EN_BF_WID ( 1)
#define TEST_MEM_TEST_TX_CFG_EN_BF_MSK (0x00000001)
#define TEST_MEM_TEST_TX_CFG_EN_BF_DEF (0x00000000)

///< Mux_sel
#define TEST_MEM_TEST_TX_CFG_MUX_SEL_BF_OFF ( 1)
#define TEST_MEM_TEST_TX_CFG_MUX_SEL_BF_WID ( 1)
#define TEST_MEM_TEST_TX_CFG_MUX_SEL_BF_MSK (0x00000002)
#define TEST_MEM_TEST_TX_CFG_MUX_SEL_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_DUAL_FCW_CONFIG[2] register description at address offset 0x380
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/DUAL_FCW_CONFIG
  * Dual FCW CONFIG register.
  */

typedef union {
  struct {
    uint32_t DUAL_FCW_ENABLE : 1;
    ///< When set to 0, the SWG only used FCW0 (frequency control word 0, or
    ///< incr) when generating its output. When setto 1, the SWG is configured
    ///< to use 2 FCW (frequency control word, also referred to as incr) to
    ///< control the frequency of the SWG output. In this mode of operation,
    ///< FCW0 (incr) is used for M clock cycles and FCW1 (incr1) is used for
    ///< N clock cycles every M+N clock cycles. Hence, the SWG uses the following
    ///< control word sequence: FCW0, FCW1, FCW0, FCW1, ....
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t COUNT0 : 8;
    ///< When dual_fcw_enable = 1, the SWG will use FCW0 for   Count0+1  clock
    ///< cycles prior to switching to FCW1.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t COUNT1 : 8;
    ///< When dual_fcw_enable = 1, the SWG will use FCW1 for   Count1+1  clock
    ///< cycles prior to switching to FCW0.
    ///< AccessType="RW" BitOffset="9" ResetValue="0x0"
    uint32_t  : 15;
    ///< Reserved
    ///< AccessType="RO" BitOffset="17" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_dual_fcw_cfg_reg_t;

#define TEST_MEM_DUAL_FCW_CFG_DEFAULT (0x00000000U)
#define TEST_MEM_DUAL_FCW_CFG_RD_MASK (0x0001ffffU)
#define TEST_MEM_DUAL_FCW_CFG_WR_MASK (0x0001ffffU)


///< When set to 0, the SWG only used FCW0 (frequency control word 0, or
///< incr) when generating its output. When setto 1, the SWG is configured
///< to use 2 FCW (frequency control word, also referred to as incr) to
///< control the frequency of the SWG output. In this mode of operation,
///< FCW0 (incr) is used for M clock cycles and FCW1 (incr1) is used for
///< N clock cycles every M+N clock cycles. Hence, the SWG uses the following
///< control word sequence: FCW0, FCW1, FCW0, FCW1, ....
#define TEST_MEM_DUAL_FCW_CFG_DUAL_FCW_EN_BF_OFF ( 0)
#define TEST_MEM_DUAL_FCW_CFG_DUAL_FCW_EN_BF_WID ( 1)
#define TEST_MEM_DUAL_FCW_CFG_DUAL_FCW_EN_BF_MSK (0x00000001)
#define TEST_MEM_DUAL_FCW_CFG_DUAL_FCW_EN_BF_DEF (0x00000000)

///< When dual_fcw_enable = 1, the SWG will use FCW0 for   Count0+1  clock
///< cycles prior to switching to FCW1.
#define TEST_MEM_DUAL_FCW_CFG_CNT0_BF_OFF ( 1)
#define TEST_MEM_DUAL_FCW_CFG_CNT0_BF_WID ( 8)
#define TEST_MEM_DUAL_FCW_CFG_CNT0_BF_MSK (0x000001FE)
#define TEST_MEM_DUAL_FCW_CFG_CNT0_BF_DEF (0x00000000)

///< When dual_fcw_enable = 1, the SWG will use FCW1 for   Count1+1  clock
///< cycles prior to switching to FCW0.
#define TEST_MEM_DUAL_FCW_CFG_CNT1_BF_OFF ( 9)
#define TEST_MEM_DUAL_FCW_CFG_CNT1_BF_WID ( 8)
#define TEST_MEM_DUAL_FCW_CFG_CNT1_BF_MSK (0x0001FE00)
#define TEST_MEM_DUAL_FCW_CFG_CNT1_BF_DEF (0x00000000)
#define TEST_MEM_DUAL_FCW_CFG_ARR_SZ0 (2)
#define TEST_MEM_DUAL_FCW_CFG_ARRAY_STRIDE0 (0x0004)


/** @brief TEST_MAP_MEM_TEST_MAP_APB_BRIDGE_STATUS register description at address offset 0x3fc
  *
  * Register default value:        0x00010000
  * Register full path in IP: test_map_MEM/test_map/APB_BRIDGE_STATUS
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_apb_brdg_stat_reg_t;

#define TEST_MEM_APB_BRDG_STAT_DEFAULT (0x00010000U)
#define TEST_MEM_APB_BRDG_STAT_RD_MASK (0xffffffffU)
#define TEST_MEM_APB_BRDG_STAT_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define TEST_MEM_APB_BRDG_STAT_TIMEOUT_VAL_BF_OFF ( 0)
#define TEST_MEM_APB_BRDG_STAT_TIMEOUT_VAL_BF_WID (20)
#define TEST_MEM_APB_BRDG_STAT_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define TEST_MEM_APB_BRDG_STAT_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define TEST_MEM_APB_BRDG_STAT_REVISION_BF_OFF (20)
#define TEST_MEM_APB_BRDG_STAT_REVISION_BF_WID ( 8)
#define TEST_MEM_APB_BRDG_STAT_REVISION_BF_MSK (0x0FF00000)
#define TEST_MEM_APB_BRDG_STAT_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define TEST_MEM_APB_BRDG_STAT_SW_LOCK_CTRL_BF_OFF (28)
#define TEST_MEM_APB_BRDG_STAT_SW_LOCK_CTRL_BF_WID ( 1)
#define TEST_MEM_APB_BRDG_STAT_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define TEST_MEM_APB_BRDG_STAT_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define TEST_MEM_APB_BRDG_STAT_UNSOL_ACK_BF_OFF (29)
#define TEST_MEM_APB_BRDG_STAT_UNSOL_ACK_BF_WID ( 1)
#define TEST_MEM_APB_BRDG_STAT_UNSOL_ACK_BF_MSK (0x20000000)
#define TEST_MEM_APB_BRDG_STAT_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define TEST_MEM_APB_BRDG_STAT_ACK_ERR_BF_OFF (30)
#define TEST_MEM_APB_BRDG_STAT_ACK_ERR_BF_WID ( 1)
#define TEST_MEM_APB_BRDG_STAT_ACK_ERR_BF_MSK (0x40000000)
#define TEST_MEM_APB_BRDG_STAT_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define TEST_MEM_APB_BRDG_STAT_TIMEOUT_BF_OFF (31)
#define TEST_MEM_APB_BRDG_STAT_TIMEOUT_BF_WID ( 1)
#define TEST_MEM_APB_BRDG_STAT_TIMEOUT_BF_MSK (0x80000000)
#define TEST_MEM_APB_BRDG_STAT_TIMEOUT_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_PLL_FUNCTION register description at address offset 0x460
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/PLL_FUNCTION
  * TEST PLL Function
  */

typedef union {
  struct {
    uint32_t ENABLE : 1;
    ///< Enable. When set to 1, the PLL Counter is enabled. PLL Counter stops
    ///< counting after running for TEST_LENGTH clk_ref cycles
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t RESET : 1;
    ///< Reset. When set to 1, the PLL Counter register is reset to 0.
    ///< AccessType="RW" BitOffset="1" ResetValue="0x0"
    uint32_t TEST_LENGTH : 16;
    ///< Test Length. Length of test in clk_ref clock cycles.
    ///< AccessType="RW" BitOffset="2" ResetValue="0x0"
    uint32_t  : 14;
    ///< Reserved
    ///< AccessType="RO" BitOffset="18" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_pll_function_reg_t;

#define TEST_MEM_PLL_FUNCTION_DEFAULT (0x00000000U)
#define TEST_MEM_PLL_FUNCTION_RD_MASK (0x0003ffffU)
#define TEST_MEM_PLL_FUNCTION_WR_MASK (0x0003ffffU)


///< Enable. When set to 1, the PLL Counter is enabled. PLL Counter stops
///< counting after running for TEST_LENGTH clk_ref cycles
#define TEST_MEM_PLL_FUNCTION_EN_BF_OFF ( 0)
#define TEST_MEM_PLL_FUNCTION_EN_BF_WID ( 1)
#define TEST_MEM_PLL_FUNCTION_EN_BF_MSK (0x00000001)
#define TEST_MEM_PLL_FUNCTION_EN_BF_DEF (0x00000000)

///< Reset. When set to 1, the PLL Counter register is reset to 0.
#define TEST_MEM_PLL_FUNCTION_RST_BF_OFF ( 1)
#define TEST_MEM_PLL_FUNCTION_RST_BF_WID ( 1)
#define TEST_MEM_PLL_FUNCTION_RST_BF_MSK (0x00000002)
#define TEST_MEM_PLL_FUNCTION_RST_BF_DEF (0x00000000)

///< Test Length. Length of test in clk_ref clock cycles.
#define TEST_MEM_PLL_FUNCTION_TEST_LENGTH_BF_OFF ( 2)
#define TEST_MEM_PLL_FUNCTION_TEST_LENGTH_BF_WID (16)
#define TEST_MEM_PLL_FUNCTION_TEST_LENGTH_BF_MSK (0x0003FFFC)
#define TEST_MEM_PLL_FUNCTION_TEST_LENGTH_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_PLL_STATUS register description at address offset 0x464
  *
  * Register default value:        0x00000004
  * Register full path in IP: test_map_MEM/test_map/PLL_STATUS
  * TEST PLL Status Register
  */

typedef union {
  struct {
    uint32_t DONE : 1;
    ///< Done. When set to 1, the PLL Count Test is complete and the state
    ///< of the PASS bit is valid.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
    uint32_t PASS : 1;
    ///< Pass. This bit should only be read when Done = 1. When this bit is
    ///< set to 1, the test Passed. Otherwise the test failed.
    ///< AccessType="RO/V" BitOffset="1" ResetValue="0x0"
    uint32_t STATE : 5;
    ///< State. Returns the state of the PLL TEST internal state machine.
    ///< AccessType="RO/V" BitOffset="2" ResetValue="0x1"
    uint32_t  : 25;
    ///< Reserved
    ///< AccessType="RO" BitOffset="7" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_pll_stat_reg_t;

#define TEST_MEM_PLL_STAT_DEFAULT (0x00000004U)
#define TEST_MEM_PLL_STAT_RD_MASK (0x0000007fU)
#define TEST_MEM_PLL_STAT_WR_MASK (0x00000000U)


///< Done. When set to 1, the PLL Count Test is complete and the state
///< of the PASS bit is valid.
#define TEST_MEM_PLL_STAT_DONE_BF_OFF ( 0)
#define TEST_MEM_PLL_STAT_DONE_BF_WID ( 1)
#define TEST_MEM_PLL_STAT_DONE_BF_MSK (0x00000001)
#define TEST_MEM_PLL_STAT_DONE_BF_DEF (0x00000000)

///< Pass. This bit should only be read when Done = 1. When this bit is
///< set to 1, the test Passed. Otherwise the test failed.
#define TEST_MEM_PLL_STAT_PASS_BF_OFF ( 1)
#define TEST_MEM_PLL_STAT_PASS_BF_WID ( 1)
#define TEST_MEM_PLL_STAT_PASS_BF_MSK (0x00000002)
#define TEST_MEM_PLL_STAT_PASS_BF_DEF (0x00000000)

///< State. Returns the state of the PLL TEST internal state machine.
#define TEST_MEM_PLL_STAT_STATE_BF_OFF ( 2)
#define TEST_MEM_PLL_STAT_STATE_BF_WID ( 5)
#define TEST_MEM_PLL_STAT_STATE_BF_MSK (0x0000007C)
#define TEST_MEM_PLL_STAT_STATE_BF_DEF (0x00000004)


/** @brief TEST_MAP_MEM_TEST_MAP_PLL_COUNTER register description at address offset 0x468
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/PLL_COUNTER
  * TEST PLL Counter
  */

typedef union {
  struct {
    uint32_t PLL_COUNTER : 32;
    ///< PLL Counter. Returns the value contained in PLL Counter.
    ///< AccessType="RO/V" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_pll_cnter_reg_t;

#define TEST_MEM_PLL_CNTER_DEFAULT (0x00000000U)
#define TEST_MEM_PLL_CNTER_RD_MASK (0xffffffffU)
#define TEST_MEM_PLL_CNTER_WR_MASK (0x00000000U)


///< PLL Counter. Returns the value contained in PLL Counter.
#define TEST_MEM_PLL_CNTER_PLL_CNTER_BF_OFF ( 0)
#define TEST_MEM_PLL_CNTER_PLL_CNTER_BF_WID (32)
#define TEST_MEM_PLL_CNTER_PLL_CNTER_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_PLL_CNTER_PLL_CNTER_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_PLL_WAIT_COUNT register description at address offset 0x46c
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/PLL_WAIT_COUNT
  * TEST PLL Wait Count
  */

typedef union {
  struct {
    uint32_t PLL_WAIT_COUNT : 4;
    ///< PLL Wait Counter.
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
    uint32_t  : 28;
    ///< Reserved
    ///< AccessType="RO" BitOffset="4" ResetValue="None"
  } ;
  uint32_t value;
} test_mem_pll_wait_cnt_reg_t;

#define TEST_MEM_PLL_WAIT_CNT_DEFAULT (0x00000000U)
#define TEST_MEM_PLL_WAIT_CNT_RD_MASK (0x0000000fU)
#define TEST_MEM_PLL_WAIT_CNT_WR_MASK (0x0000000fU)


///< PLL Wait Counter.
#define TEST_MEM_PLL_WAIT_CNT_PLL_WAIT_CNT_BF_OFF ( 0)
#define TEST_MEM_PLL_WAIT_CNT_PLL_WAIT_CNT_BF_WID ( 4)
#define TEST_MEM_PLL_WAIT_CNT_PLL_WAIT_CNT_BF_MSK (0x0000000F)
#define TEST_MEM_PLL_WAIT_CNT_PLL_WAIT_CNT_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_PLL_COUNT_HIGH register description at address offset 0x470
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/PLL_COUNT_HIGH
  * TEST PLL Count High Register
  */

typedef union {
  struct {
    uint32_t COUNT_HIGH : 32;
    ///< Memory error interrupt force
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_pll_cnt_high_reg_t;

#define TEST_MEM_PLL_CNT_HIGH_DEFAULT (0x00000000U)
#define TEST_MEM_PLL_CNT_HIGH_RD_MASK (0xffffffffU)
#define TEST_MEM_PLL_CNT_HIGH_WR_MASK (0xffffffffU)


///< Memory error interrupt force
#define TEST_MEM_PLL_CNT_HIGH_CNT_HIGH_BF_OFF ( 0)
#define TEST_MEM_PLL_CNT_HIGH_CNT_HIGH_BF_WID (32)
#define TEST_MEM_PLL_CNT_HIGH_CNT_HIGH_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_PLL_CNT_HIGH_CNT_HIGH_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_PLL_COUNT_LOW register description at address offset 0x474
  *
  * Register default value:        0x00000000
  * Register full path in IP: test_map_MEM/test_map/PLL_COUNT_LOW
  * TEST PLL Count Low Register
  */

typedef union {
  struct {
    uint32_t COUNT_LOW : 32;
    ///< Memory error interrupt force
    ///< AccessType="RW" BitOffset="0" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_pll_cnt_low_reg_t;

#define TEST_MEM_PLL_CNT_LOW_DEFAULT (0x00000000U)
#define TEST_MEM_PLL_CNT_LOW_RD_MASK (0xffffffffU)
#define TEST_MEM_PLL_CNT_LOW_WR_MASK (0xffffffffU)


///< Memory error interrupt force
#define TEST_MEM_PLL_CNT_LOW_CNT_LOW_BF_OFF ( 0)
#define TEST_MEM_PLL_CNT_LOW_CNT_LOW_BF_WID (32)
#define TEST_MEM_PLL_CNT_LOW_CNT_LOW_BF_MSK (0xFFFFFFFF)
#define TEST_MEM_PLL_CNT_LOW_CNT_LOW_BF_DEF (0x00000000)


/** @brief TEST_MAP_MEM_TEST_MAP_APB_BRIDGE_STATUS_PLL register description at address offset 0x7fc
  *
  * Register default value:        0x00010000
  * Register full path in IP: test_map_MEM/test_map/APB_BRIDGE_STATUS_PLL
  * APB Bridge Status Register
  */

typedef union {
  struct {
    uint32_t TIMEOUT_VALUE : 20;
    ///< Number of core clocks to wait before timing out an APB request
    ///< AccessType="RW" BitOffset="0" ResetValue="0x10000"
    uint32_t REVISION : 8;
    ///< Module Revision Number
    ///< AccessType="RO/V" BitOffset="20" ResetValue="0x0"
    uint32_t SW_LOCK_CTRL : 1;
    ///< Block software writes to timeout_value if set
    ///< AccessType="RW" BitOffset="28" ResetValue="0x0"
    uint32_t UNSOL_ACK : 1;
    ///< An unsolicited acknowledge was received
    ///< AccessType="RW" BitOffset="29" ResetValue="0x0"
    uint32_t ACK_ERROR : 1;
    ///< Acknowledgement had error bit set
    ///< AccessType="RW" BitOffset="30" ResetValue="0x0"
    uint32_t TIMEOUT : 1;
    ///< An APB request has timed out
    ///< AccessType="RW" BitOffset="31" ResetValue="0x0"
  } ;
  uint32_t value;
} test_mem_apb_brdg_stat_pll_reg_t;

#define TEST_MEM_APB_BRDG_STAT_PLL_DEFAULT (0x00010000U)
#define TEST_MEM_APB_BRDG_STAT_PLL_RD_MASK (0xffffffffU)
#define TEST_MEM_APB_BRDG_STAT_PLL_WR_MASK (0xf00fffffU)


///< Number of core clocks to wait before timing out an APB request
#define TEST_MEM_APB_BRDG_STAT_PLL_TIMEOUT_VAL_BF_OFF ( 0)
#define TEST_MEM_APB_BRDG_STAT_PLL_TIMEOUT_VAL_BF_WID (20)
#define TEST_MEM_APB_BRDG_STAT_PLL_TIMEOUT_VAL_BF_MSK (0x000FFFFF)
#define TEST_MEM_APB_BRDG_STAT_PLL_TIMEOUT_VAL_BF_DEF (0x00010000)

///< Module Revision Number
#define TEST_MEM_APB_BRDG_STAT_PLL_REVISION_BF_OFF (20)
#define TEST_MEM_APB_BRDG_STAT_PLL_REVISION_BF_WID ( 8)
#define TEST_MEM_APB_BRDG_STAT_PLL_REVISION_BF_MSK (0x0FF00000)
#define TEST_MEM_APB_BRDG_STAT_PLL_REVISION_BF_DEF (0x00000000)

///< Block software writes to timeout_value if set
#define TEST_MEM_APB_BRDG_STAT_PLL_SW_LOCK_CTRL_BF_OFF (28)
#define TEST_MEM_APB_BRDG_STAT_PLL_SW_LOCK_CTRL_BF_WID ( 1)
#define TEST_MEM_APB_BRDG_STAT_PLL_SW_LOCK_CTRL_BF_MSK (0x10000000)
#define TEST_MEM_APB_BRDG_STAT_PLL_SW_LOCK_CTRL_BF_DEF (0x00000000)

///< An unsolicited acknowledge was received
#define TEST_MEM_APB_BRDG_STAT_PLL_UNSOL_ACK_BF_OFF (29)
#define TEST_MEM_APB_BRDG_STAT_PLL_UNSOL_ACK_BF_WID ( 1)
#define TEST_MEM_APB_BRDG_STAT_PLL_UNSOL_ACK_BF_MSK (0x20000000)
#define TEST_MEM_APB_BRDG_STAT_PLL_UNSOL_ACK_BF_DEF (0x00000000)

///< Acknowledgement had error bit set
#define TEST_MEM_APB_BRDG_STAT_PLL_ACK_ERR_BF_OFF (30)
#define TEST_MEM_APB_BRDG_STAT_PLL_ACK_ERR_BF_WID ( 1)
#define TEST_MEM_APB_BRDG_STAT_PLL_ACK_ERR_BF_MSK (0x40000000)
#define TEST_MEM_APB_BRDG_STAT_PLL_ACK_ERR_BF_DEF (0x00000000)

///< An APB request has timed out
#define TEST_MEM_APB_BRDG_STAT_PLL_TIMEOUT_BF_OFF (31)
#define TEST_MEM_APB_BRDG_STAT_PLL_TIMEOUT_BF_WID ( 1)
#define TEST_MEM_APB_BRDG_STAT_PLL_TIMEOUT_BF_MSK (0x80000000)
#define TEST_MEM_APB_BRDG_STAT_PLL_TIMEOUT_BF_DEF (0x00000000)

//************************************************ /RegisterStructs


// ******************************************* Register pointer macros

#define TEST_MEM_SCRATCH_REG(_BASE) ((test_mem_scratch_reg_t*) TEST_MEM_SCRATCH_ADR(_BASE))
#define TEST_MEM_MSI_ACTIVE_REG(_BASE) ((test_mem_msi_active_reg_t*) TEST_MEM_MSI_ACTIVE_ADR(_BASE))
#define TEST_MEM_RD_EN_REG(_BASE) ((test_mem_rd_en_reg_t*) TEST_MEM_RD_EN_ADR(_BASE))
#define TEST_MEM_WR_EN_REG(_BASE) ((test_mem_wr_en_reg_t*) TEST_MEM_WR_EN_ADR(_BASE))
#define TEST_MEM_RXBAR_SEL0_REG(_BASE) ((test_mem_rxbar_sel_reg_t*) TEST_MEM_RXBAR_SEL0_ADR(_BASE))
#define TEST_MEM_RXBAR_SEL1_REG(_BASE) ((test_mem_rxbar_sel_reg_t*) TEST_MEM_RXBAR_SEL1_ADR(_BASE))
#define TEST_MEM_RXBAR_SEL2_REG(_BASE) ((test_mem_rxbar_sel_reg_t*) TEST_MEM_RXBAR_SEL2_ADR(_BASE))
#define TEST_MEM_RXBAR_SEL3_REG(_BASE) ((test_mem_rxbar_sel_reg_t*) TEST_MEM_RXBAR_SEL3_ADR(_BASE))
#define TEST_MEM_RXBAR_SEL4_REG(_BASE) ((test_mem_rxbar_sel_reg_t*) TEST_MEM_RXBAR_SEL4_ADR(_BASE))
#define TEST_MEM_MSO_FIFO_WM0_REG(_BASE) ((test_mem_mso_fifo_wm_reg_t*) TEST_MEM_MSO_FIFO_WM0_ADR(_BASE))
#define TEST_MEM_MSO_FIFO_WM1_REG(_BASE) ((test_mem_mso_fifo_wm_reg_t*) TEST_MEM_MSO_FIFO_WM1_ADR(_BASE))
#define TEST_MEM_MSO_FIFO_WM2_REG(_BASE) ((test_mem_mso_fifo_wm_reg_t*) TEST_MEM_MSO_FIFO_WM2_ADR(_BASE))
#define TEST_MEM_BIST_ADC_MODE_REG(_BASE) ((test_mem_bist_adc_mode_reg_t*) TEST_MEM_BIST_ADC_MODE_ADR(_BASE))
#define TEST_MEM_BIST_ADC_CTRL_REG(_BASE) ((test_mem_bist_adc_ctrl_reg_t*) TEST_MEM_BIST_ADC_CTRL_ADR(_BASE))
#define TEST_MEM_BIST_STAT_REG(_BASE) ((test_mem_bist_stat_reg_t*) TEST_MEM_BIST_STAT_ADR(_BASE))
#define TEST_MEM_BIST_WAIT_TIME_REG(_BASE) ((test_mem_bist_wait_time_reg_t*) TEST_MEM_BIST_WAIT_TIME_ADR(_BASE))
#define TEST_MEM_BIST_TEST_TIME_REG(_BASE) ((test_mem_bist_test_time_reg_t*) TEST_MEM_BIST_TEST_TIME_ADR(_BASE))
#define TEST_MEM_BIST_PLL_BYP_PHASE_REG(_BASE) ((test_mem_bist_pll_byp_phase_reg_t*) TEST_MEM_BIST_PLL_BYP_PHASE_ADR(_BASE))
#define TEST_MEM_BIST_PLL_BYP_MULT_REG(_BASE) ((test_mem_bist_pll_byp_mult_reg_t*) TEST_MEM_BIST_PLL_BYP_MULT_ADR(_BASE))
#define TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_REG(_BASE) ((test_mem_bist_amplitude_multiplier_reg_t*) TEST_MEM_BIST_AMPLITUDE_MULTIPLIER_ADR(_BASE))
#define TEST_MEM_TPACK_FIFO_WM_REG(_BASE) ((test_mem_tpack_fifo_wm_reg_t*) TEST_MEM_TPACK_FIFO_WM_ADR(_BASE))
#define TEST_MEM_TDPACK_CFG_REG(_BASE) ((test_mem_tdpack_cfg_reg_t*) TEST_MEM_TDPACK_CFG_ADR(_BASE))
#define TEST_MEM_MSO_FIFO_STAT0_REG(_BASE) ((test_mem_mso_fifo_stat_reg_t*) TEST_MEM_MSO_FIFO_STAT0_ADR(_BASE))
#define TEST_MEM_MSO_FIFO_STAT1_REG(_BASE) ((test_mem_mso_fifo_stat_reg_t*) TEST_MEM_MSO_FIFO_STAT1_ADR(_BASE))
#define TEST_MEM_MSO_FIFO_STAT2_REG(_BASE) ((test_mem_mso_fifo_stat_reg_t*) TEST_MEM_MSO_FIFO_STAT2_ADR(_BASE))
#define TEST_MEM_PLL_DBGM_FIFO_STAT_REG(_BASE) ((test_mem_pll_dbgm_fifo_stat_reg_t*) TEST_MEM_PLL_DBGM_FIFO_STAT_ADR(_BASE))
#define TEST_MEM_TPACK_FIFO_STAT_REG(_BASE) ((test_mem_tpack_fifo_stat_reg_t*) TEST_MEM_TPACK_FIFO_STAT_ADR(_BASE))
#define TEST_MEM_FIFO_FLUSH_REG(_BASE) ((test_mem_fifo_flush_reg_t*) TEST_MEM_FIFO_FLUSH_ADR(_BASE))
#define TEST_MEM_TEST_ERR_REG(_BASE) ((test_mem_test_err_reg_t*) TEST_MEM_TEST_ERR_ADR(_BASE))
#define TEST_MEM_PACKER_CFG_REG(_BASE) ((test_mem_packer_cfg_reg_t*) TEST_MEM_PACKER_CFG_ADR(_BASE))
#define TEST_MEM_INT_STAT_REG(_BASE) ((test_mem_int_stat_reg_t*) TEST_MEM_INT_STAT_ADR(_BASE))
#define TEST_MEM_INT_HIGH_EN_REG(_BASE) ((test_mem_int_high_en_reg_t*) TEST_MEM_INT_HIGH_EN_ADR(_BASE))
#define TEST_MEM_INT_LOW_EN_REG(_BASE) ((test_mem_int_low_en_reg_t*) TEST_MEM_INT_LOW_EN_ADR(_BASE))
#define TEST_MEM_INT_CLR_REG(_BASE) ((test_mem_int_clr_reg_t*) TEST_MEM_INT_CLR_ADR(_BASE))
#define TEST_MEM_INT_FORCE_REG(_BASE) ((test_mem_int_force_reg_t*) TEST_MEM_INT_FORCE_ADR(_BASE))
#define TEST_MEM_TTSG_EN0_REG(_BASE) ((test_mem_ttsg_en_reg_t*) TEST_MEM_TTSG_EN0_ADR(_BASE))
#define TEST_MEM_TTSG_EN1_REG(_BASE) ((test_mem_ttsg_en_reg_t*) TEST_MEM_TTSG_EN1_ADR(_BASE))
#define TEST_MEM_TTSG_MODE_REG(_BASE) ((test_mem_ttsg_mode_reg_t*) TEST_MEM_TTSG_MODE_ADR(_BASE))
#define TEST_MEM_CDAC_CFG_REG(_BASE) ((test_mem_cdac_cfg_reg_t*) TEST_MEM_CDAC_CFG_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER0_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER0_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER1_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER1_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER2_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER2_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER3_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER3_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER4_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER4_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER5_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER5_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER6_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER6_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER7_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER7_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER8_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER8_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER9_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER9_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER10_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER10_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER11_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER11_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER12_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER12_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER13_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER13_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER14_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER14_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER15_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER15_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER16_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER16_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER17_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER17_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER18_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER18_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER19_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER19_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER20_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER20_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER21_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER21_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER22_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER22_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER23_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER23_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER24_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER24_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER25_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER25_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER26_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER26_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER27_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER27_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER28_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER28_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER29_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER29_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER30_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER30_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_UPPER31_REG(_BASE) ((test_mem_ttsg_cordic_init_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_UPPER31_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER0_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER0_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER1_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER1_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER2_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER2_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER3_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER3_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER4_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER4_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER5_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER5_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER6_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER6_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER7_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER7_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER8_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER8_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER9_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER9_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER10_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER10_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER11_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER11_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER12_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER12_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER13_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER13_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER14_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER14_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER15_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER15_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER16_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER16_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER17_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER17_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER18_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER18_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER19_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER19_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER20_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER20_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER21_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER21_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER22_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER22_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER23_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER23_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER24_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER24_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER25_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER25_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER26_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER26_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER27_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER27_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER28_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER28_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER29_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER29_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER30_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER30_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INIT_LOWER31_REG(_BASE) ((test_mem_ttsg_cordic_init_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INIT_LOWER31_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER0_REG(_BASE) ((test_mem_ttsg_cordic_incr_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INCR_UPPER0_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INCR_UPPER1_REG(_BASE) ((test_mem_ttsg_cordic_incr_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INCR_UPPER1_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER0_REG(_BASE) ((test_mem_ttsg_cordic_incr_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INCR_LOWER0_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INCR_LOWER1_REG(_BASE) ((test_mem_ttsg_cordic_incr_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INCR_LOWER1_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER0_REG(_BASE) ((test_mem_ttsg_cordic_incr1_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INCR1_UPPER0_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INCR1_UPPER1_REG(_BASE) ((test_mem_ttsg_cordic_incr1_upper_reg_t*) TEST_MEM_TTSG_CORDIC_INCR1_UPPER1_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER0_REG(_BASE) ((test_mem_ttsg_cordic_incr1_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INCR1_LOWER0_ADR(_BASE))
#define TEST_MEM_TTSG_CORDIC_INCR1_LOWER1_REG(_BASE) ((test_mem_ttsg_cordic_incr1_lower_reg_t*) TEST_MEM_TTSG_CORDIC_INCR1_LOWER1_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_WM0_REG(_BASE) ((test_mem_msi_fifo_wm_reg_t*) TEST_MEM_MSI_FIFO_WM0_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_WM1_REG(_BASE) ((test_mem_msi_fifo_wm_reg_t*) TEST_MEM_MSI_FIFO_WM1_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_WM2_REG(_BASE) ((test_mem_msi_fifo_wm_reg_t*) TEST_MEM_MSI_FIFO_WM2_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_WM3_REG(_BASE) ((test_mem_msi_fifo_wm_reg_t*) TEST_MEM_MSI_FIFO_WM3_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_WM4_REG(_BASE) ((test_mem_msi_fifo_wm_reg_t*) TEST_MEM_MSI_FIFO_WM4_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_STAT0_REG(_BASE) ((test_mem_msi_fifo_stat_reg_t*) TEST_MEM_MSI_FIFO_STAT0_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_STAT1_REG(_BASE) ((test_mem_msi_fifo_stat_reg_t*) TEST_MEM_MSI_FIFO_STAT1_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_STAT2_REG(_BASE) ((test_mem_msi_fifo_stat_reg_t*) TEST_MEM_MSI_FIFO_STAT2_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_STAT3_REG(_BASE) ((test_mem_msi_fifo_stat_reg_t*) TEST_MEM_MSI_FIFO_STAT3_ADR(_BASE))
#define TEST_MEM_MSI_FIFO_STAT4_REG(_BASE) ((test_mem_msi_fifo_stat_reg_t*) TEST_MEM_MSI_FIFO_STAT4_ADR(_BASE))
#define TEST_MEM_ERR_PHASE_REG(_BASE) ((test_mem_err_phase_reg_t*) TEST_MEM_ERR_PHASE_ADR(_BASE))
#define TEST_MEM_ERR_AMPL_REG(_BASE) ((test_mem_err_ampl_reg_t*) TEST_MEM_ERR_AMPL_ADR(_BASE))
#define TEST_MEM_TEST_TX_CFG_REG(_BASE) ((test_mem_test_tx_cfg_reg_t*) TEST_MEM_TEST_TX_CFG_ADR(_BASE))
#define TEST_MEM_DUAL_FCW_CFG0_REG(_BASE) ((test_mem_dual_fcw_cfg_reg_t*) TEST_MEM_DUAL_FCW_CFG0_ADR(_BASE))
#define TEST_MEM_DUAL_FCW_CFG1_REG(_BASE) ((test_mem_dual_fcw_cfg_reg_t*) TEST_MEM_DUAL_FCW_CFG1_ADR(_BASE))
#define TEST_MEM_APB_BRDG_STAT_REG(_BASE) ((test_mem_apb_brdg_stat_reg_t*) TEST_MEM_APB_BRDG_STAT_ADR(_BASE))
#define TEST_MEM_PLL_FUNCTION_REG(_BASE) ((test_mem_pll_function_reg_t*) TEST_MEM_PLL_FUNCTION_ADR(_BASE))
#define TEST_MEM_PLL_STAT_REG(_BASE) ((test_mem_pll_stat_reg_t*) TEST_MEM_PLL_STAT_ADR(_BASE))
#define TEST_MEM_PLL_CNTER_REG(_BASE) ((test_mem_pll_cnter_reg_t*) TEST_MEM_PLL_CNTER_ADR(_BASE))
#define TEST_MEM_PLL_WAIT_CNT_REG(_BASE) ((test_mem_pll_wait_cnt_reg_t*) TEST_MEM_PLL_WAIT_CNT_ADR(_BASE))
#define TEST_MEM_PLL_CNT_HIGH_REG(_BASE) ((test_mem_pll_cnt_high_reg_t*) TEST_MEM_PLL_CNT_HIGH_ADR(_BASE))
#define TEST_MEM_PLL_CNT_LOW_REG(_BASE) ((test_mem_pll_cnt_low_reg_t*) TEST_MEM_PLL_CNT_LOW_ADR(_BASE))
#define TEST_MEM_APB_BRDG_STAT_PLL_REG(_BASE) ((test_mem_apb_brdg_stat_pll_reg_t*) TEST_MEM_APB_BRDG_STAT_PLL_ADR(_BASE))

// ******************************************* /Register pointer macros


// ******************************************* AddressSpace struct
typedef struct
{
    test_mem_scratch_reg_t SCRATCH;    /*< Address offset = 0x0 */
    test_mem_msi_active_reg_t MSI_ACTIVE; /*< Address offset = 0x4 */
    test_mem_rd_en_reg_t MEM_RD_EN;  /*< Address offset = 0x8 */
    test_mem_wr_en_reg_t MEM_WR_EN;  /*< Address offset = 0xc */
    const uint8_t        reservedArea0 [16];  /*< Address offset = 0x10 */
    test_mem_rxbar_sel_reg_t RXBAR_SEL[5]; /*< Address offset = 0x20 */
    const uint8_t        reservedArea1 [44];  /*< Address offset = 0x34 */
    test_mem_mso_fifo_wm_reg_t MSO_FIFO_WM[3]; /*< Address offset = 0x60 */
    const uint8_t        reservedArea2 [4];   /*< Address offset = 0x6c */
    test_mem_bist_adc_mode_reg_t BIST_ADC_MODE; /*< Address offset = 0x70 */
    test_mem_bist_adc_ctrl_reg_t BIST_ADC_CTRL; /*< Address offset = 0x74 */
    test_mem_bist_stat_reg_t BIST_STAT;  /*< Address offset = 0x78 */
    test_mem_bist_wait_time_reg_t BIST_WAIT_TIME; /*< Address offset = 0x7c */
    test_mem_bist_test_time_reg_t BIST_TEST_TIME; /*< Address offset = 0x80 */
    test_mem_bist_pll_byp_phase_reg_t BIST_PLL_BYP_PHASE; /*< Address offset = 0x84 */
    test_mem_bist_pll_byp_mult_reg_t BIST_PLL_BYP_MULT; /*< Address offset = 0x88 */
    test_mem_bist_amplitude_multiplier_reg_t BIST_AMPLITUDE_MULTIPLIER; /*< Address offset = 0x8c */
    const uint8_t        reservedArea3 [88];  /*< Address offset = 0x90 */
    test_mem_tpack_fifo_wm_reg_t TPACK_FIFO_WM; /*< Address offset = 0xe8 */
    const uint8_t        reservedArea4 [4];   /*< Address offset = 0xec */
    test_mem_tdpack_cfg_reg_t TDPACK_CFG; /*< Address offset = 0xf0 */
    const uint8_t        reservedArea5 [12];  /*< Address offset = 0xf4 */
    test_mem_mso_fifo_stat_reg_t MSO_FIFO_STAT[3]; /*< Address offset = 0x100 */
    const uint8_t        reservedArea6 [4];   /*< Address offset = 0x10c */
    test_mem_pll_dbgm_fifo_stat_reg_t PLL_DBGM_FIFO_STAT; /*< Address offset = 0x110 */
    const uint8_t        reservedArea7 [16];  /*< Address offset = 0x114 */
    test_mem_tpack_fifo_stat_reg_t TPACK_FIFO_STAT; /*< Address offset = 0x124 */
    test_mem_fifo_flush_reg_t FIFO_FLUSH; /*< Address offset = 0x128 */
    test_mem_test_err_reg_t TEST_ERR;   /*< Address offset = 0x12c */
    test_mem_packer_cfg_reg_t PACKER_CFG; /*< Address offset = 0x130 */
    const uint8_t        reservedArea8 [76];  /*< Address offset = 0x134 */
    test_mem_int_stat_reg_t INT_STAT; /*< Address offset = 0x180 */
    test_mem_int_high_en_reg_t INT_HIGH_EN; /*< Address offset = 0x184 */
    test_mem_int_low_en_reg_t INT_LOW_EN; /*< Address offset = 0x188 */
    test_mem_int_clr_reg_t INT_CLR;  /*< Address offset = 0x18c */
    test_mem_int_force_reg_t INT_FORCE;  /*< Address offset = 0x190 */
    const uint8_t        reservedArea9 [92];  /*< Address offset = 0x194 */
    test_mem_ttsg_en_reg_t TTSG_EN[2]; /*< Address offset = 0x1f0 */
    test_mem_ttsg_mode_reg_t TTSG_MODE;  /*< Address offset = 0x1f8 */
    test_mem_cdac_cfg_reg_t CDAC_CFG;   /*< Address offset = 0x1fc */
    test_mem_ttsg_cordic_init_upper_reg_t TTSG_CORDIC_INIT_UPPER[32]; /*< Address offset = 0x200 */
    test_mem_ttsg_cordic_init_lower_reg_t TTSG_CORDIC_INIT_LOWER[32]; /*< Address offset = 0x280 */
    test_mem_ttsg_cordic_incr_upper_reg_t TTSG_CORDIC_INCR_UPPER[2]; /*< Address offset = 0x300 */
    test_mem_ttsg_cordic_incr_lower_reg_t TTSG_CORDIC_INCR_LOWER[2]; /*< Address offset = 0x308 */
    test_mem_ttsg_cordic_incr1_upper_reg_t TTSG_CORDIC_INCR1_UPPER[2]; /*< Address offset = 0x310 */
    test_mem_ttsg_cordic_incr1_lower_reg_t TTSG_CORDIC_INCR1_LOWER[2]; /*< Address offset = 0x318 */
    test_mem_msi_fifo_wm_reg_t MSI_FIFO_WM[5]; /*< Address offset = 0x320 */
    const uint8_t        reservedArea10 [12]; /*< Address offset = 0x334 */
    test_mem_msi_fifo_stat_reg_t MSI_FIFO_STAT[5]; /*< Address offset = 0x340 */
    const uint8_t        reservedArea11 [12]; /*< Address offset = 0x354 */
    test_mem_err_phase_reg_t ERR_PHASE; /*< Address offset = 0x360 */
    test_mem_err_ampl_reg_t ERR_AMPL; /*< Address offset = 0x364 */
    test_mem_test_tx_cfg_reg_t TEST_TX_CFG; /*< Address offset = 0x368 */
    const uint8_t        reservedArea12 [20]; /*< Address offset = 0x36c */
    test_mem_dual_fcw_cfg_reg_t DUAL_FCW_CFG[2]; /*< Address offset = 0x380 */
    const uint8_t        reservedArea13 [116]; /*< Address offset = 0x388 */
    test_mem_apb_brdg_stat_reg_t APB_BRDG_STAT; /*< Address offset = 0x3fc */
    const uint8_t        reservedArea14 [96]; /*< Address offset = 0x400 */
    test_mem_pll_function_reg_t PLL_FUNCTION; /*< Address offset = 0x460 */
    test_mem_pll_stat_reg_t PLL_STAT; /*< Address offset = 0x464 */
    test_mem_pll_cnter_reg_t PLL_CNTER; /*< Address offset = 0x468 */
    test_mem_pll_wait_cnt_reg_t PLL_WAIT_CNT; /*< Address offset = 0x46c */
    test_mem_pll_cnt_high_reg_t PLL_CNT_HIGH; /*< Address offset = 0x470 */
    test_mem_pll_cnt_low_reg_t PLL_CNT_LOW; /*< Address offset = 0x474 */
    const uint8_t        reservedArea15 [900]; /*< Address offset = 0x478 */
    test_mem_apb_brdg_stat_pll_reg_t APB_BRDG_STAT_PLL; /*< Address offset = 0x7fc */
} test_t;     // size: 0x00c8

// AddressSpace struct pointer
//
#define MEM_CAP0_TEST    ((test_t*) MEM_CAP0_TEST_BASE)
#define MEM_CAP1_TEST    ((test_t*) MEM_CAP1_TEST_BASE)

// ******************************************* /Address Space

#endif      // _TEST_H_

