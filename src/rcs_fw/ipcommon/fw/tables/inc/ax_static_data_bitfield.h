/* INTEL CONFIDENTIAL
 *
 * Copyright 2024 Intel Corporation All Rights Reserved.
 *
 * The source code contained or described herein and all documents related
 * to the source code ("Material") are owned by Intel Corporation or its
 * suppliers or licensors. Title to the Material remains with Intel
 * Corporation or its suppliers and licensors. The Material contains trade
 * secrets and proprietary and confidential information of Intel or its
 * suppliers and licensors. The Material is protected by worldwide copyright
 * and trade secret laws and treaty provisions. No part of the Material
 * may be used, copied, reproduced, modified, published, uploaded, posted,
 * transmitted, distributed, or disclosed in any way without Intel's prior
 * express written permission.
 *
 * No license under any patent, copyright, trade secret or other
 * intellectual property right is granted to or conferred upon you by
 * disclosure or delivery of the Materials, either expressly, by
 * implication, inducement, estoppel or otherwise. Any license under such
 * intellectual property rights must be express and approved by Intel in
 * writing.
 *
 *****************************************************************************/

/**
 * this header file is generated by tool, any direct modification without going
 * through the table generation process will get lost
 */

#ifndef __AX_STATIC_DATA_BITFIELD__
#define __AX_STATIC_DATA_BITFIELD__

#include <stdint.h>
#include "com_rf_def.h"

/*
 * BFN main and remote configuration/
 */
typedef union {
    struct
    {
        uint8_t bfn_rmt_chk_en : 1;   // Enable BFN remote check
        uint8_t ext_src_sel : 2;      // None=0, Sysref=1, GPIO=2, Both=3
        uint8_t extsync_gpio_sel : 5; // External BFN GPIO select
    };
    uint8_t value;
} ax_bfn_config_lut_bf_t;

/*
 * BFN self sync offset
 */
typedef union {
    struct
    {
        uint32_t self_sync_offset; // Self sync offset need for setup self sync
    };
    uint32_t value;
} ax_bfn_selfsync_lut_bf_t;

/*
 * JESD compression parameters and register settings
 */
typedef union {
    struct
    {
        uint32_t comp_top_reg : 20;        // Defines the different modes of operation of compression modes
        uint32_t significand_width : 4;    // Significant width
        uint32_t exponent_width : 3;       // Expondent Width
        uint32_t jesd_format : 1;          // JESD format total bits(0=24, 1=32)
        uint32_t input_iq_format : 1;      // Input Format (0=sc16.15, 1 = sc32.15)
        uint32_t signed_format : 1;        // signed_format (0=TC, 1=SM)
        uint32_t agc_bit : 1;              // AGC bit (0=NO, 1=YES)
        uint32_t exponent_method : 1;      // Exponent Method (0=Common, 1=Individual)
        uint32_t comp_vmlga_reg;           // Configuration input to VMLGA module of compression block
        uint32_t comp_vnsh_reg;            // Configuration input to the NORMSHIFT module of compression block
        uint32_t comp_bitformat_ctl0_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl1_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl2_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl3_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl4_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl5_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl6_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl7_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl8_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl9_reg;  // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl10_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl11_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl12_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl13_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl14_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl15_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl16_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl17_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl18_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl19_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl20_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl21_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl22_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl23_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl24_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl25_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl26_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl27_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl28_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl29_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl30_reg; // Select input to Mux of bit packing logic
        uint32_t comp_bitformat_ctl31_reg; // Select input to Mux of bit packing logic
    };
    uint32_t value[35];
} ax_jesd_comp_param_lut_bf_t;

/*
 * Additional JESD configuration parameters for each JESD use case index.
 */
typedef union {
    struct
    {
        uint32_t jesd_1p5g_clk : 1;             // Set to 1 if JESD case uses 1p5Ghz input clock
        uint32_t jesd_sample_width_n : 1;       // Set to 0 for 16 bit, 1 for 24 bit. N parameter.
        uint32_t jesd_octets_per_frame_f : 5;   // Number of octets in a frame minus 1. F parameter.
        uint32_t jesd_samples_per_frame_s : 1;  // Number of samples per frame minus 1. (0=1 sample, 1=2 samples) S parameter.
        uint32_t jesd_hd_flag : 1;              // JESD High density = 1
        uint32_t jesd_sample_to_char_ratio : 3; // Clock ratio CHAR * (N+1) = Sample
        uint32_t jesd_soni : 3;                 // JESD Samples on Interface (SONI).
        uint32_t res_15 : 1;                    // reserved
        uint32_t tx_sample_neg : 3;             // Positive/Negative is a ratio of clocks with data versus clocks without data. The
                                                // negative sample is number of consecutive clocks without data between positive
                                                // clocks.
        uint32_t tx_sample_pos : 3;             // Positive/Negative is a ratio of clocks with data versus clocks without data. The
                                                // positive sample is number of consecutive clocks with data between negative clocks.
        uint32_t jesd_num_min_emb : 2;          // Number of minimum EMB
        uint32_t tx_latency_delay : 8;          // Number of reference clocks that transmit data is delayed through the JESD.
    };
    uint32_t value;
} ax_jesd_configuration_lut_bf_t;

/*
 * JESD decompression parameters and register settings
 */
typedef union {
    struct
    {
        uint32_t decomp_top_reg : 4;    // Defines the different modes of operation of decompression modes
        uint32_t significand_width : 4; // Significant width
        uint32_t exponent_width : 3;    // Expondent Width
        uint32_t jesd_format : 1;       // JESD format total bits(0=24, 1=32)
        uint32_t input_iq_format : 1;   // Input Format (0=sc16.15, 1 = sc32.15)
        uint32_t signed_format : 1;     // signed_format (0=TC, 1=SM)
        uint32_t exponent_method : 1;   // Exponent Method (0=Common, 1=Individual)
        uint32_t res_31_15 : 17;        // reserved
        uint32_t decomp_vnsh_ctl;       // Configuration input to the NORMSHIFT module of decompression block
        uint32_t decomp_mantissa_ctl0;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl1;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl2;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl3;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl4;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl5;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl6;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl7;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl8;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl9;  // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl10; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl11; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl12; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl13; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl14; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl15; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl16; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl17; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl18; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl19; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl20; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl21; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl22; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl23; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl24; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl25; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl26; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl27; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl28; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl29; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl30; // Defines ECC status for data going to crux ports
        uint32_t decomp_mantissa_ctl31; // Defines ECC status for data going to crux ports
        uint32_t decomp_exp_ctl0;       // Control to select the exponent bits from the compressed data packet
        uint32_t decomp_exp_ctl1;       // Control to select the exponent bits from the compressed data packet
        uint32_t decomp_exp_ctl2;       // Control to select the exponent bits from the compressed data packet
        uint32_t decomp_exp_ctl3;       // Control to select the exponent bits from the compressed data packet
        uint32_t decomp_exp_ctl4;       // Control to select the exponent bits from the compressed data packet
        uint32_t decomp_exp_ctl5;       // Control to select the exponent bits from the compressed data packet
        uint32_t decomp_exp_ctl6;       // Control to select the exponent bits from the compressed data packet
        uint32_t decomp_exp_ctl7;       // Control to select the exponent bits from the compressed data packet
    };
    uint32_t value[42];
} ax_jesd_decomp_param_lut_bf_t;

/*
 * Input parameter types required to configure JESD
 */
typedef union {
    struct
    {
        e_jesd_sysref_clk_t sysref_rate : 2; // SYSREF clk rate
        uint32_t compression_type : 4;       // TX data compression type
        uint32_t decompression_type : 2;     // RX data decompression type
        uint32_t jesd_tx_start_type : 1;     // Select JESD TX startup method (0=ANTENNARX_START, 1=BFN)
        uint32_t jesd_rx_start_type : 1;     // Select JESD RX startup method (0=First Valid Smpl, 1=SW triggered)
        uint32_t res_31_10 : 22;             // reserved
    };
    uint32_t value;
} ax_jesd_input_param_lut_bf_t;

/*
 * Rate To JESD Use case index mapping table. Table is indexed by JESD use case (configuration message parameter) and
 * provides lookup for rates associated with the use case index.
 */
typedef union {
    struct
    {
        e_jesd_sample_rate_t jesd_sample_rate : 4;         // Jesd Sample Rate enumeration
        uint32_t jesd_num_streams : 4;                     // Log 2 of number of data streams. 0=1, 1=2, 2=4, 3=8, 4=16
        uint32_t jesd_num_lanes_l : 4;                     // Number of serdes lanes. L Parameter.
        e_serdes_phy_data_rate_t jesd_serdes_bit_rate : 4; // JESD Serdes bit rate enumeration
        uint32_t jesd_num_converters_m : 4;                // Log 2 of number of data converters. 0=1, 1=2, 2=4, 3=8, 4=16.
                                                           // parameter M.
        e_jesd_char_clock_t jesd_char_clk : 4;             // JESD Character clock rate enumeration
        e_jesd_char_clock_t jesd_sample_clk : 4;           // JESD Sample clock rate enumeration
        uint32_t res_30_28 : 3;                            // reserved
        uint32_t jesd_204d : 1;                            // 0 = 204C 1 = 204D
    };
    uint32_t value;
} ax_jesd_rate_index_lut_bf_t;

/*
 * Firmware print configuration table. Configure base address for printing'fifo' for simulation.
 */
typedef union {
    struct
    {
        uint32_t print_monitor_base_address; // base address for the AX CPU print monitor
    };
    uint32_t value;
} ax_print_config_lut_bf_t;

#endif // __AX_STATIC_DATA_BITFIELD__
