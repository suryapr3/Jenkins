/* INTEL CONFIDENTIAL
 *
 * Copyright 2024 Intel Corporation All Rights Reserved.
 *
 * The source code contained or described herein and all documents related
 * to the source code ("Material") are owned by Intel Corporation or its
 * suppliers or licensors. Title to the Material remains with Intel
 * Corporation or its suppliers and licensors. The Material contains trade
 * secrets and proprietary and confidential information of Intel or its
 * suppliers and licensors. The Material is protected by worldwide copyright
 * and trade secret laws and treaty provisions. No part of the Material
 * may be used, copied, reproduced, modified, published, uploaded, posted,
 * transmitted, distributed, or disclosed in any way without Intel's prior
 * express written permission.
 *
 * No license under any patent, copyright, trade secret or other
 * intellectual property right is granted to or conferred upon you by
 * disclosure or delivery of the Materials, either expressly, by
 * implication, inducement, estoppel or otherwise. Any license under such
 * intellectual property rights must be express and approved by Intel in
 * writing.
 *
 *****************************************************************************/

/**
 * this header file is generated by tool, any direct modification without going
 * through the table generation process will get lost
 */

#ifndef __COM_STATIC_DATA_BITFIELD__
#define __COM_STATIC_DATA_BITFIELD__

#include <stdint.h>
#include "com_rf_def.h"

/*
 * supported sample rate, PLL clock and operation clock combination, this table is indexed by [drf_rate] (need 8-bit). Bit
 * fields stage_active specifies filter setting when in manual mode; for auto mode, only sys_rate and ant_rate are needed.
 */
typedef union {
    struct
    {
        e_sys_clk_t f_clk : 1;      // operation clock, 0:983.04MHz, 1: 1474.56MHz. VHA/V2D/DRF should have same operation clock
        e_pll_clk_t pll_clk : 2;    // PLL clock, 0: 15.72864GHz, 1: 17.69472GHz, 2: 23.59296GHz
        e_ant_rate_t ant_rate : 3;  // supported DRF output rate, 0:3s/clk, 1:4s/clk, 2:6s/clk, 3:8s/clk, 4:12s/clk, 5:16s/clk
        e_sys_rate_t sys_rate : 5;  // supoorted DRF input rate in MSPS, 0:245.76, 1:368.64, 2: 491.52, 3:737.28, 4:983.04,
                                    // 5:1474.56, 6:1966.08, 7:2949.12, 8:3932.16, 9:5898.24, 10:7864.32, 11:11796.48
        e_smpl_fmt_t smpl_fmt : 1;  // data use IQ format or Real at sample I/F. 0: IQ, 1: Real
        uint32_t stage_active : 11; // each of these 11 bits indicating corresponding filter (from low to high: TBF1, TBF1I/D,
                                    // TBF2, TBF2I/D, HBF1, FBF1, HBF2, HBF3, HBF4, HBF5 and HBF6) is active or not
        uint32_t smpl_per_clk : 4;  // num of samples per clock, based on ant_rate
        uint32_t res_31_27 : 5;     // reserved
    };
    uint32_t value;
} com_drf_rate_conf_lut_bf_t;

/*
 * Common Firmware configuration table.
 */
typedef union {
    struct
    {
        uint32_t fw_env : 2;                   // Firmware Execution environment. 0=HW 1=RTL Sim 2=VP
        uint32_t fw_debug_level : 3;           // Firmware debug log level
        uint32_t fw_trace_buffer_config : 8;   // Trace buffer control-Value in BitMask
        uint32_t fw_boot_iteration_delay : 11; // Delay per boot-wait loop
        uint32_t fw_boot_iterations : 8;       // Number of iterations for boot-wait loop
    };
    uint32_t value;
} com_fw_config_lut_bf_t;

/*
 * JESD host id LUT, indexed by JESD port id (0 to 3); indexing of this table needs 2-bit
 */
typedef union {
    struct
    {
        uint8_t host_id : 7; // JESD host id
        uint8_t res_7 : 1;   // reserved
    };
    uint8_t value;
} com_jesd_hostid_lut_bf_t;

/*
 * RXFB host id LUT, indexed by DRF id (0 to 1, ie, DRF_IDX(ant_idx)); indexing of this table needs 1-bit
 */
typedef union {
    struct
    {
        uint16_t chain0 : 7;    // Host id for RXFB chain0
        uint16_t chain1 : 7;    // Host id for RXFB chain1
        uint16_t res_15_14 : 2; // reserved
    };
    uint16_t value;
} com_rxfb_hostid_lut_bf_t;

/*
 * Common Firmware configuration table.
 */
typedef union {
    struct
    {
        uint32_t trax_trigger_pc;     // Address to stop trax recording stop
        uint32_t trax_stop_pcml : 5;  // Ignore these many lower bits of TRIGGERPC
        uint32_t trax_stop_pcms : 1;  // Out of range, Range specified in TRIGGERPC
        uint32_t trax_ctrl_pcmen : 1; // Enable TRIGGERPC register
        uint32_t res_63_39 : 25;      // reserved
    };
    uint32_t value[2];
} com_trax_addr_config_lut_bf_t;

/*
 * V2D host id LUT, indexed by group id (0 to 7, ie, TRX_GRP_IDX(ant_idx)); indexing of this table needs 3-bit
 */
typedef union {
    struct
    {
        uint32_t apb0_port0 : 7; // host id for V2D port 0 on CM0
        uint32_t apb0_port1 : 7; // host id for V2D port 1 on CM0
        uint32_t apb1_port0 : 7; // host id for V2D port 0 on CM1
        uint32_t apb1_port1 : 7; // host id for V2D port 1 on CM1
        uint32_t res_31_28 : 4;  // reserved
    };
    uint32_t value;
} com_v2d_hostid_lut_bf_t;

/*
 * specifying watermark and stream count based on VEX process block size and sample rate. Watermark is used for releasing
 * data from V2D buffer while stream count is used by CM for when to release data out from CM. this table is accessed as
 * table[e_blk_sz_t][sys_rate equavalent]
 */
typedef union {
    struct
    {
        uint32_t strm_cnt : 10;  // This value is used to read data flits out of Tx Buffer in CM. It supports up to 1k 512-bit data
                                 // flits. 0 means 1 flit
        uint32_t wm : 12;        // watermark for when to release data from V2D buffer (A/C, B), current use %50 of VEX process block
        uint32_t res_31_22 : 10; // reserved
    };
    uint32_t value;
} com_v2d_strm_buf_lut_bf_t;

/*
 * specifying # of VEXs used for B flow, C/A flow, D flow, F flow, G flow and proc_block_granularity(0.52us or 1.04us).
 * Current set to 4-bit index, might extent in the future. Indexed by [strm_cfg]
 */
typedef union {
    struct
    {
        uint16_t ac : 3;            // num of stream/VEXs for A/C flow
        uint16_t b : 3;             // num of stream/VEXs for B flow
        uint16_t d : 3;             // num of VEXs for D flow
        uint16_t g : 3;             // num of VEXs for G flow
        uint16_t f : 3;             // num of stream/VEXs for F flow
        e_proc_blk_sz_t blk_sz : 1; // vex process block granularity. Assumption here is for specific topology, all VEX use
                                    // same processing block size
    };
    uint16_t value;
} com_v2d_strm_cfg_lut_bf_t;

/*
 * VEX host id LUT, indexed by group id (0 to 7, ie, TRX_GRP_IDX(ant_idx)); this table assumes that 2x2 VEX cores connected
 * to the same SW plus one VEX from the middle column connected to the SW could be assigned to one V2D block. indexing of
 * this table needs 3-bit
 */
typedef union {
    struct
    {
        uint32_t v0 : 5;        // the north_east VEX core host id
        uint32_t v1 : 5;        // the south_east VEX core host id
        uint32_t v2 : 5;        // the north_west VEX core host id
        uint32_t v3 : 5;        // the south_west VEX core host id
        uint32_t v4 : 6;        // the middle VEX host id
        uint32_t res_31_26 : 6; // reserved
    };
    uint32_t value;
} com_vex_hostid_lut_bf_t;

/*
 * VHA host id LUT, indexed by group id (0 to 7, ie, TRX_GRP_IDX(ant_idx)); indexing of this table needs 3-bit
 */
typedef union {
    struct
    {
        uint16_t port0 : 7;     // Host id for VHA port 0
        uint16_t port1 : 7;     // Host id for VHA port 1
        uint16_t res_15_14 : 2; // reserved
    };
    uint16_t value;
} com_vha_hostid_lut_bf_t;

/*
 * VHA input FIFO watermark setting table. This table is indexed by [f_clk][vha_input_rate], here f_clk = e_CLK_983M for
 * operation clock at 1GHz, f_clk = e_CLK_1474M for operation clock at 1.5GHz, vha_input_rate is the valid DL VHA input
 * rates: e_VHA_RATE_P125 to e_VHA_RATE_1
 */
typedef union {
    struct
    {
        uint16_t if_wm_1_us : 8;  // VHA input FIFO watermark for 1.04us
        uint16_t if_wm_p5_us : 7; // VHA input FIFO watermark for 0.52 us
        uint16_t res_15 : 1;      // reserved
    };
    uint16_t value;
} com_vha_if_wm_lut_bf_t;

/*
 * supported VHA DUC/DDC configuration, this table indexed by usecase (need 4-bit)
 */
typedef union {
    struct
    {
        uint16_t stage_active : 4;  // Manual filter stage selection bits. These bits determine which filter stages are active when
                                    // MODE is 1. When a STAGE_ACTIVE bit is 1, corresponding filter stage is active, otherwise it
                                    // is bypassed(low to high: w1 to w4)
        e_vha_rate_t high_rate : 3; // for VHA_DDC, this is the sample rate of the data present in the UL input FIFO, if vha_dmod
                                    // is being used, this cannot be any less than VHA_RATE_1, if dmod is bypassed, this can take
                                    // any legal rate; for VHA_DUC, This is the sample rate out of bank 0/1 of vha_duc, Note that
                                    // if vha_mod is being used, this cannot be any less than VHA_RATE_1.
        e_vha_rate_t low_rate : 3;  // for DUC, this is the sample rate of the data present in the downlink band 0/1 input FIFO,
                                    // this must be set correctly so that the VHA circuitry extracts data for the respective band
                                    // correctly, if the VHA_DUC is being used, this must be programmed to match its input rate.
                                    // for DDC, this is the sample rate of the data at the output of the VHA_DDC
        e_vha_rate_t mix_rate : 3;  // optional mod/demod rate, value e_VHA_NO_MIX=6 indicating no mod/demod used(if input_rate for
                                    // DDC or output_rate for DUC is less than min SWG rate 983.04/1474.56MSPS). mix_rate almost
                                    // always the same as high_rate
        uint16_t smpl_per_clk : 3;  // num of samples at input to MOD (for DL) or DMOD (for UL), this can be used by SWG
                                    // configuration for num of polyphases. 0 means input sample rate is lower than mix_rate
    };
    uint16_t value;
} com_vha_rate_conf_lut_bf_t;

#endif // __COM_STATIC_DATA_BITFIELD__
