# INTEL CONFIDENTIAL
#
# Copyright 2022 Intel Corporation All Rights Reserved.
#
# The source code contained or described herein and all documents related
# to the source code ("Material") are owned by Intel Corporation or its
# suppliers or licensors. Title to the Material remains with Intel
# Corporation or its suppliers and licensors. The Material contains trade
# secrets and proprietary and confidential information of Intel or its
# suppliers and licensors. The Material is protected by worldwide copyright
# and trade secret laws and treaty provisions. No part of the Material
# may be used, copied, reproduced, modified, published, uploaded, posted,
# transmitted, distributed, or disclosed in any way without Intel's prior
# express written permission.
#
# No license under any patent, copyright, trade secret or other
# intellectual property right is granted to or conferred upon you by
# disclosure or delivery of the Materials, either expressly, by
# implication, inducement, estoppel or otherwise. Any license under such
# intellectual property rights must be express and approved by Intel in
# writing.

from time import strftime, localtime # for header copyright
import re # for regular expression
from .util import *
import json
import os

def build_copyright_info(out_f):
    """Adding copyright info for output header file

    Parameters
    ----------
    out_f : str
        output file name

    Returns
    -------
    None
    """
    # for header/copyright info generation
    lt =  strftime("%a %b %d %H:%M:%S %Y", localtime())
    year = strftime("%Y", localtime())
    out_f.write("/* INTEL CONFIDENTIAL\n")
    out_f.write(" *\n")
    out_f.write(" * Copyright " + year  + " Intel Corporation All Rights Reserved.\n")
    out_f.write(" *\n")
    out_f.write(" * The source code contained or described herein and all documents related\n")
    out_f.write(" * to the source code (\"Material\") are owned by Intel Corporation or its\n")
    out_f.write(" * suppliers or licensors. Title to the Material remains with Intel\n")
    out_f.write(" * Corporation or its suppliers and licensors. The Material contains trade\n")
    out_f.write(" * secrets and proprietary and confidential information of Intel or its\n")
    out_f.write(" * suppliers and licensors. The Material is protected by worldwide copyright\n")
    out_f.write(" * and trade secret laws and treaty provisions. No part of the Material\n")
    out_f.write(" * may be used, copied, reproduced, modified, published, uploaded, posted,\n")
    out_f.write(" * transmitted, distributed, or disclosed in any way without Intel's prior\n")
    out_f.write(" * express written permission.\n")
    out_f.write(" *\n")
    out_f.write(" * No license under any patent, copyright, trade secret or other\n")
    out_f.write(" * intellectual property right is granted to or conferred upon you by\n")
    out_f.write(" * disclosure or delivery of the Materials, either expressly, by\n")
    out_f.write(" * implication, inducement, estoppel or otherwise. Any license under such\n")
    out_f.write(" * intellectual property rights must be express and approved by Intel in\n")
    out_f.write(" * writing.\n")
    out_f.write(" *\n")
    out_f.write(" *****************************************************************************/\n\n")
    #out_f.write("// File Name            : " + file_name.split('/')[-1] + "\n")
    #out_f.write("// Date                 : " + lt + "\n")

def build_includ_head_info(out_f, file_name, ext):
    """Add header file macro checker with given file name and extention

    Parameters
    ----------
    out_f : str
        output file name
    file_name : str
        name to be used for header file macro checker
    ext : str
        extention to be used for header file macro checker

    Returns
    -------
    None
    """
    out_f.write("/**\n")
    out_f.write(" * this header file is generated by tool, any direct modification without going\n")
    out_f.write(" * through the table generation process will get lost\n")
    out_f.write(" */\n\n")
    out_f.write('#ifndef ' + '__' + file_name.split('/')[-1].upper().replace('.', '_') + str(ext).upper() + '__' + '\n')
    out_f.write('#define ' + '__' + file_name.split('/')[-1].upper().replace('.', '_') + str(ext).upper() + '__' + '\n')

def build_includ_tail_info(out_f, file_name, ext):
    """Adding matching maco statement for header file macro checker

    Parameters
    ----------
    out_f : str
        output file name
    file_name : str
        name to be used for header file macro checker
    ext : str
        extention to be used for header file macro checker

    Returns
    -------
    None
    """
    out_f.write('\n#endif ' + '// ' + '__' + file_name.split('/')[-1].upper().replace('.', '_') + str(ext).upper() + '__' + '\n')

def build_table_consts(out_f, super_table_name, table_dim_dic, pos_shift):
    """build up contants related to table

    Parameters
    ----------
    out_f : str
        name of output file
    super_table_name : str
        table name which contains all the tables defined in this .xlsx file
    table_dim_dic : dict
        a dimision dictionary with tbl_name as key, tup (sub_tbl_num_max, sub_tbl_entry_num_max) as value
    pos_shift : int
        position shift for output formating

    Returns
    ----------
    None
    """
    for tbl_name,dim in table_dim_dic.items():
        if dim[0] > 1 or dim[1] >= 1:
            out_f.write("\n{}{} {} {}\n".format('// Table size definition for ', ('1D', '2D')[dim[0] > 1], 'table:', \
                    tbl_name + ('[' + str(dim[1]) + ']', '[' + str(dim[0]) + '][' + str(dim[1]) + ']')[dim[0] > 1]))
        tbl_dim_const = (tbl_name.upper() + '_SUB_TBL_NUM',  tbl_name.upper() + '_MAX_ENTRY_NUM')
        if dim[0] > 1:
            out_f.write("{0} {1} {2:>{4}}{3}\n".format('#define', tbl_dim_const[0], '(', str(dim[0]) + ')', \
                    set_pos(tbl_dim_const[0], pos_shift)))
        if dim[1] > 1:
            out_f.write("{0} {1} {2:>{4}}{3}\n".format('#define',tbl_dim_const[1] , '(', str(dim[1]) + ')', \
                set_pos(tbl_dim_const[1], pos_shift)))
        if dim[0] == 1 and dim[1] == 1:
            out_f.write("{0} {1} {2:>{4}}{3}\n".format('#define',tbl_dim_const[1] , '(', str(dim[1]) + ')', \
                set_pos(tbl_dim_const[1], pos_shift)))

def build_header_bitfield(out_f, super_table_name, tbl_dic, enum_dic, do_msg, hdr_list, ctypes_dir):
    """build up bit field definition struct header file

    Parameters
    ----------
    out_f : str
        name of output header file
    super_table_name : str
        table name for the combinded table containing all the tables defined in this .xlsx file
    tbl_dic : dict
        a dictionary with tbl_name as key, tup (tbl_des, bf_blks, sub_tbl_dic, tbl_bitwidth_tup, align) as value
        tbl_des: table description
        bf_blks: bit-field block list, each bit-field block is a list of info for a specific bit-field
        sub_tbl_dic: a dictionary with info about a subtable
        tbl_bitwidth_tup: a tup with bitwidth info for each table
        align: specifying the alignment attribute of this table
    enum_dic : dict
        a dictionary: enum type name as key, a list of enum elements for this enum type as value
    do_msg: str
        indicating generating header files for message use case
    hdr_list: list
        a list of user specified header files to be included for the table
    ctypes_dir: str
        folder to store python ctypes compatible table struct definitions, an empty string means no generation of these definitions

    Returns
    ----------
    None
    """

    out_f.write('\n#include <stdint.h>\n')
    if hdr_list != None:
        for hdr in hdr_list:
            out_f.write("{} {}\n".format('#include', '"' + hdr + '"'))
    if enum_dic != {}:
        out_f.write("{} {}{}".format('#include', '"' + super_table_name.lower(), '_enum.h"\n'))

    # for python ctypes struct
    if ctypes_dir:
        py_bf_dic = {}
    pre_tab = ' '*4
    # force bit-field struct in alphabet order in generated header file
    tbl_sorted_keys = sorted(tbl_dic.keys(), key=lambda x:x.lower())
    
    for tbl_name in tbl_sorted_keys: #tbl_dic.keys():

        field_dict = {}

        tbl_des = tbl_dic[tbl_name][0]
        bf_blk = tbl_dic[tbl_name][1]
        tbl_alignment = tbl_dic[tbl_name][4]
        type_bitwidth = tbl_dic[tbl_name][3][1]
        tbl_struct_blk_num = tbl_dic[tbl_name][3][2]
        bf_max_len =  tbl_dic[tbl_name][3][3]

        # table description:
        if (tbl_des and (not tbl_des.isspace()) and (tbl_des.upper() != 'NULL')):
            out_f.write("\n/*\n")
            tbl_des = re.sub('\s+', ' ', tbl_des)
            tbl_des = re.sub(r"\s+([.;:,?!\"'])", r"\1", tbl_des) # using raw string here
            #struct_des = tbl_des.rstrip()
            out_f.write("{}{}\n".format(' * ', wrap(tbl_des, 120, 0, ' * ', 0)))
            out_f.write(" */\n")

        # table bit-field struct
        out_f.write("typedef union {\n")
        out_f.write(pre_tab + "struct {\n")
        val_str = ("value[" + str(tbl_struct_blk_num) + "];", "value;")[tbl_struct_blk_num == 1]

        # for python ctypes struct
        if ctypes_dir:
            py_val_str = "{0}\n{1}{4}{2}\n{4}{3}\n\n".format("class " + tbl_name + "_bf_t(ctypes.Union):",
                    ('', pre_tab + '_pack_ = ' + str(tbl_alignment) + "\n")[tbl_alignment != None],
                    '_anonymous_ = ("u",)',
                    "_fields_ = [ ('u', " + tbl_name + "_bf_s), " + "('value', ctypes.c_uint" + str(type_bitwidth) + ("*"+str(tbl_struct_blk_num)+") ]",") ]")[tbl_struct_blk_num == 1],
                    pre_tab)
            py_bf_head = "{0}\n{2}{1}\n".format("class " + tbl_name + "_bf_s(ctypes.Structure):", "_fields_ = [", pre_tab)
            py_bf_body = ""

        e_dic = {}


        for blk_num in range(tbl_struct_blk_num):
            for bf in bf_blk[blk_num]:

                bit_des = bf[1]

                detail_dict = {'min':bf[4], 'max':bf[5], 'sign':bf[6], 'bit width': bf[7]}
                field_dict[bf[0]] = detail_dict

                if(bit_des and (not bit_des.isspace()) and (bit_des.upper() != 'NULL')):
                    bit_des = re.sub('\s+', ' ', bit_des)
                    bit_des = re.sub(r"\s+([.;:,?!\"'])", r"\1", bit_des) # using raw string here
                    #bit_des = bit_des.rstrip()

                if bf[6] == 'signed' or bf[6] == 'unsigned':
                    field_type = ('u', '')[bf[6] == 'signed'] + 'int' + str(type_bitwidth) + '_t'
                else:
                    field_type = bf[6] # enum or float/double
                bit_width = bf[7]
                bit_upper_pos = bf[8]
                name = bf[0] # field name
                if name == None or name == 'RES':
                    name = 'RES' + '_' + str(bf[8]) + ('' if bit_width == 1 else ('_' + str(bf[8] - bit_width + 1)))
                if field_type[:2] == 'e_' and field_type[-2:] == '_t': # enum
                    if field_type[2:-2] not in e_dic.keys():
                        e_dic[field_type[2:-2]] = 0
                    else:
                        e_dic[field_type[2:-2]] += 1
                    if field_type in enum_dic.keys():
                        e_name = field_type[2:-2] + (str(e_dic[field_type[2:-2]]), '')[e_dic[field_type[2:-2]] == 0]
                    else:
                        e_name = name
                    if bit_width != type_bitwidth:
                        out_f.write("{7}{0} {1}{3:>{2}}{4:2d}{5}{6}\n".format(field_type, e_name,
                                set_pos(e_name + field_type, bf_max_len + 4),
                                " :", bit_width, "; // ", wrap(bit_des, 128 - bf_max_len - 4 - 8, 2, '// ',
                                bf_max_len + 4 + 6 - 1), pre_tab*2))
                    else:
                        out_f.write("{5}{0} {1}{2:>{3}}{4}\n".format(field_type, e_name,
                                "; // ", set_pos(e_name + field_type, bf_max_len + 4 + 7),
                                wrap(bit_des, 128 - bf_max_len - 4 - 7 - 8, 2, '// ', bf_max_len + 4 + 7 - 2), pre_tab*2))
                    # for python ctypes struct
                    if ctypes_dir:
                        py_bf_body += "{}{} {}\n".format(pre_tab*2,
                            '("' + e_name + '",', "ctypes.c_uint" + str(type_bitwidth) + (", " + str(bit_width) + "),", "),")[bit_width == type_bitwidth])
                elif bit_width == type_bitwidth or field_type == 'float' or field_type == 'double': # and (bit_upper_pos + 1) % type_bitwidth  == 0:
                    # no bit field for float/double
                    out_f.write("{5}{0} {1}{2:>{3}}{4}\n".format(field_type, name,
                        "; // ", set_pos(name + field_type, bf_max_len + 4 + 7),
                        wrap(bit_des, 128 - bf_max_len - 4 - 7 - 8, 2, '// ', bf_max_len + 4 + 7 - 2), pre_tab*2))
                    # for python ctypes struct
                    if ctypes_dir:
                        py_bf_body += "{}{} {}\n".format(pre_tab*2, '("' + name + '",', "ctypes.c_" + (field_type, field_type[:-2])[field_type[-2:] == '_t'] + (", " + str(bit_width), '')[bit_width == type_bitwidth or field_type == 'float' or field_type == 'double'] + "),")
                else:
                    out_f.write("{7}{0} {1}{3:>{2}}{4:2d}{5}{6}\n".format(field_type, name,
                        set_pos(name + field_type, bf_max_len + 4), " :", bit_width, "; // ", wrap(bit_des, 128 - bf_max_len - 4 - 8, 2, '// ', bf_max_len + 4 + 6 - 1), pre_tab*2))
                    # for python ctypes struct
                    if ctypes_dir:
                        py_bf_body += "{}{} {}\n".format( pre_tab*2, '("' + name + '",', "ctypes.c_" + (field_type, field_type[:-2])[field_type[-2:] == '_t'] + ", " + str(bit_width) + "),")

        # write dictionaries into the data file 
        if not os.path.exists('/scripts/table_utils/pm/msg_dic.dat'):
            with open("scripts/table_utils/pm/msg_dic.dat", "a+") as f:
                f.write("")
        table_dict = {}
        with open("scripts/table_utils/pm/msg_dic.dat", "r+") as f:
            if (os.stat("scripts/table_utils/pm/msg_dic.dat").st_size != 0):
                table_dict = json.load(f)
        table_dict[tbl_name] = field_dict
        with open("scripts/table_utils/pm/msg_dic.dat", "w+") as f:
            json.dump(table_dict, f, indent = 4)

        out_f.write(pre_tab + "};\n")
        out_f.write("{}uint{}_t {}\n".format(pre_tab, type_bitwidth, val_str))

        # for python ctypes struct
        if ctypes_dir:
            py_bf_dic[tbl_name] = py_bf_head + py_bf_body[:-2] + " ]\n" + py_val_str

        if tbl_alignment != None:
            out_f.write("} %s%s%s%s%s\n" % (tbl_name, '_bf_t' ,' __attribute__((aligned(', tbl_alignment, ')));'))
        else:
            out_f.write("} %s%s\n" % (tbl_name, '_bf_t;'))
        p_green2('Generated bit-field struct ', tbl_name + '_bf_t')
    
    # for python ctypes struct
    if ctypes_dir:
        ext = ''
        if do_msg != None:
            ext = '_msg'
        access = ("a", "w")[enum_dic == {}]
        with open(ctypes_dir + '/' + super_table_name + ext + ".py", access) as py_fh:
            if enum_dic == {}:
                py_fh.write("import ctypes\n\n")
            for tbl_name in py_bf_dic.keys():
                py_fh.write(py_bf_dic[tbl_name])

def build_header_enum(out_f, enum_dic, super_table_name, ctypes_dir):
    """build up enum definition

    Parameters
    ----------
    out_f : str
        name of output file
    enum_dic : dict
        a dictionary: enum type name as key, a list of enum elements for this enum type as value
    super_table_name : str
        table name for the combinded table containing all the tables defined in this .xlsx file
        here it's only used for output file name generation
    ctypes_dir: str
        folder to store python ctypes compatible table struct definitions, an empty string means no generation of these definitions

    Returns
    ----------
    None
    """
    pre_tab = ' '*4
    # for python ctypes struct
    if ctypes_dir:
        py_enum = ""

    if enum_dic != {}:
        for e_type,e_val in enum_dic.items(): # enum_type:{enum_elm,...}
            out_f.write("\ntypedef enum {\n")
            # for python ctypes struct
            if ctypes_dir:
                py_tmp = "("

            for elm in sorted(e_val):
                out_f.write("{}{},\n".format(pre_tab, elm))
                # for python ctypes struct
                if ctypes_dir:
                    py_tmp += "{}".format(elm + ", ")
            out_f.write("} %s;\n" % e_type)
            # for python ctypes struct
            if ctypes_dir:
                #py_enum += py_tmp[:-3] + ") = " + "map(lambda x:c_uint32(x).value, range(" + str(len(e_val)) + "))\n"
                py_enum += py_tmp[:-3] + ") = " + "range(" + str(len(e_val)) + ")\n"
    # for python ctypes struct
    if ctypes_dir and py_enum:
        with open(ctypes_dir + '/' + super_table_name + ".py", "w") as py_fh:
            py_fh.write("import ctypes\n\n")
            py_fh.write(py_enum)
            py_fh.write("\n")

def build_header_super_table(out_f, super_table_name, tbl_dic, table_dim_dic, pos_shift, tb_access_macros, addr_len_tup, addr_sec, ofs, ctypes_dir):
    """build up table struct header file, tables are grouped/combined as a 'super table'

    Parameters
    ----------
    out_f : str
        name of output file
    super_table_name : str
        table name for the combinded table containing all the tables defined in this .xlsx file
    tbl_dic : dict
        a dictionary: tbl_name as key, tup (tbl_des, bf_blks, sub_tbl_dic, tbl_bitwidth_tup, align) as value
        tbl_des: table description
        bf_blks: bit-field block list, each bit-field block is a list of info for a specific bit-field
        sub_tbl_dic: a dictionary with info about a subtable
        tbl_bitwidth_tup: a tup with bitwidth info for each table
        align: specifying the alignment attribute of this table
    table_dim_dic : dict
        a dimision dictionary: tbl_name as key, tup (sub_tbl_num_max, sub_tbl_entry_num_max) as value
        sub_tbl_num_max: constant, subtable first dimision
        sub_tbl_entry_num_max: constant, subtable second dimision
    pos_shift : int
        position shift for output formating
    tb_access_macros : str
        header file name of table access macros definition
    addr_len_tup : tup
        a tup of (table_address, table_length_in_bytes)
    addr_sec : str
        table address specified as section name
    ofs : str
        offset expressed in hex format 0x
    ctypes_dir: str
        folder to store python ctypes compatible table struct definitions, an empty string means no generation of these definitions

    Returns
    ----------
    None
    """
    pre_tab = ' '*4
    out_f.write('\n')
    if tb_access_macros != None:
        out_f.write("{} {}{}".format('#include', '"' + tb_access_macros, '"\n'))
    out_f.write("{} {}{}".format('#include', '"' + super_table_name.lower(), '_bitfield.h"\n'))
    out_f.write("{} {}{}".format('#include', '"' + super_table_name.lower(), '_const.h"\n'))

    # for python ctypes struct
    if ctypes_dir:
        py_stbl = ""
        py_stbl_body = ""
        py_stbl_addr = ""

    # tbl_dic is only used to make sure to still generate header files and do tests when not all tables listed on address_size_layout
    # are available.
    # Super Table struct:
    for tbl_name, dim_info in table_dim_dic.items():
        if tbl_name in tbl_dic.keys(): # only if it's been processed
            # table_dim_dic = {tbl_name:(A, B), ...]
            out_f.write("\n{} {}{}".format('//', tbl_name, ':\n'))
            out_f.write("typedef struct {\n")
            tbl_dim_const = (tbl_name.upper() + '_SUB_TBL_NUM',  tbl_name.upper() + '_MAX_ENTRY_NUM')
            out_f.write("{5}{0:<{2}} {1}{3}{4};\n".format(tbl_name + '_bf_t', tbl_name, pos_shift, \
                    ('[' + tbl_dim_const[0] + ']', '')[dim_info[0] == 1], \
                    '[' + tbl_dim_const[1] + ']', pre_tab))
            out_f.write("} %s;\n" % (tbl_name + '_t'))
            p_green2('Generated table struct:', tbl_name + '_t')

            # for python ctypes struct
            if ctypes_dir:
                py_tbl_const = (tbl_dim_const[0] + " = " + str(dim_info[0]) + "\n", '')[dim_info[0] == 1] + (tbl_dim_const[1] + " = " + str(dim_info[1]) + "\n", '')[dim_info[1] == 1]
                py_tbl_head = "{}\n{}{}".format("class " + tbl_name + "_t(ctypes.Structure):", pre_tab, "_fields_ = [ ")
                py_tbl_body = "{} {}\n".format('("' + tbl_name + '",',
                        tbl_name + "_bf_t" + (" * " + tbl_dim_const[0], '')[dim_info[0] == 1] + (" * " + tbl_dim_const[1], '')[dim_info[1] == 1] + ") ]" )
                py_stbl += py_tbl_const + py_tbl_head + py_tbl_body + "\n"

    # Super Table struct:
    out_f.write("\n/*\n")
    out_f.write(" {} {}{}".format('*', super_table_name.lower(), ':\n'))
    out_f.write(" */\n")
    out_f.write("typedef struct {\n")
    for tbl_name, dim_info in table_dim_dic.items():
        if tbl_name in tbl_dic.keys():
            out_f.write("{3}{0:<{2}} {1};\n".format(tbl_name + '_t', tbl_name, pos_shift, pre_tab))
            # for python ctypes struct
            if ctypes_dir:
                py_stbl_body += "{}{} {}\n".format(pre_tab*2, '("' + tbl_name + '",', tbl_name + '_t),')

    out_f.write("} %s;\n" % (super_table_name + '_t'))

    if addr_sec != '':
        if addr_sec.startswith('0x'):
            address = addr_sec
        else:
            address = re.sub('\.', '_', addr_sec) + '_start'
            #out_f.write("\n{}".format('extern ' + super_table_name + '_t ' + address + '[1]; // symbol defined in LSP'))
            #address = '&' + address + '[0]'

            # for python ctypes struct
            if ctypes_dir:
                py_stbl_addr = "\n\n# " + super_table_name + " start address: " + address

            out_f.write("\n{}".format('extern ' + super_table_name + '_t ' + address + '; // symbol defined in LSP'))
            #out_f.write("\n{}".format('extern char ' + address + '; // symbol defined in LSP'))
            address = '&' + address
    else:
        address = addr_len_tup[0]
    address = (address + ' + ' + ofs, address)[ofs == '0x0']
    out_f.write("\n{0} {1} {2:>{4}}{3}\n".format('#define', super_table_name.upper() + '_START_ADDRESS',\
        '(', address + ')', set_pos(super_table_name + '_START_ADDRESS', pos_shift)))
    #len_limit = (length, addr_len_tup[1])[length == '0']
    #out_f.write("{0} {1}{2:>{4}}{3}\n".format('#define', super_table_name.upper() + '_SIZE',\
    #    '(', len_limit + ')', set_pos(super_table_name + '_SIZE', pos_shift)))
    out_f.write("\n{}\n".format('#ifndef offsetof'))
    out_f.write("{}".format('#define offsetof(st, m) \\\n'))
    out_f.write("{}{}".format(pre_tab, '((size_t)((char *)&((st *)0)->m - (char *)0))\n'))
    out_f.write('#endif\n')

    # for python ctypes struct
    if ctypes_dir:
        py_stbl_head = "{}\n{}{}\n".format("class " + super_table_name + "_t(ctypes.Structure):", pre_tab, "_fields_ = [")
        py_stbl += py_stbl_head + py_stbl_body[:-2] + " ]" + py_stbl_addr
        with open(ctypes_dir + '/' + super_table_name + ".py", "a") as py_fh:
            py_fh.write(py_stbl)

    # table pointers:
    out_f.write("{}".format('\n// pointers to access each table:\n'))
    out_f.write("{0}{1} {3:>{2}}{4}{5}".format('#define p_', super_table_name, set_pos(super_table_name, pos_shift), '((', super_table_name + '_t *) (', super_table_name.upper() + '_START_ADDRESS))\n'))
    for tbl_name in table_dim_dic.keys():
        if tbl_name in tbl_dic.keys():
            out_f.write("{0}{1} {3:>{2}}{4}{5}{6} {7}{8}".format('#define p_', tbl_name, set_pos(tbl_name, pos_shift), '((', tbl_name + '_t *) ((char *)(', super_table_name.upper() + '_START_ADDRESS) + offsetof(',\
                super_table_name + '_t,', tbl_name, ')))\n'))

def build_header_data(out_f, super_table_name, table_dim_dic, tbl_dic, pos_shift, ext):
    """build up header file for constants and data related to table initialization

    Parameters
    ----------
    out_f : str
        name of output file
    super_table_name : str
        table name for the combinded table containing all the tables defined in this .xlsx file
    table_dim_dic : dict
        a dimision dictionary: tbl_name as key, tup (sub_tbl_num_max, sub_tbl_entry_num_max) as value
        sub_tbl_num_max: constant, subtable first dimision
        sub_tbl_entry_num_max: constant, subtable second dimision
    tbl_dic : dict
        a dictionary: tbl_name as key, tup (tbl_des, bf_blks, sub_tbl_dic, tbl_bitwidth_tup, align) as value
        tbl_des: table description
        bf_blks: bit-field block list, each bit-field block is a list of info for a specific bit-field
        sub_tbl_dic: a dictionary with info about a subtable
        tbl_bitwidth_tup: a tup with bitwidth info for each table
        align: specifying the alignment attribute of this table
    pos_shift : int
        position shift for output formating
    ext : str
        extention to be used for header file macro checker

    Returns
    ----------
    None
    """
    pre_tab = ' '*4
    out_f.write("{} {}{}".format('\n#include', '"' + super_table_name.lower(), '_table.h"\n'))
    for tbl_name, dim_info in table_dim_dic.items():
        if tbl_name in tbl_dic.keys(): # only if it's been processed
            sub_tbl_dic = tbl_dic[tbl_name][2] # {sub_tbl_name:(L, R, sub_tbl_hex, sub_tbl_bf_info), ...}}
            tbl_bitwidth_tup = tbl_dic[tbl_name][3]
            type_bitwidth = tbl_bitwidth_tup[1]
            sub_tbl_num_max = table_dim_dic[tbl_name][0] # A
            sub_tbl_entry_num_max = table_dim_dic[tbl_name][1] # B

            sub_tbl_num_real = min(len(sub_tbl_dic.keys()), sub_tbl_num_max) # <= A
            if sub_tbl_num_max >= 1 and sub_tbl_entry_num_max >= 1:
                out_f.write("\n{} {}\n".format('// Initalization related constants for table', tbl_name))
            sub_tbl_idx = 0
            for sub_tbl_name in sub_tbl_dic.keys():
                L = sub_tbl_dic[sub_tbl_name][0]
                R = sub_tbl_dic[sub_tbl_name][1]
                sub_tbl_max_valid_entry_cnt = (L, L*R)[L != 0]
                if sub_tbl_num_real > 1:
                    out_f.write("{0} {1} {2:>{3}}\n".format('#define', sub_tbl_name.upper(), '(' + str(sub_tbl_idx) + ')', \
                        set_pos(sub_tbl_name, pos_shift + 10)))
                if sub_tbl_entry_num_max > 1:
                    out_f.write("{0} {1} {2:>{3}}\n".format('#define', sub_tbl_name.upper() + '_VALID_ENTRY_NUM', '(' + str(sub_tbl_max_valid_entry_cnt) + ')', \
                        set_pos(sub_tbl_name + '_VALID_ENTRY_NUM', pos_shift + 10)))
                sub_tbl_idx += 1

            shift_pos = type_bitwidth // 4 + 2 # num of half bytes + 2 for '0x'
            # [A][B].value[X]
            # the default values provided in table are in base-type unit
            A = sub_tbl_num_real
            B = sub_tbl_entry_num_max
            X = tbl_bitwidth_tup[2] # tbl_struct_blk_num
            # T: sub_tbl_entry_valid_num: L*R or L+R or L-R
            # L: sub_tbl_entry_num_visable
            # R: sub_tbl_entry_num remain or repeated
            output_wrap = 6 # wrap after 6 basetype size
            size_info_str = "{} {}x{}x({}x{}{})".format('//', A, B, X, type_bitwidth, '-bit')
            if sub_tbl_dic == {}:
                p_red4('Initalization data', 'NOT', 'provided for table', tbl_name)
                out_f.write("{} {} {} {} {}\n".format("#define", (tbl_name + str(ext)).upper(),
                    '{/* No initalization data provided for table', tbl_name, '*/}'))
            else:
                out_f.write("{}\n".format(size_info_str))
                out_f.write("{0} {1} {2}\n".format("#define", (tbl_name + str(ext)).upper(), '{ \\'))
                a = 0 # track num of sub tbl
                for sub_tbl_name in sub_tbl_dic.keys():
                    L = sub_tbl_dic[sub_tbl_name][0]
                    R = sub_tbl_dic[sub_tbl_name][1]
                    hex_vals = sub_tbl_dic[sub_tbl_name][2]
                    XL = X * L
                    for r in range(R):
                        for xl in range(XL):
                            prefix = ('', pre_tab)[xl == 0 and r == 0]
                            prefix0 = ('', '['+ sub_tbl_name.upper() + '] = ') [A > 1 and xl == 0 and r == 0]
                            prefix1 = ('', '{ \\\n' + pre_tab)[A > 1 and r == 0 and xl == 0] # sub tbl start
                            prefix2 = ('', '[' + str(xl // X + r * L) + '].value=') [xl % X == 0 and B >= 1]
                            blk_start = ('', '{')[X > 1 and xl % X == 0]
                            blk_end = ('', '}')[X > 1 and xl % X == X - 1]
                            posfix0 = ('', ', ')[xl < XL - 1 or r < R - 1]
                            posfix1 = ('', '}')[A > 1 and r == R - 1 and xl == XL - 1] # sub tbl end
                            posfix2 = ('', ', \\\n')[xl == XL - 1 and r == R - 1 and a < A - 1]
                            posfix3 = ('', '\\\n' + pre_tab)[(xl + r * XL) % output_wrap == output_wrap - 1 and XL * R / output_wrap > 0 and (xl != XL - 1 or r != R - 1)]
                            out_f.write("{}{}{}{}{}{}{}{}{}{}{}".format(prefix, prefix0, prefix1, prefix2, blk_start, \
                                    hex_vals[xl], blk_end, posfix0, posfix1, posfix2, posfix3))
                    a += 1
                out_f.write("{}".format('}\n'))

