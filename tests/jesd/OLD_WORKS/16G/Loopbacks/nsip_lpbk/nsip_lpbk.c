
/*********************************************************************************************
 *
 * INTEL CONFIDENTIAL
 *
 * Copyright (C) 2022 Intel Corporation
 *
 * This software and the related documents ("Material") are Intel copyrighted materials,
 * and your use of them is governed by the express license under which they were provided
 * to you ("License"). Unless the License provides otherwise, you may not use, modify,
 * copy, publish, distribute, disclose or transmit this software or the related documents
 * without Intel's prior written permission.
 * This software and the related documents are provided as is, with no express or implied
 * warranties, other than those that are expressly stated in the License.
 * No license under any patent, copyright, trade secret or other intellectual property
 * right is granted to or conferred upon you by disclosure or delivery of the Materials,
 * either expressly, by implication, inducement, estoppel or otherwise. Any license under
 * such intellectual property rights must be expressed and approved by Intel in writing.
 *
 *********************************************************************************************/
/**
 * @file    vex_jesd_nsip_lpbk_1s.c
 * @brief   HOST Configuration code for sending the data from VEX to JESD and receving it back.
 * @details 1. Configuration of VEX, JESD and Common Module for sending data from VEX to JESD
 and receving it back to VEX - 8 streams
 2. Evaluate the result written by VEX for the test case evaluation.
 * @TC Description:
 1. 32K samples (1K vectors) for given data rate will be streamed to JESD from
 configured VEX core 0.
 2. With JESD NSIP loop back enabled the data looped back at sample interface
 is expected to reach VEX core 1 
 3.8 streams of Data sent from Vex 0 is compared to the data received at Vex 1. 
 The flit count at Vex CIO2STRM, JESD B2H, JESD H2B and Vex STRM2CIO are also expected to be incrementing.
 */

/*********************************************************************************************
 * LOCAL INCLUDE STATEMENTS                    *
 *********************************************************************************************/
#define HIVE_MULTIPLE_PROGRAMS
#include "srp.h"
#include <stdio.h>
#include <stdbool.h>
#include <srp_vex.h>
#include "logger.h"
#include "common_functions.h"
#include "nsip_hbi.h"
#include "ve32_cell.h"
#include "srp_block_ids.h"
#include "cli.h"
#include "init.h"
#include "all_comps.h"
#include<time.h> 
#include "vex_fw/sim_m64/jesd_tx.map.h"

enum jesdUsecasenum{UC2B,UC3B,UC5C,UC3A,UC7C,UC2C,UC3D};

typedef struct jesdConfig_t {
    int jesdUsecase;
    int jesdTxncs;
    int jesdEn;
    int jesdTestmode;
    int jesdFecCrc;
    int jesdBitordertx;
    int jesdBitorderrx;
    int jesdShth;
    int jesdEmbth;
}jesdConfig_t;

struct  flow_params_t {
    int vexCount;
    int nsipCount;
    jesdConfig_t jesdConfig;
}flow_params;

int vexCount = 1;
int nsipCount = 1;

/***********************************************
 * LOCAL/PRIVATE TYPEDEFS (structs, enums)     *
 ***********************************************/
typedef struct register_config_tbl_s {
    uint32_t offset;
    uint32_t value;
    uint32_t mask;
    char *name;
} register_config_tbl_t;

/***********************************************
 * LOCAL/PRIVATE MACROS AND DEFINES            *
 ***********************************************/
#define NUM_TOTAL_VEC_PER_STREAM 64
#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
#define NUM_OF_ELEMENTS_PER_VEC 32
#define APB_OFFSET_GEN(apb_num) (apb_num * 0x20000)
#define CIO2STRM_INT_EN_VALUE 0x3F
#define CIO2STRM_FIFO_STATUS_CTL_VALUE 0x00000001
#define CIO2STRM_WORD_CNT_CTL_VALUE 0x00000001
#define STRM2CIO_INT_ENABLE_VALUE 0xF
#define STRM2CIO_FIFO_STATUS_CTL_VALUE 0x00000001
#define STRM2CIO_WORD_CNT_CTL_VALUE 0x00000001
#define NSIP_HBI_INT_CSR_INT_VALUE 0xFFFFF
#define FIFO_CONTROL_VALUE 0x00000184
#define CREDIT_CS_VALUE 0x8
#define MISC_CTRL_VALUE 0x0
#define CSR_INT_VALUE 0xFFFFFFFF



/***********************************************
 * GLOBAL DATA DEFINITIONS (consts, vars)      *
 ***********************************************/
// VEX 0 table 0 
static const register_config_tbl_t g_cio2strm_0_config_tbl[] = 
{
	// INT Enable
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_INT_ENABLE_OFFSET, CIO2STRM_INT_EN_VALUE, \
        CIO2STRM_MEM_CIO2STRM_INT_ENABLE_WR_MASK, "CIO2STRM_INT_ENABLE"},

    //VE00 cio2strm
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_FIFO_STATUS_CTL_OFFSET, CIO2STRM_FIFO_STATUS_CTL_VALUE,
        CIO2STRM_MEM_CIO2STRM_FIFO_STATUS_CTL_WR_MASK, "CIO2STRM_FIFO_STATUS_CTL"},

    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_WORD_CNT_CTL_OFFSET, CIO2STRM_WORD_CNT_CTL_VALUE, CIO2STRM_MEM_CIO2STRM_WORD_CNT_CTL_WR_MASK, \
        "CIO2STRM_WORD_CNT_CTL"},

    // Enables 8 streams from vex core to CRUX -0xff
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_RANGE_EN_OFFSET, 0x0000000ff, 0xFF, \
        "CIO2STRM_RANGE_EN_vijay"},

    //MEM_ADDR_LOW[0] - [31-17] destination ID,[16-0] bits local address as seen from STRM2CIO
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW0_OFFSET, 0x00000000, \
        CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW_WR_MASK, "CIO2STRM_MEM_ADDR_LOW0"},
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH0_OFFSET, 0x1FFFF, \
        CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH_WR_MASK, "CIO2STRM_MEM_ADDR_HIGH0"},
    //MEM_OFFSET[0]- is in bytes
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_OFFSET0_OFFSET, 0x00000000, CIO2STRM_MEM_CIO2STRM_MEM_OFFSET_WR_MASK, \
        "CIO2STRM_MEM_OFFSET0"},
    //STRM_DEST[0] - mapped to JESD_0
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_STRM_DEST0_OFFSET, 0x00000040, CIO2STRM_MEM_CIO2STRM_STRM_DEST_WR_MASK, \
        "CIO2STRM_STRM_DEST0"},
		
	//MEM_ADDR_LOW[1] - [31-17] destination ID,[16-0] bits local address as seen from STRM2CIO
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW1_OFFSET, 0x20000, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW_WR_MASK, \
        "CIO2STRM_MEM_ADDR_LOW1"},
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH1_OFFSET, 0x3FFFF, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH_WR_MASK, \
        "CIO2STRM_MEM_ADDR_HIGH1"},
    //MEM_OFFSET[1]- is in words
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_OFFSET1_OFFSET, 0x00000000, CIO2STRM_MEM_CIO2STRM_MEM_OFFSET_WR_MASK, \
        "CIO2STRM_MEM_OFFSET1"},
    //STRM_DEST[1] - mapped to JESD_Port_0
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_STRM_DEST1_OFFSET, 0x00000040, CIO2STRM_MEM_CIO2STRM_STRM_DEST_WR_MASK, \
        "CIO2STRM_STRM_DEST1"},

    //MEM_ADDR_LOW[2] - [31-17] destination ID,[16-0] bits local address as seen from STRM2CIO
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW2_OFFSET, 0x40000, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW_WR_MASK, \
        "CIO2STRM_MEM_ADDR_LOW2"},
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH2_OFFSET, 0x5FFFF, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH_WR_MASK, \
        "CIO2STRM_MEM_ADDR_HIGH2"},
    //MEM_OFFSET[2]- is in words
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_OFFSET2_OFFSET, 0x00000000, CIO2STRM_MEM_CIO2STRM_MEM_OFFSET_WR_MASK, \
        "CIO2STRM_MEM_OFFSET2"},
    //STRM_DEST[2] - mapped to JESD_Port_0
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_STRM_DEST2_OFFSET, 0x00000040, CIO2STRM_MEM_CIO2STRM_STRM_DEST_WR_MASK, \
        "CIO2STRM_STRM_DEST2"},

    //MEM_ADDR_LOW[3] - [31-17] destination ID,[16-0] bits local address as seen from STRM2CIO
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW3_OFFSET, 0x60000, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW_WR_MASK, \
        "CIO2STRM_MEM_ADDR_LOW3"},
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH3_OFFSET, 0x7FFFF, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH_WR_MASK, \
        "CIO2STRM_MEM_ADDR_HIGH3"},
    //MEM_OFFSET[3]- is in words
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_OFFSET3_OFFSET, 0x00000000, CIO2STRM_MEM_CIO2STRM_MEM_OFFSET_WR_MASK, \
        "CIO2STRM_MEM_OFFSET3"},
    //STRM_DEST[3] - mapped to JESD_Port_0
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_STRM_DEST3_OFFSET, 0x00000040, CIO2STRM_MEM_CIO2STRM_STRM_DEST_WR_MASK, \
        "CIO2STRM_STRM_DEST3"},

    //MEM_ADDR_LOW[4] - [31-17] destination ID,[16-0] bits local address as seen from STRM2CIO
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW4_OFFSET, 0x80000, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW_WR_MASK, \
        "CIO2STRM_MEM_ADDR_LOW4"},
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH4_OFFSET, 0x9FFFF, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH_WR_MASK, \
        "CIO2STRM_MEM_ADDR_HIGH4"},
    //MEM_OFFSET[4]- is in words
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_OFFSET4_OFFSET, 0x00000000, CIO2STRM_MEM_CIO2STRM_MEM_OFFSET_WR_MASK, \
        "CIO2STRM_MEM_OFFSET4"},
    //STRM_DEST[4] - mapped to JESD_Port_0
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_STRM_DEST4_OFFSET, 0x00000040, CIO2STRM_MEM_CIO2STRM_STRM_DEST_WR_MASK, \
        "CIO2STRM_STRM_DEST4"},

    //MEM_ADDR_LOW[5] - [31-17] destination ID,[16-0] bits local address as seen from STRM2CIO
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW5_OFFSET, 0xA0000, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW_WR_MASK, \
        "CIO2STRM_MEM_ADDR_LOW5"},
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH5_OFFSET, 0xBFFFF, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH_WR_MASK, \
        "CIO2STRM_MEM_ADDR_HIGH5"},
    //MEM_OFFSET[5]- is in words
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_OFFSET5_OFFSET, 0x00000000, CIO2STRM_MEM_CIO2STRM_MEM_OFFSET_WR_MASK, \
        "CIO2STRM_MEM_OFFSET5"},
    //STRM_DEST[5] - mapped to JESD_Port_0
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_STRM_DEST5_OFFSET, 0x00000040, CIO2STRM_MEM_CIO2STRM_STRM_DEST_WR_MASK, \
        "CIO2STRM_STRM_DEST5"},

    //MEM_ADDR_LOW[6] - [31-17] destination ID,[16-0] bits local address as seen from STRM2CIO
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW6_OFFSET, 0xC0000, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW_WR_MASK, \
        "CIO2STRM_MEM_ADDR_LOW6"},
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH6_OFFSET, 0xDFFFF, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH_WR_MASK, \
        "CIO2STRM_MEM_ADDR_HIGH6"},
    //MEM_OFFSET[6]- is in words
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_OFFSET6_OFFSET, 0x00000000, CIO2STRM_MEM_CIO2STRM_MEM_OFFSET_WR_MASK, \
        "CIO2STRM_MEM_OFFSET6"},
    //STRM_DEST[6] - mapped to JESD_Port_0
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_STRM_DEST6_OFFSET, 0x00000040, CIO2STRM_MEM_CIO2STRM_STRM_DEST_WR_MASK, \
        "CIO2STRM_STRM_DEST6"},

    //MEM_ADDR_LOW[7] - [31-17] destination ID,[16-0] bits local address as seen from STRM2CIO
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW7_OFFSET, 0xE0000, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_LOW_WR_MASK, \
        "CIO2STRM_MEM_ADDR_LOW7"},
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH7_OFFSET, 0xFFFFF, CIO2STRM_MEM_CIO2STRM_MEM_ADDR_HIGH_WR_MASK, \
        "CIO2STRM_MEM_ADDR_HIGH7"},
    //MEM_OFFSET[7]- is in words
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_MEM_OFFSET7_OFFSET, 0x00000000, CIO2STRM_MEM_CIO2STRM_MEM_OFFSET_WR_MASK, \
        "CIO2STRM_MEM_OFFSET7"},
    //STRM_DEST[7] - mapped to JESD_Port_0
    {VEXABC0_C2S_CIO2STRM_BASE + CIO2STRM_MEM_CIO2STRM_STRM_DEST7_OFFSET, 0x00000040, CIO2STRM_MEM_CIO2STRM_STRM_DEST_WR_MASK, \
        "CIO2STRM_STRM_DEST7"},
    
};

// VEX1 table-1
static register_config_tbl_t g_cio2strm_1_config_tbl[] = 
{

};

// VEX0 table1
static register_config_tbl_t g_cio2strm_config_tbl[] = 
{

};


//8 Streams U-2b==1 VEX entry; U-3b== 1 VEX entry; U-5c==1 VEX entry;  -> g_cio2strm_0_config_tbl
//4 Streams U-3a==1 VEX entry; U-7c== 1 VEX entry; -> g_cio2strm_config_tbl
//16 Streams U-2c==2 VEX entries; U-3d== 2 VEX entries; -> g_cio2strm_0_config_tbl,g_cio2strm_1_config_tbl

static register_config_tbl_t* vexConfigArray[9] = {	g_cio2strm_0_config_tbl, g_cio2strm_0_config_tbl, g_cio2strm_0_config_tbl,
													g_cio2strm_config_tbl, g_cio2strm_config_tbl,
													g_cio2strm_0_config_tbl, g_cio2strm_1_config_tbl, g_cio2strm_0_config_tbl, g_cio2strm_1_config_tbl};
static int vexConfigArraySize[9] = {	ARRAY_SIZE(g_cio2strm_0_config_tbl),ARRAY_SIZE(g_cio2strm_0_config_tbl),ARRAY_SIZE(g_cio2strm_0_config_tbl),
										ARRAY_SIZE(g_cio2strm_config_tbl),ARRAY_SIZE(g_cio2strm_config_tbl),
										ARRAY_SIZE(g_cio2strm_0_config_tbl),ARRAY_SIZE(g_cio2strm_1_config_tbl), ARRAY_SIZE(g_cio2strm_0_config_tbl),ARRAY_SIZE(g_cio2strm_1_config_tbl)};

static int vexCountStartIdxTbl[2];

#if 0
//NSIP table-0
static register_config_tbl_t g_cm_0_config_tbl[] = {};

//NSIP table-1 
static register_config_tbl_t g_cm_1_config_tbl[] = {};

//8 Streams U-2b, U-3b, U-5c
//4 Streams U-3a, U-7c
//16 Streams U-2c, U-3d 1 NSIP entry 

static register_config_tbl_t* nsipConfigArray[2] = {g_cm_0_config_tbl, g_cm_1_config_tbl};
static int nsipConfigArraySize[2] = {ARRAY_SIZE(g_cm_0_config_tbl),ARRAY_SIZE(g_cm_1_config_tbl)};
#endif


//static int nsipConfigArraySize[2] = {ARRAY_SIZE(g_cm_0_config_tbl),ARRAY_SIZE(g_cm_1_config_tbl)};
register_config_tbl_t g_vex_noc_config[] = {
    {0x94, 0, 0, "NOC_CLK_GATE"},
    {0x98, 0, 0, "NOC_SOFT_RESET"}
};

/*
   register_config_tbl_t g_jesd_reset_config[] = {
   {0x184, 0, 0, "JESD_SOFT_RESET"},
   {0x184, 0, 0, "JESD_SOFT_RESET"}
   };
   */

/***********************************************
 * STATIC FUNCTION PROTOTYPES                  *
 ***********************************************/
int configure_jesd_host(int, int [], int, int[], int, int);



/***********************************************
 * STATIC FUNCTION DEFINITIONS                 *
 ***********************************************/
/**
 * @brief           Function for noc reset
 * @param [in]      srp
 * @return          status value
 */

static int release_reset_abc_noc (void *srp)
{
int i, rv = 0, flags = 0;
for (i = 0; i < ARRAY_SIZE(g_vex_noc_config); i++)
{
    rv = srp_dev_block_write32(srp,
            SRP_BLOCK_VEX_CFG_CTRL,
            0,
            g_vex_noc_config[i].offset,
            &g_vex_noc_config[i].value,
            1,
            flags);
    }
    return rv;
}

static int configure_jesd_b2h()
{
    //================
    //NSIP_HBI config
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_INTR_INT_HIGH_EN_OFFSET, NSIP_HBI_INTR_INT_HIGH_EN_DEFAULT, NSIP_HBI_INT_CSR_INT_VALUE, NSIP_HBI_INT_CSR_INT_VALUE, NSIP_HBI_INTR_INT_HIGH_EN_RD_MASK, NSIP_HBI_INTR_INT_HIGH_EN_WR_MASK, "NSIP_HBI_INTR_INT_HIGH_EN");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_INTR_INT_LOW_EN_OFFSET, NSIP_HBI_INTR_INT_LOW_EN_DEFAULT, NSIP_HBI_INT_CSR_INT_VALUE, NSIP_HBI_INT_CSR_INT_VALUE, NSIP_HBI_INTR_INT_LOW_EN_RD_MASK, NSIP_HBI_INTR_INT_LOW_EN_WR_MASK, "NSIP_HBI_INTR_INT_LOW_EN");

    // H2B Registers
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL_OFFSET,NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL_DEFAULT , FIFO_CONTROL_VALUE, FIFO_CONTROL_VALUE, NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL_RD_MASK, NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL_WR_MASK, "NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_CREDIT_READY_CS_OFFSET, NSIP_HBI_H2B_CREDIT_READY_CS_DEFAULT, CREDIT_CS_VALUE, CREDIT_CS_VALUE, NSIP_HBI_H2B_CREDIT_READY_CS_RD_MASK, NSIP_HBI_H2B_CREDIT_READY_CS_WR_MASK, "NSIP_HBI_H2B_CREDIT_READY_CS");

    // These are for Buffer S0
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_TBL0_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_DEFAULT, 0x80000000, 0x80000000, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_TBL0_OFFSET");
    // Mask was set for total 2K flits in words
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL0_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_DEFAULT, 0x1ffff, 0x1ffff, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL0_OFFSET");
   
	  // These are for Buffer S1 
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_TBL1_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_DEFAULT, 0x80020000, 0x80020000, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_TBL1_OFFSET");
    // Mask was set for total 2K flits in words
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL1_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_DEFAULT, 0x1ffff, 0x1ffff, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL1_OFFSET");

    // These are for Buffer S2
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_TBL2_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_DEFAULT, 0x80040000, 0x80040000, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_TBL2_OFFSET");
    // Mask was set for total 2K flits in words
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL2_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_DEFAULT, 0x1ffff, 0x1ffff, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL2_OFFSET");

    // These are for Buffer S3
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_TBL3_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_DEFAULT, 0x80060000, 0x80060000, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_TBL3_OFFSET");
    // Mask was set for total 2K flits in words
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL3_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_DEFAULT, 0x1ffff, 0x1ffff, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL3_OFFSET");

    // These are for Buffer S4
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_TBL4_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_DEFAULT, 0x80080000, 0x80080000, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_TBL4_OFFSET");
    // Mask was set for total 2K flits in words
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL4_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_DEFAULT, 0x1ffff, 0x1ffff, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL4_OFFSET");

    // These are for Buffer S5
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_TBL5_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_DEFAULT, 0x800a0000, 0x800a0000, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_TBL5_OFFSET");
    // Mask was set for total 2K flits in words
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL5_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_DEFAULT, 0x1ffff, 0x1ffff, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL5_OFFSET");

    // These are for Buffer S6
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_TBL6_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_DEFAULT, 0x800c0000, 0x800c0000, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_TBL6_OFFSET");
    // Mask was set for total 2K flits in words
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL6_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_DEFAULT, 0x1ffff, 0x1ffff, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL6_OFFSET");

    // These are for Buffer S7
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_TBL7_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_DEFAULT, 0x800e0000, 0x800e0000, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_TBL7_OFFSET");
    // Mask was set for total 2K flits in words
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL7_OFFSET, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_DEFAULT, 0x1ffff, 0x1ffff, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_RD_MASK, NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL_WR_MASK, "NSIP_HBI_B2H_CSR_B2H_ADDR_MASK_TBL7_OFFSET");

}

static int configure_jesd_h2b()
{
    //================
    //NSIP_HBI config
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_INTR_INT_HIGH_EN_OFFSET, NSIP_HBI_INTR_INT_HIGH_EN_DEFAULT, NSIP_HBI_INT_CSR_INT_VALUE, NSIP_HBI_INT_CSR_INT_VALUE, NSIP_HBI_INTR_INT_HIGH_EN_RD_MASK, NSIP_HBI_INTR_INT_HIGH_EN_WR_MASK, "NSIP_HBI_INTR_INT_HIGH_EN");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_INTR_INT_LOW_EN_OFFSET, NSIP_HBI_INTR_INT_LOW_EN_DEFAULT, NSIP_HBI_INT_CSR_INT_VALUE, NSIP_HBI_INT_CSR_INT_VALUE, NSIP_HBI_INTR_INT_LOW_EN_RD_MASK, NSIP_HBI_INTR_INT_LOW_EN_WR_MASK, "NSIP_HBI_INTR_INT_LOW_EN");

    // H2B Registers
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL_OFFSET,NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL_DEFAULT , FIFO_CONTROL_VALUE, FIFO_CONTROL_VALUE, NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL_RD_MASK, NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL_WR_MASK, "NSIP_HBI_H2B_FF_H2B_FIFO_CONTROL");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_CREDIT_READY_CS_OFFSET, NSIP_HBI_H2B_CREDIT_READY_CS_DEFAULT, CREDIT_CS_VALUE, CREDIT_CS_VALUE, NSIP_HBI_H2B_CREDIT_READY_CS_RD_MASK, NSIP_HBI_H2B_CREDIT_READY_CS_WR_MASK, "NSIP_HBI_H2B_CREDIT_READY_CS");

    //Sending all data to VEX1
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ROUTE_LKUP_TBL0_OFFSET, NSIP_HBI_H2B_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ROUTE_LKUP_TBL_WR_MASK, "H2B_ROUTE_LKUP_TBL0");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ADDR_LKUP_TBL0_OFFSET, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_DEFAULT, 0x18000, 0x18000, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ADDR_LKUP_TBL0");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL0_OFFSET, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL0");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_MD_CONTROL_TBL0_OFFSET, NSIP_HBI_H2B_MD_CONTROL_TBL_DEFAULT, 0x7, 0x7, NSIP_HBI_H2B_MD_CONTROL_TBL_RD_MASK, NSIP_HBI_H2B_MD_CONTROL_TBL_WR_MASK, "NSIP_HBI_H2B_MD_CONTROL_TBL0");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ADDR_LKUP_TBL0_OFFSET, NSIP_HBI_H2B_ADDR_LKUP_TBL_DEFAULT, 0x80001000, 0x80001000, NSIP_HBI_H2B_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ADDR_LKUP_TBL_WR_MASK, "H2B_ADDR_LKUP_TBL0");
    
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ROUTE_LKUP_TBL1_OFFSET, NSIP_HBI_H2B_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ROUTE_LKUP_TBL_WR_MASK, "H2B_ROUTE_LKUP_TBL1");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ADDR_LKUP_TBL1_OFFSET, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_DEFAULT, 0x18004, 0x18004, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ADDR_LKUP_TBL1");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL1_OFFSET, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL1");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_MD_CONTROL_TBL1_OFFSET, NSIP_HBI_H2B_MD_CONTROL_TBL_DEFAULT, 0x7, 0x7, NSIP_HBI_H2B_MD_CONTROL_TBL_RD_MASK, NSIP_HBI_H2B_MD_CONTROL_TBL_WR_MASK, "NSIP_HBI_H2B_MD_CONTROL_TBL1");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ADDR_LKUP_TBL1_OFFSET, NSIP_HBI_H2B_ADDR_LKUP_TBL_DEFAULT, 0x80001200, 0x80001200, NSIP_HBI_H2B_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ADDR_LKUP_TBL_WR_MASK, "H2B_ADDR_LKUP_TBL1");

    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ROUTE_LKUP_TBL2_OFFSET, NSIP_HBI_H2B_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ROUTE_LKUP_TBL_WR_MASK, "H2B_ROUTE_LKUP_TBL2");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ADDR_LKUP_TBL2_OFFSET, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_DEFAULT, 0x18008, 0x18008, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ADDR_LKUP_TBL2");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL2_OFFSET, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL2");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_MD_CONTROL_TBL2_OFFSET, NSIP_HBI_H2B_MD_CONTROL_TBL_DEFAULT, 0x7, 0x7, NSIP_HBI_H2B_MD_CONTROL_TBL_RD_MASK, NSIP_HBI_H2B_MD_CONTROL_TBL_WR_MASK, "NSIP_HBI_H2B_MD_CONTROL_TBL2");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ADDR_LKUP_TBL2_OFFSET, NSIP_HBI_H2B_ADDR_LKUP_TBL_DEFAULT, 0x80001400, 0x80001400, NSIP_HBI_H2B_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ADDR_LKUP_TBL_WR_MASK, "H2B_ADDR_LKUP_TBL2");

    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ROUTE_LKUP_TBL3_OFFSET, NSIP_HBI_H2B_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ROUTE_LKUP_TBL_WR_MASK, "H2B_ROUTE_LKUP_TBL3");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ADDR_LKUP_TBL3_OFFSET, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_DEFAULT, 0x1800c, 0x1800c, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ADDR_LKUP_TBL3");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL3_OFFSET, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL3");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_MD_CONTROL_TBL3_OFFSET, NSIP_HBI_H2B_MD_CONTROL_TBL_DEFAULT, 0x7, 0x7, NSIP_HBI_H2B_MD_CONTROL_TBL_RD_MASK, NSIP_HBI_H2B_MD_CONTROL_TBL_WR_MASK, "NSIP_HBI_H2B_MD_CONTROL_TBL3");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ADDR_LKUP_TBL3_OFFSET, NSIP_HBI_H2B_ADDR_LKUP_TBL_DEFAULT, 0x80001600, 0x80001600, NSIP_HBI_H2B_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ADDR_LKUP_TBL_WR_MASK, "H2B_ADDR_LKUP_TBL3");

    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ROUTE_LKUP_TBL4_OFFSET, NSIP_HBI_H2B_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ROUTE_LKUP_TBL_WR_MASK, "H2B_ROUTE_LKUP_TBL4");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ADDR_LKUP_TBL4_OFFSET, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_DEFAULT, 0x18010, 0x18010, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ADDR_LKUP_TBL4");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL4_OFFSET, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL4");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_MD_CONTROL_TBL4_OFFSET, NSIP_HBI_H2B_MD_CONTROL_TBL_DEFAULT, 0x7, 0x7, NSIP_HBI_H2B_MD_CONTROL_TBL_RD_MASK, NSIP_HBI_H2B_MD_CONTROL_TBL_WR_MASK, "NSIP_HBI_H2B_MD_CONTROL_TBL4");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ADDR_LKUP_TBL4_OFFSET, NSIP_HBI_H2B_ADDR_LKUP_TBL_DEFAULT, 0x80001800, 0x80001800, NSIP_HBI_H2B_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ADDR_LKUP_TBL_WR_MASK, "H2B_ADDR_LKUP_TBL4");

    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ROUTE_LKUP_TBL5_OFFSET, NSIP_HBI_H2B_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ROUTE_LKUP_TBL_WR_MASK, "H2B_ROUTE_LKUP_TBL5");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ADDR_LKUP_TBL5_OFFSET, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_DEFAULT, 0x18014, 0x18014, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ADDR_LKUP_TBL5");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL5_OFFSET, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL5");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_MD_CONTROL_TBL5_OFFSET, NSIP_HBI_H2B_MD_CONTROL_TBL_DEFAULT, 0x7, 0x7, NSIP_HBI_H2B_MD_CONTROL_TBL_RD_MASK, NSIP_HBI_H2B_MD_CONTROL_TBL_WR_MASK, "NSIP_HBI_H2B_MD_CONTROL_TBL5");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ADDR_LKUP_TBL5_OFFSET, NSIP_HBI_H2B_ADDR_LKUP_TBL_DEFAULT, 0x80001a00, 0x80001a00, NSIP_HBI_H2B_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ADDR_LKUP_TBL_WR_MASK, "H2B_ADDR_LKUP_TBL5");

    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ROUTE_LKUP_TBL6_OFFSET, NSIP_HBI_H2B_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ROUTE_LKUP_TBL_WR_MASK, "H2B_ROUTE_LKUP_TBL6");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ADDR_LKUP_TBL6_OFFSET, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_DEFAULT, 0x18018, 0x18018, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ADDR_LKUP_TBL6");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL6_OFFSET, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL6");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_MD_CONTROL_TBL6_OFFSET, NSIP_HBI_H2B_MD_CONTROL_TBL_DEFAULT, 0x7, 0x7, NSIP_HBI_H2B_MD_CONTROL_TBL_RD_MASK, NSIP_HBI_H2B_MD_CONTROL_TBL_WR_MASK, "NSIP_HBI_H2B_MD_CONTROL_TBL6");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ADDR_LKUP_TBL6_OFFSET, NSIP_HBI_H2B_ADDR_LKUP_TBL_DEFAULT, 0x80001c00, 0x80001c00, NSIP_HBI_H2B_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ADDR_LKUP_TBL_WR_MASK, "H2B_ADDR_LKUP_TBL6");

    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ROUTE_LKUP_TBL7_OFFSET, NSIP_HBI_H2B_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ROUTE_LKUP_TBL_WR_MASK, "H2B_ROUTE_LKUP_TBL7");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ADDR_LKUP_TBL7_OFFSET, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_DEFAULT, 0x1801c, 0x1801c, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ADDR_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ADDR_LKUP_TBL7");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL7_OFFSET, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_DEFAULT, 0x1, 0x1, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL_WR_MASK, "NSIP_HBI_H2B_TK_ROUTE_LKUP_TBL7");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_MD_CONTROL_TBL7_OFFSET, NSIP_HBI_H2B_MD_CONTROL_TBL_DEFAULT, 0x7, 0x7, NSIP_HBI_H2B_MD_CONTROL_TBL_RD_MASK, NSIP_HBI_H2B_MD_CONTROL_TBL_WR_MASK, "NSIP_HBI_H2B_MD_CONTROL_TBL7");
    write_read_expect_18a(DLNK_JESDABC0_NSIP_HBI_CSR_BASE+NSIP_HBI_H2B_ADDR_LKUP_TBL7_OFFSET, NSIP_HBI_H2B_ADDR_LKUP_TBL_DEFAULT, 0x80001e00, 0x80001e00, NSIP_HBI_H2B_ADDR_LKUP_TBL_RD_MASK, NSIP_HBI_H2B_ADDR_LKUP_TBL_WR_MASK, "H2B_ADDR_LKUP_TBL7");
}

/***********************************************
 * GLOBAL FUNCTION DEFINITIONS                 *
 ***********************************************/

/**
 * @brief           Function configuring all the required registers from host
 * @param [in]      Vex Id, Jesd Id, APB Id and SYS_RATE_IQ_P5
 * @return          status
 */
// static register_config_tbl_t* ptr;
int configure_jesd_host(int vexCount, int vexId[], int nsipCount, int nsipId[], int apb_num, int cm_num)
{
    int vexIdx,j,k,rv = 0;
    int i=0;
    int nsipIdx = 0;

    for (vexIdx = vexCountStartIdxTbl[vexCount-1]; vexIdx < vexCount+vexCountStartIdxTbl[vexCount-1]; vexIdx++)
    {
        for (j = 0; j < vexConfigArraySize[vexIdx]; j++)
        {

            if (rv = write_reg_18a(vexConfigArray[vexIdx][j].offset + (0x40000*vexIdx), vexConfigArray[vexIdx][j].value, \
                        vexConfigArray[vexIdx][j].mask, vexConfigArray[vexIdx][j].name))
                return rv;
        }
        printf("INFO: Vex %d cio2strm configuration completed", vexIdx);
    }

    //Hardcoding nsip registers for usecase 5c 1 stream, for now, will update automation later
    printf("###vexcount is = %d\n", vexCount);
    printf("###nsipCount is = %d\n", nsipCount);
    configure_jesd_b2h();
    configure_jesd_h2b();
    return rv;
}

fpga_clk_and_sysref_period()
{
    system("frioPciWrite -F s5a1 -P 0x20000 0x10");
    system("frioPciWrite -F s5b1 -P 0x20000 0x10");
    system("frioPciWrite -F s5a1 -P 0x20004 0x1900190");
    system("frioPciWrite -F s5b1 -P 0x20004 0x1900190");

    //enable jesd_ip path or serial or parallel lpbk
    system("frioPciWrite -F s5a3 -P 0x20000 0x02"); //IP
    //system("frioPciWrite -F s5a3 -P 0x20000 0x0"); //Serial
    //system("frioPciWrite -F s5a3 -P 0x20000 0x01"); //Parallel
}

fpga_provided_sysref()
{
   //enable sysref
    system("frioPciWrite -F s5a1 -P 0x20000 0x90");
    system("frioPciWrite -F s5b1 -P 0x20000 0x90");
}

static void delay(unsigned int milliseconds){

    clock_t start = clock();
    while((clock() - start) * 1000 / CLOCKS_PER_SEC < milliseconds);
}

// JESD CMN CSR reg
//18A For 16G usecases JESD CMN CSR reg == 0x6(U-5C)
static int program_cmn_csr_tx_registers()
{
    int i=0;
    uint32_t base_address_cmn[] = {DLNK_JESDABC0_CMN_CSR_BASE,  DLNK_JESDABC1_CMN_CSR_BASE,  DLNK_JESDABC2_CMN_CSR_BASE,  DLNK_JESDABC3_CMN_CSR_BASE};
    printf("JESD CMN CSR CONFIG : program_cmn_csr_registers \n");

    for(i=0; i<1; i++)
    {
        write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_NUM_VALID_STR_OFFSET, JESDABC_CMN_CSR_MEM_TX_NUM_VALID_STR_DEFAULT, 0x000000ff, 0x000000ff, JESDABC_CMN_CSR_MEM_TX_NUM_VALID_STR_RD_MASK, JESDABC_CMN_CSR_MEM_TX_NUM_VALID_STR_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_NUM_VALID_STR");
        write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_IP_CLK_CTRL_OFFSET, JESDABC_CMN_CSR_MEM_TX_IP_CLK_CTRL_DEFAULT, 0x00000018, 0x00000018, JESDABC_CMN_CSR_MEM_TX_IP_CLK_CTRL_RD_MASK, JESDABC_CMN_CSR_MEM_TX_IP_CLK_CTRL_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_IP_CLK_CTRL");
        write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_SYSREF_TSAD_OFFSET, JESDABC_CMN_CSR_MEM_TX_SYSREF_TSAD_DEFAULT, 0x00000017, 0x00000017, JESDABC_CMN_CSR_MEM_TX_SYSREF_TSAD_RD_MASK, JESDABC_CMN_CSR_MEM_TX_SYSREF_TSAD_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_SYSREF_TSAD");

        //bits 0-15 -> 1b, bits 16-31 -> b, so total is 0x0b001b
        write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_SYNC_POINT_CTRL_OFFSET, JESDABC_CMN_CSR_MEM_TX_SYNC_POINT_CTRL_DEFAULT, 0x00170023, 0x00170023, JESDABC_CMN_CSR_MEM_TX_SYNC_POINT_CTRL_RD_MASK, JESDABC_CMN_CSR_MEM_TX_SYNC_POINT_CTRL_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_SYNC_POINT_CTRL");
        write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_BFN_SYSREF_TSAD_OFFSET, JESDABC_CMN_CSR_MEM_TX_BFN_SYSREF_TSAD_DEFAULT, 0x00000017, 0x00000017, JESDABC_CMN_CSR_MEM_TX_BFN_SYSREF_TSAD_RD_MASK, JESDABC_CMN_CSR_MEM_TX_BFN_SYSREF_TSAD_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_BFN_SYSREF_TSAD");
        write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CTRL_OFFSET, JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CTRL_DEFAULT, 0x00170023, 0x00170023, JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CTRL_RD_MASK, JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CTRL_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CTRL");

        //this register can be ingnored as per RP, roshan 12/02/24
        //write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_CLK_1P5G_DIV_ENABLE_OFFSET, JESDABC_CMN_CSR_MEM_TX_CLK_1P5G_DIV_ENABLE_DEFAULT, 0x00000001, 0x00000001, JESDABC_CMN_CSR_MEM_TX_CLK_1P5G_DIV_ENABLE_RD_MASK, JESDABC_CMN_CSR_MEM_RX_CLK_1P5G_DIV_ENABLE_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_CLK_1P5G_DIV_ENABLE");
        write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_CLK_GEN_ENABLE_OFFSET, JESDABC_CMN_CSR_MEM_TX_CLK_GEN_ENABLE_DEFAULT, 0x00000001, 0x00000001, JESDABC_CMN_CSR_MEM_TX_CLK_GEN_ENABLE_RD_MASK, JESDABC_CMN_CSR_MEM_TX_CLK_GEN_ENABLE_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_CLK_GEN_ENABLE");
            
        //this register can be ingnored as per RP, roshan 12/02/24
        //write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_RX_SYNC_POINT_CNT_ENABLE_OFFSET, JESDABC_CMN_CSR_MEM_RX_SYNC_POINT_CNT_ENABLE_DEFAULT, 0x00000001, 0x00000001, JESDABC_CMN_CSR_MEM_RX_SYNC_POINT_CNT_ENABLE_RD_MASK, JESDABC_CMN_CSR_MEM_RX_SYNC_POINT_CNT_ENABLE_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_SYNC_POINT_CNT_ENABLE");
        write_read_expect_18a(base_address_cmn[i]+JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CNT_ENABLE_OFFSET, JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CNT_ENABLE_DEFAULT, 0x00000001, 0x00000001, JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CNT_ENABLE_RD_MASK, JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CNT_ENABLE_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_BFN_SYNC_POINT_CNT_ENABLE");
    }
}

// JESD enable reg
static int program_enable_registers()
{
    int i,j = 0;
    uint32_t base_address_rx[] = {DLNK_JESDABC0_XIP_204C_RX_BASE,  DLNK_JESDABC1_XIP_204C_RX_BASE,  DLNK_JESDABC2_XIP_204C_RX_BASE,  DLNK_JESDABC3_XIP_204C_RX_BASE};
    uint32_t base_address_tx[] = {DLNK_JESDABC0_XIP_204C_TX_BASE,  DLNK_JESDABC1_XIP_204C_TX_BASE,  DLNK_JESDABC2_XIP_204C_TX_BASE,  DLNK_JESDABC3_XIP_204C_TX_BASE};
    printf("JESD ENABLE : program_enable_registers \n");

    for(i=0; i<1; i++)
    {
        write_read_expect_18a(base_address_tx[i]+JESD_XIP_204C_TX_MEM_TX_ENABLEMODULE_OFFSET, JESD_XIP_204C_TX_MEM_TX_ENABLEMODULE_REG_DEFAULT, 0x1, 0x1, JESD_XIP_204C_TX_MEM_TX_ENABLEMODULE_REG_RD_MASK, JESD_XIP_204C_TX_MEM_TX_ENABLEMODULE_REG_WR_MASK, "JESD_XIP_204C_TX_MEM_TX_ENABLEMODULE_OFFSET");
    }

    for(i=0; i<1; i++)
    {
        write_read_expect_18a(base_address_rx[i]+JESD_XIP_204C_RX_MEM_RX_ENABLEMODULE_OFFSET, JESD_XIP_204C_RX_MEM_RX_ENABLEMODULE_REG_DEFAULT, 0x1, 0x1, JESD_XIP_204C_RX_MEM_RX_ENABLEMODULE_REG_RD_MASK, JESD_XIP_204C_RX_MEM_RX_ENABLEMODULE_REG_WR_MASK, "JESD_XIP_204C_RX_MEM_RX_ENABLEMODULE_OFFSET");
    }
}



static void configure_vex_strm2cio()
{
    printf("\nprograming vex 1 to receive\n");
    write_reg_18a(VEXABC1_S2C_STRM2CIO_BASE + STRM2CIO_MEM_STRM2CIO_INT_ENABLE_OFFSET, STRM2CIO_INT_ENABLE_VALUE, STRM2CIO_MEM_STRM2CIO_INT_ENABLE_WR_MASK, "STRM2CIO_INT_ENABLE");
    write_reg_18a(VEXABC1_S2C_STRM2CIO_BASE + STRM2CIO_MEM_STRM2CIO_FIFO_STATUS_CTL_OFFSET, STRM2CIO_FIFO_STATUS_CTL_VALUE, STRM2CIO_MEM_STRM2CIO_FIFO_STATUS_CTL_WR_MASK, "STRM2CIO_MEM_FIFO_STATUS_CTL");
    write_reg_18a(VEXABC1_S2C_STRM2CIO_BASE + STRM2CIO_MEM_STRM2CIO_WORD_CNT_CTL_OFFSET, STRM2CIO_WORD_CNT_CTL_VALUE, STRM2CIO_MEM_STRM2CIO_WORD_CNT_CTL_WR_MASK, "STRM2CIO_MEM_WORD_CNT_CTL");
}


static void configure_jesd_block()
{
    uint32_t tx_gb_empty_reg = 0;
    uint32_t tx_gb_full_reg = 0;
    uint32_t rx_gb_empty_reg = 0;
    uint32_t rx_gb_full_reg = 0;

    // function calls - Reg seq usecase
    program_cmn_csr_tx_registers();
    
    configure_vex_strm2cio();
    printf("Giving delay of 10 milli seconds \n");
    delay(10);

    //enable loopback - NSIP level - jesd b2h to jesd h2b - lpbk ctl - 0x1
    int k =0;
    uint32_t base_address_crux_clk_csr[] = {DLNK_JESDABC0_CRUX_CLK_CSR_BASE,  DLNK_JESDABC1_CRUX_CLK_CSR_BASE,  DLNK_JESDABC2_CRUX_CLK_CSR_BASE,  DLNK_JESDABC3_CRUX_CLK_CSR_BASE};
    printf("\n#####Nsip lpbk is enabled\n\n");
    for(k=0; k<1; k++)
    {
        write_read_expect_18a(base_address_crux_clk_csr[k]+JESDABC_CRUX_CLK_CSR_MEM_LPBK_CTL_OFFSET, JESDABC_CRUX_CLK_CSR_MEM_LPBK_CTL_DEFAULT, 0x1, 0x1, JESDABC_CRUX_CLK_CSR_MEM_LPBK_CTL_RD_MASK, JESDABC_CRUX_CLK_CSR_MEM_LPBK_CTL_WR_MASK, "JESDABC_CRUX_CLK_CSR_MEM_LPBK_CTL");
    }

    int i,j=0;
    uint32_t base_address_rx[] = {DLNK_JESDABC0_XIP_204C_RX_BASE,  DLNK_JESDABC1_XIP_204C_RX_BASE,  DLNK_JESDABC2_XIP_204C_RX_BASE,  DLNK_JESDABC3_XIP_204C_RX_BASE};
    uint32_t base_address_tx[] = {DLNK_JESDABC0_XIP_204C_TX_BASE,  DLNK_JESDABC1_XIP_204C_TX_BASE,  DLNK_JESDABC2_XIP_204C_TX_BASE,  DLNK_JESDABC3_XIP_204C_TX_BASE};

    //=================================
    printf("\n");
    printf("\n");
    for(i=0; i<1; i++)
    {
        tx_gb_empty_reg = read_reg_18a(base_address_tx[i] + JESD_XIP_204C_TX_MEM_TX_GEARBOX_EMPTY_STATUS_OFFSET, "JL_N_TX_GB_EMPTY_REG");
        tx_gb_full_reg = read_reg_18a(base_address_tx[i] + JESD_XIP_204C_TX_MEM_TX_GEARBOX_FULL_STATUS_OFFSET, "JL_N_TX_GB_FULL_REG");
    }
    for(j=0; j<1; j++)
    {
        //using JESDABC_M1_XIP_204C_RX_BASE to configure jesd1 for rx
        rx_gb_empty_reg = read_reg_18a(base_address_rx[j] + JESD_XIP_204C_RX_MEM_RX_GEARBOX_EMPTY_STATUS_OFFSET, "JL_N_RX_GB_EMPTY_REG");
        rx_gb_full_reg = read_reg_18a(base_address_rx[j] + JESD_XIP_204C_RX_MEM_RX_GEARBOX_FULL_STATUS_OFFSET, "JL_N_RX_GB_FULL_REG");
    }

    printf(" Before jesd enable value for JL_N_TX_GB_EMPTY_REG --------is 0x%x \n", tx_gb_empty_reg);
    printf(" Before jesd enable value for JL_N_TX_GB_FULL_REG ---------is 0x%x \n", tx_gb_full_reg);
    printf(" Before jesd enable value for JL_N_RX_GB_EMPTY_REG --------is 0x%x \n", rx_gb_empty_reg);
    printf(" Before jesd enable value for JL_N_RX_GB_FULL_REG ---------is 0x%x \n", rx_gb_full_reg);

    program_enable_registers();
    //CMN_CSR SYSREF ENABLE, AS PER SIMVAL LOG,
    write_read_expect_18a(DLNK_JESDABC0_CMN_CSR_BASE+JESDABC_CMN_CSR_MEM_RX_IP_SYSREF_ENABLE_OFFSET, JESDABC_CMN_CSR_MEM_RX_IP_SYSREF_ENABLE_DEFAULT, 0x00000001, 0x00000001, JESDABC_CMN_CSR_MEM_RX_IP_SYSREF_ENABLE_RD_MASK, JESDABC_CMN_CSR_MEM_RX_IP_SYSREF_ENABLE_WR_MASK, "JESDABC_CMN_CSR_MEM_RX_IP_SYSREF_ENABLE");
    write_read_expect_18a(DLNK_JESDABC0_CMN_CSR_BASE+JESDABC_CMN_CSR_MEM_TX_IP_SYSREF_ENABLE_OFFSET, JESDABC_CMN_CSR_MEM_TX_IP_SYSREF_ENABLE_DEFAULT, 0x00000001, 0x00000001, JESDABC_CMN_CSR_MEM_TX_IP_SYSREF_ENABLE_RD_MASK, JESDABC_CMN_CSR_MEM_TX_IP_SYSREF_ENABLE_WR_MASK, "JESDABC_CMN_CSR_MEM_TX_IP_SYSREF_ENABLE");
	
    //=================================
    tx_gb_empty_reg = 0;
    tx_gb_full_reg = 0;
    rx_gb_empty_reg = 0;
    rx_gb_full_reg = 0;
    printf("\n");
    printf("\n");
    for(i=0; i<1; i++)
    {
        tx_gb_empty_reg = read_reg_18a(base_address_tx[i] + JESD_XIP_204C_TX_MEM_TX_GEARBOX_EMPTY_STATUS_OFFSET, "JL_N_TX_GB_EMPTY_REG");
        tx_gb_full_reg = read_reg_18a(base_address_tx[i] + JESD_XIP_204C_TX_MEM_TX_GEARBOX_FULL_STATUS_OFFSET, "JL_N_TX_GB_FULL_REG");
    }
    for(j=0; j<1; j++)
    {
        //using JESDABC_M1_XIP_204C_RX_BASE to configure jesd1 for rx
        rx_gb_empty_reg = read_reg_18a(base_address_rx[j] + JESD_XIP_204C_RX_MEM_RX_GEARBOX_EMPTY_STATUS_OFFSET, "JL_N_RX_GB_EMPTY_REG");
        rx_gb_full_reg = read_reg_18a(base_address_rx[j] + JESD_XIP_204C_RX_MEM_RX_GEARBOX_FULL_STATUS_OFFSET, "JL_N_RX_GB_FULL_REG");
    }

    printf(" After jesd enable value for JL_N_TX_GB_EMPTY_REG --------is 0x%x \n", tx_gb_empty_reg);
    printf(" After jesd enable value for JL_N_TX_GB_FULL_REG ---------is 0x%x \n", tx_gb_full_reg);
    printf(" After jesd enable value for JL_N_RX_GB_EMPTY_REG --------is 0x%x \n", rx_gb_empty_reg);
    printf(" After jesd enable value for JL_N_RX_GB_FULL_REG ---------is 0x%x \n", rx_gb_full_reg);
    printf("\n");
    printf("\n");

}

#define PARSEBUF 160
///
/**
 * I2C:,rw,bus,address,NBYTES,{DATA}
 * @param parg
 * @param flow_ptr
 * @return
 */
int parseVexCnt( char* parg, struct flow_params_t *flow_ptr )
{
    int result=0;
    int i=0;
    int rr;
    int bus=0;
    int rtype=0;
    srp_uint64_t address;
    srp_uint32_t nBytes;
    srp_uint32_t nBytesRead=0;
    //    int slen=0;
    int vidx=0;
    srp_int32_t val=0x1;
    srp_uint8_t *vals;
    srp_dev_hdl_t devHdl=NULL;
    int ll;
    char *p;
#if(0)
    const char *direction[2];
    direction[0] = "WRITE";
    direction[1] = "READ";
#endif
    char buffer[PARSEBUF];
    /*  ########## VEXCNT ######## */
    for (ll=0;ll<PARSEBUF;ll++)
    {
        buffer[ll]='\0';
    }
    printf("1022\n");
    printf("buffer is %s\n", buffer);
    printf("1024\n");
    printf("parg is %s\n", parg);
    strcpy(buffer, parg);
    p = strtok (buffer, ",");
    printf("1026\n");
    rr = strcmp(p, "VEXCNT:");
    printf("1028\n");
    if ( rr == 0 )
    {
        printf("1027\n");
        while ( p != NULL)
        {
            p = strtok (NULL, ",");

            if ( p != NULL )
            {
                switch (i)
                {
                    case 0:
                        /* ### rType ### */
                        flow_ptr->vexCount=atoi(p);
                        if ( rtype >1)
                        {
                            printf("ERROR:, parseVexCnt,  Mode rtype=%d\n", rtype);
                            return 1;
                        }

                        break;

                    default:
                        break;
                }
                i++;
            }
        }

#if(0)
        printf("DEBUG:,parseVexCnt, rtype=%s, bus=%d, address=%lx, nBytes=%d,nBytesRead=%d {%d", direction[rtype] ,bus,address, nBytes,nBytesRead,vals[0] );
        for (int ll=1;ll<nBytesRead;ll++)
        {
            printf(",%d", vals[ll]);
        }
        printf("}\n");
#endif
        result=2;
    }
    return result;
}


///
/**
 * I2C:,rw,bus,address,NBYTES,{DATA}
 * @param parg
 * @param flow_ptr
 * @return
 */
int parseNsipCnt( char* parg, struct flow_params_t *flow_ptr )
{
    int result=0;
    int i=0;
    int rr;
    int bus=0;
    int rtype=0;
    srp_uint64_t address;
    srp_uint32_t nBytes;
    srp_uint32_t nBytesRead=0;
    //    int slen=0;
    int nsipidx=0;
    srp_int32_t val=0x1;
    srp_uint8_t *vals;
    srp_dev_hdl_t devHdl=NULL;
#if(0)
    const char *direction[2];
    direction[0] = "WRITE";
    direction[1] = "READ";
#endif
    char buffer[PARSEBUF];
    char *p;
    int ll;
    int vidx=0;

    /*  ########## NSIPCNT ######## */
    for (ll=0;ll<PARSEBUF;ll++)
    {
        buffer[ll]='\0';
    }
    strcpy(buffer, parg);
    p = strtok (buffer, ",");
    rr = strcmp(p, "NSIPCNT:");
    if ( rr == 0 )
    {
        while ( p != NULL)
        {
            p = strtok (NULL, ",");

            if ( p != NULL )
            {
                switch (i)
                {
                    case 0:
                        /* ### rType ### */
                        flow_ptr->nsipCount=atoi(p);
                        if ( rtype >1)
                        {
                            printf("ERROR:, parseNsipCnt,  Mode rtype=%d\n", rtype);
                            return 1;
                        }

                        break;

                    default:
                        break;
                }
                i++;
            }
        }

#if(0)
        printf("DEBUG:,parseVexCnt, rtype=%s, bus=%d, address=%lx, nBytes=%d,nBytesRead=%d {%d", direction[rtype] ,bus,address, nBytes,nBytesRead,vals[0] );
        for (int ll=1;ll<nBytesRead;ll++)
        {
            printf(",%d", vals[ll]);
        }
        printf("}\n");
#endif
        result=2;
    }
    return result;
}


/**
 * Parse JESD parameters
 * JESD:,
jesdUsecase: 3A,3B,3C,3D,4A,4B,4D,5A
Tx N & CS:     0 - 160 default
1-  151
2-  142
Tx Rx FB Enable:     001      Tx En=0 & Rx En=0 & Fb En=1
010        Tx En=0 & Rx En=1 & Fb En=0    
011        Tx En=0 & Rx En=1 & Fb En=1
100        Tx En=1 & Rx En=0 & Fb En=0
101        Tx En=1 & Rx En=0 & Fb En=1
110        Tx En=1 & Rx En=1 & Fb En=0
111        Tx En=1 & Rx En=1 & Fb En=1

Bit Order=3;

TestMode:     
0  Tx=0 Rx=0 Fb=0  Test mode off  
1  Tx=0 Rx=1 Fb=0  Short pattern Rx
2  Tx=1 Rx=1 Fb=1  Short Pattern  
3  Tx=1 Rx=0 Fb=1  Short pattern Tx 
4  Tx=3 Rx=0 Fb=3  Long pattern   


FEC & CRC :
00  Tx FEC=1 & CRC12=0  Rx FEC=1 & CRC12=0  - Tx FEC Rx FEC
01  Tx FEC=0 & CRC12=1  Rx FEC=1 & CRC12=0  - Tx CRC Rx FEC
10  Tx FEC=1 & CRC12=0  Rx FEC=0 & CRC12=1  - Tx FEC Rx CRC
11  Tx FEC=0 & CRC12=1  Rx FEC=0 & CRC12=1  - Tx CRC Rx CRC

SH Error Threshold :
EMB Error Threshold :


 **/
int parseJesd( char* parg, struct flow_params_t *flow_ptr )
{
    int result=0;
    int i = 0;
    int rr;
    char *ucnum;
    char buffer[PARSEBUF];
    int flag=0;
    int ll=0;
    for (ll=0;ll<PARSEBUF;ll++)
    {
        buffer[ll]='\0';
    }
    /*  ########## JESD ######## */
    if ( flow_ptr->jesdConfig.jesdUsecase == 0)
        ucnum = "0B";
    printf("DEBUG:,DEFAULT: Usecase=%s, N_CS=%d, TX_RX_FB En=%d, Testmode=%d, FEC_CRC=%d, Bit_order_Tx=%d, Bit_order_Rx=%d, SHErrTh= %d, EMBErrThr= %d\n", ucnum,  flow_ptr->jesdConfig.jesdTxncs, flow_ptr->jesdConfig.jesdEn, flow_ptr->jesdConfig.jesdTestmode, flow_ptr->jesdConfig.jesdFecCrc, flow_ptr->jesdConfig.jesdBitordertx,flow_ptr->jesdConfig.jesdBitorderrx, flow_ptr->jesdConfig.jesdShth, flow_ptr->jesdConfig.jesdEmbth );
    strcpy(buffer, parg);
    char *p = strtok (buffer, ",");
    char *ptr;
    i=0;
    int actstrlen=0;
    int iManipulate=1;
    rr = strcmp(p, "JESD:");
    int j = 0;
    int count=0;
    int k=0;
    if ( rr == 0 )
    {
        while ( p != NULL)
        {
            actstrlen+=strlen(p);        
            k=0;
            while( ((buffer[actstrlen+k]=='\0') && (buffer[actstrlen+k+1]==',') )
                    || ( (buffer[actstrlen+k]==',') && (buffer[actstrlen+k+1]==',') ) )
            {
                iManipulate++;
                i++;
                k++;
            }
            actstrlen+=iManipulate;
            iManipulate=1;
            p = strtok (NULL, ",");
            if ( p != NULL )
            {
                switch (i)
                {
					// Added for 8streams :UC-2B,3B,5C
					// Added for 4streams :UC-3A,7C
					// Added for 16streams :UC-2C,3D
                    case 0:
						/* USECASE NUMBER */
						if(strcmp (p, "2B")==0 || strcmp (p, "2b") ==0)
						{  
                  		    printf("Selected Usecase is 2B TX path\n");
							flow_ptr->jesdConfig.jesdUsecase=UC2B;
							ucnum="2B";
							vexCountStartIdxTbl[0]=0;
						}
						else if(strcmp(p, "3B")==0 || strcmp (p, "3b")==0)
						{ 
                  		    printf("Selected Usecase is 3B TX path\n");
							flow_ptr->jesdConfig.jesdUsecase=UC3B;
							ucnum="3B";
							vexCountStartIdxTbl[0]=1;
						}
						
						else if(strcmp (p, "5C")==0 || strcmp (p, "5c") ==0)
						{ 
                  		    printf("Selected Usecase is 5C TX path\n");
							flow_ptr->jesdConfig.jesdUsecase=UC5C;
							ucnum="5C";
							vexCountStartIdxTbl[0]=2;
						}
						else if(strcmp(p, "3A")==0 || strcmp (p, "3a")==0)
						{ 
                  		    printf("Selected Usecase is 3A TX path\n");
							flow_ptr->jesdConfig.jesdUsecase=UC3A;
							ucnum="3A";
							vexCountStartIdxTbl[0]=3;
						}
						else if(strcmp(p, "7C")==0 || strcmp (p, "7c")==0)
						{ 
                  		    printf("Selected Usecase is 7C TX path\n");
							flow_ptr->jesdConfig.jesdUsecase=UC7C;	
							ucnum="7C";
							vexCountStartIdxTbl[0]=4;
						}
						else if(strcmp (p, "2C")==0 || strcmp (p, "2c") ==0)
						{ 
                  		    printf("Selected Usecase is 2C TX path\n");
							flow_ptr->jesdConfig.jesdUsecase=UC2C;
							ucnum="2C";
							vexCountStartIdxTbl[1]=5;
						}
						else if(strcmp(p, "3D")==0 || strcmp (p, "3d")==0)
						{ 
                  		    printf("Selected Usecase is 3D TX path\n");
							flow_ptr->jesdConfig.jesdUsecase=UC3D;	
							ucnum="3D";
							vexCountStartIdxTbl[1]=7;
						}
                        else
                        {
                            printf("ERROR:, parseJESD. Usecase number value out of range. Usecase number=%s\n",p);
                            ucnum = p;
                            return 1;
                        }
                        break;
                    case 1:
                        /*Value of N & CS*/
                        flow_ptr->jesdConfig.jesdTxncs = atoi(p);
                        if ( flow_ptr->jesdConfig.jesdTxncs < 0 ||  flow_ptr->jesdConfig.jesdTxncs > 2)
                        {
                            printf("ERROR:, parseJESD. N_CS value out of range. N_CS=%d\n",flow_ptr->jesdConfig.jesdTxncs);
                            return 1;
                        }
                        break;
                    case 2:
                        /*Tx,Rx or Fb En*/
                        flow_ptr->jesdConfig.jesdEn = atoi(p);
                        if ( flow_ptr->jesdConfig.jesdEn == 000)
                        {
                            printf("ERROR:, parseJESD. Invalid Value of Enable. En=%d\n",flow_ptr->jesdConfig.jesdEn);
                            return 1;
                        }
                        break;
                    case 3: 
                        /* Test Mode */
                        flow_ptr->jesdConfig.jesdTestmode = atoi(p);
                        if ( flow_ptr->jesdConfig.jesdTestmode < 0 && flow_ptr->jesdConfig.jesdTestmode > 4)
                        {
                            printf("ERROR:, parseJESD. Testmode value out of range. Testmode=%d\n",flow_ptr->jesdConfig.jesdTestmode);
                            return 1;
                        }
                        break;
                    case 4:
                        /* FEC CRC */
                        flow_ptr->jesdConfig.jesdFecCrc = atoi(p);
                        if ( flow_ptr->jesdConfig.jesdFecCrc != 0 && flow_ptr->jesdConfig.jesdFecCrc != 1 && flow_ptr->jesdConfig.jesdFecCrc != 2 && flow_ptr->jesdConfig.jesdFecCrc != 3)
                        {
                            printf("ERROR:, parseJESD. FEC_ CRC value out of range. FEC_CRC=%d\n",flow_ptr->jesdConfig.jesdFecCrc);
                            return 1;
                        }
                        break;
                    case 5:
                        /* Bit Order Tx */
                        flow_ptr->jesdConfig.jesdBitordertx = atoi(p);
                        if ( flow_ptr->jesdConfig.jesdBitordertx < 0 && flow_ptr->jesdConfig.jesdBitordertx > 7)
                        {
                            printf("ERROR:, parseJESD. Bit Order Tx value out of range. BitOrdertx=%d\n",flow_ptr->jesdConfig.jesdBitordertx);
                            return 1;
                        }
                        break;
                    case 6:
                        /* Bit Order Rx */
                        flow_ptr->jesdConfig.jesdBitorderrx = atoi(p);
                        if ( flow_ptr->jesdConfig.jesdBitorderrx < 0 && flow_ptr->jesdConfig.jesdBitorderrx > 7)
                        {
                            printf("ERROR:, parseJESD. Bit Order rx value out of range. BitOrderrx=%d\n",flow_ptr->jesdConfig.jesdBitorderrx);
                            return 1;
                        }
                        break;
                    case 7:
                        /* SH Error Threshold */
                        flow_ptr->jesdConfig.jesdShth = atoi(p);
                        if ( flow_ptr->jesdConfig.jesdShth == 0 )
                        {
                            printf("ERROR:, parseJESD. Invalid Value of SH Error Threshold. ShErrThr=%d\n",flow_ptr->jesdConfig.jesdShth);
                            return 1;
                        }
                        break;
                    case 8:
                        /* EMB Error Threshold */
                        flow_ptr->jesdConfig.jesdEmbth = atoi(p);
                        if ( flow_ptr->jesdConfig.jesdEmbth == 0 )
                        {
                            printf("ERROR:, parseJESD. Invalid Value of EMB Error Threshold. EMBErrThr=%d\n",flow_ptr->jesdConfig.jesdEmbth);
                            return 1;
                        }
                        i=-1;
                        break;
                }
                flag=1;
                i++;
            }
        }
        printf("DEBUG:,POST: Usecase=%s, N_CS=%d, TX_RX_FB En=%d, Testmode=%d, FEC_CRC=%d, Bit_order_Tx=%d, Bit_order_Rx=%d, SHErrTh= %d, EMBErrThr= %d\n", ucnum, flow_ptr->jesdConfig.jesdTxncs, flow_ptr->jesdConfig.jesdEn, flow_ptr->jesdConfig.jesdTestmode, flow_ptr->jesdConfig.jesdFecCrc, flow_ptr->jesdConfig.jesdBitordertx,flow_ptr->jesdConfig.jesdBitorderrx, flow_ptr->jesdConfig.jesdShth, flow_ptr->jesdConfig.jesdEmbth );
    }
    return result;
}

/**
 * Parse command line options of the form OPT:
 * This is called my main with the command line positional arguments
 * @param carg - Single option
 * @param flow_ptr - Parameters
 * @return
 */
int  parseOpts( char* carg, struct flow_params_t *flow_ptr )
{
    int rr=0;
    printf("parseOpts\n");
    rr=parseVexCnt(  carg, flow_ptr )|rr;
    rr=parseNsipCnt(  carg, flow_ptr )|rr;
    rr=parseJesd(  carg, flow_ptr )|rr;
    if ((rr !=0) && (rr !=2))
    {
        printf("ERROR:, Parsing command line option, {%s}\n",carg);
        rr=-1;
    }
    return rr;
}


void assign_defaults(struct flow_params_t *flow_ptr)
{
    flow_ptr->vexCount = 1;
    flow_ptr->nsipCount = 1;

    /*JESD */
    flow_ptr->jesdConfig.jesdUsecase    = UC5C;
    flow_ptr->jesdConfig.jesdTxncs      = 0;
    flow_ptr->jesdConfig.jesdEn         = 111;
    flow_ptr->jesdConfig.jesdTestmode   = 0;
    flow_ptr->jesdConfig.jesdFecCrc     = 0;
    flow_ptr->jesdConfig.jesdBitordertx = 3;
    flow_ptr->jesdConfig.jesdBitorderrx = 0;
    flow_ptr->jesdConfig.jesdShth       = 16;
    flow_ptr->jesdConfig.jesdEmbth      = 8;
}

int main(int argc, const char *argv[])
{
    int rv = 0;
    uint32_t value38 = 0;
    uint32_t value39 = 0;
    uint32_t value40 = 0;
    uint32_t value41 = 0;
    uint32_t value42 = 0;
    uint32_t value43 = 0;
    uint32_t value44 = 0;
    uint32_t value45 = 0;
    int flags = 0;
    void *vex_hdl;
    /*
    //clear vex memory
    //printf("\n########Starting to clear vex mem from 0-10\n");
    vex_mem_clear(0, srp);
    vex_mem_clear(1, srp);
    vex_mem_clear(2, srp);
    vex_mem_clear(3, srp);
    vex_mem_clear(4, srp);
    vex_mem_clear(5, srp);
    vex_mem_clear(6, srp);
    vex_mem_clear(7, srp);
    vex_mem_clear(8, srp);
    vex_mem_clear(9, srp);
    vex_mem_clear(10, srp);
    //printf("########Done clearing vex mem from 0-10\n\n");
    */
    srp_vex_config_t vex_params;
    srp_vex_t srp_vex_hdl;
    int lc, i, j;
    int vexId[40], nsipId[2], apb_num, host_flag = 1, cm_num = 0, port_num = 0;
    volatile unsigned int b2h_flit_cnt = 0, h2b_flit_cnt = 0, host_result = 0, host_vec_processed = 0, host_blocks_processed = 0;
    int total_streams_0 = 8;
    int total_streams_1 = 16;
    int dmem_offset = 0x4000;
    int vex_tx_offset_val[] = {HIVE_ADDR_jesd_tx_g_dest_buffer0_base, HIVE_ADDR_jesd_tx_g_dest_buffer1_base,
                                    HIVE_ADDR_jesd_tx_g_dest_buffer2_base, HIVE_ADDR_jesd_tx_g_dest_buffer3_base,
                                    HIVE_ADDR_jesd_tx_g_dest_buffer4_base, HIVE_ADDR_jesd_tx_g_dest_buffer5_base,
                                    HIVE_ADDR_jesd_tx_g_dest_buffer6_base, HIVE_ADDR_jesd_tx_g_dest_buffer7_base,
                                    HIVE_ADDR_jesd_tx_g_timeout_cycles};

//8 Streams U-2b==1 VEX entry v0_vex_tx_val_kargs; U-3b== 1 VEX entry v1_vex_tx_val_kargs; U-5c==1 VEX entry v2_vex_tx_val_kargs, 
//Added for U-2B
    unsigned v0_vex_tx_val_kargs[] = {0x00000, 0x20000,
                                   0x40000, 0x60000,
								   0x80000, 0xA0000,
								   0xC0000, 0xE0000,8191};								   
//Added for U-3B
	unsigned v1_vex_tx_val_kargs[] = {0x00000, 0x20000,
									0x40000, 0x60000,
									0x80000, 0xA0000,
									0xC0000, 0xE0000,4095};
//Added for U-5C
	unsigned v2_vex_tx_val_kargs[] = {0x00000, 0x20000,
                                   0x40000, 0x60000,
								   0x80000, 0xA0000,
								   0xC0000, 0xE0000,2047};
								   
//4 Streams U-3a==1 VEX entry v3_vex_tx_val_kargs; U-7c== 1 VEX entry v4_vex_tx_val_kargs		   
//Added for U-3A
    unsigned v3_vex_tx_val_kargs[] = {0x00000, 0x20000,
                                   0x40000, 0x60000,
								   0x80000, 0xA0000,
								   0xC0000, 0xE0000,8191};
//Added for U-7C
    unsigned v4_vex_tx_val_kargs[] = {0x00000, 0x20000,
                                   0x40000, 0x60000,
								   0x80000, 0xA0000,
								   0xC0000, 0xE0000,2047};
								   
//16 Streams U-2c==2 VEX entries v5_vex_tx_val_kargs, v6_vex_tx_val_kargs; U-3d== 2 VEX entries v7_vex_tx_val_kargs, v8_vex_tx_val_kargs
//Added for U-2C
    unsigned v5_vex_tx_val_kargs[] = {0x00000, 0x20000,
                                   0x40000, 0x60000,
								   0x80000, 0xA0000,
								   0xC0000, 0xE0000,2047};
								   
	unsigned v6_vex_tx_val_kargs[] = {0x100000, 0x120000,
                                   0x140000, 0x160000,
								   0x180000, 0x1A0000,
								   0x1C0000, 0x1E0000,2047};

								   
//Added for U-3D
    unsigned v7_vex_tx_val_kargs[] = {0x00000, 0x20000,
                                   0x40000, 0x60000,
								   0x80000, 0xA0000,
								   0xC0000, 0xE0000,2047};
								// need to give - > n-1
								// jesd -> expectes data at every 0-2047
	unsigned v8_vex_tx_val_kargs[] = {0x100000, 0x120000,
                                   0x140000, 0x160000,
								   0x180000, 0x1A0000,
								   0x1C0000, 0x1E0000,2047};
								   
								 								   
//Added for 8 streams : U-2B, U-3B, U-5C
//Added for 4 streams : U-3A, U-7C
//Added for 16 streams : U-2C, U-3D
	unsigned *vex_tx_val_kargs_tbl[9]={ v0_vex_tx_val_kargs, v1_vex_tx_val_kargs, v2_vex_tx_val_kargs,
										v3_vex_tx_val_kargs, v4_vex_tx_val_kargs,
										v5_vex_tx_val_kargs, v6_vex_tx_val_kargs, v7_vex_tx_val_kargs, v8_vex_tx_val_kargs}; 

	unsigned vex_tx_buffer_addr[] = {HIVE_ADDR_jesd_tx_vbuffer_0, HIVE_ADDR_jesd_tx_vbuffer_1,
									HIVE_ADDR_jesd_tx_vbuffer_2, HIVE_ADDR_jesd_tx_vbuffer_3,
									HIVE_ADDR_jesd_tx_vbuffer_4, HIVE_ADDR_jesd_tx_vbuffer_5,
									HIVE_ADDR_jesd_tx_vbuffer_6, HIVE_ADDR_jesd_tx_vbuffer_7};
									
	unsigned val_inp[NUM_TOTAL_VEC_PER_STREAM][NUM_OF_ELEMENTS_PER_VEC] = {0};
	unsigned int add_val[1];
	
//Added for 8 streams : U-2B, U-3B, U-5C
//Added for 4 streams : U-3A, U-7C
//Added for 16 streams : U-2C, U-3D
	unsigned int vex_start_stop[9][2]={	{0,8},{0,8},{0,8},
										{0,4},{0,4},
										{0,8},{8,16},{0,8},{8,16}
										};
    int rr=0;
    int vexIdx;
    int k=0;

    int vexCount = 1;
    int nsipCount = 1;

    //###########################################
    fpga_clk_and_sysref_period();
    delay(100);    
    system("/p/frio/tools/frioPciWrite -F s6b3 -P 0x20000 0xa");
    system("/p/frio/tools/frioPciWrite -F s6b3 -P 0x20000 0xb");
    delay(100);
    init(); // Initialize the srp
    delay(1000);
    //clear vex memory
    printf("\n########Starting to clear vex mem from 0-10\n");
    vex_mem_clear(0, srp);
    vex_mem_clear(1, srp);
    vex_mem_clear(2, srp);
    vex_mem_clear(3, srp);
    vex_mem_clear(4, srp);
    vex_mem_clear(5, srp);
    vex_mem_clear(6, srp);
    vex_mem_clear(7, srp);
    vex_mem_clear(8, srp);
    vex_mem_clear(9, srp);
    vex_mem_clear(10, srp);
    printf("########Done clearing vex mem from 0-10\n\n");
    delay(100);
    jesd_reset(JESD_INSTANCE_0,0);
    delay(1000);
    printf("\n");
    fpga_provided_sysref();
    delay(100);
    //###########################################

    printf("Number of command-line arguments: %d\n", argc);

    printf("Command-line arguments:\n");
    for (i = 0; i < argc-1; i++) {
        printf("1313\n");
        if (argv[i] != NULL) {
            printf("argv[%d] = %s\n", i, argv[i]);
        } else {
            printf("argv[%d] is NULL\n", i);
        }
        printf("1319\n");
    }


    assign_defaults(&flow_params);
    optind=0;
    for(; optind < argc-1; optind++)
    {
        rr = parseOpts( argv[optind],  &flow_params )|rr;
    }

    sleep(2);
    //system("source jesd_config.sh"); //vijay

    LOG_PRINT("INFO: logger beginning\n");

    //vexCount = 1;
    vexCount = flow_params.vexCount;
    printf("Vex count is %d\n", vexCount);
    //for(i=0; i<vexCount; i++)
    for (j=0, i = vexCountStartIdxTbl[vexCount-1]; i < vexCount+vexCountStartIdxTbl[vexCount-1]; j++, i++)
    {
        // vexId[i] = i - vexCountStartIdxTbl[vexCount-1];
        vexId[i] = j;
    }

    //nsipCount = 2;
    nsipCount = flow_params.nsipCount;
    printf("Nsip count is %d\n", nsipCount);
    for(i=0; i<nsipCount; i++)
    {
        nsipId[i] = i;
    }

    port_num= 0;
    apb_num = 0;
    cm_num = 0;
    printf("vex id: %d , nsipId : %d , apb_num: %d, cm_num: %d\n",vexId[0], nsipId, apb_num, cm_num);

    memset(&vex_params, 0, sizeof(vex_params));
    memset(&srp_vex_hdl, 0, sizeof(srp_vex_hdl));

    //if (rv = o_configure_jesd_host(vexCount, vexId, nsipId, apb_num, cm_num))
    if (rv = configure_jesd_host(vexCount, vexId, nsipCount, nsipId, apb_num, cm_num))
    {
        printf ("ERROR: configure_jesd_host\n");
        return rv;
    }
    

    vex_hdl = &srp_vex_hdl;

    if ((rv = srp_vex_config(srp, &vex_hdl, &vex_params)))
        return rv;

    /*resetting the VEC NOC*/
    if (rv = release_reset_abc_noc(srp))
    {
        printf("ERROR: reset_abc failed\n");
        return rv;
    }

    printf("Host: start vex tx program load \n");

    //for (vexIdx = 0; vexIdx < vexCount; vexIdx++)
    for (vexIdx = vexCountStartIdxTbl[vexCount-1]; vexIdx < vexCount+vexCountStartIdxTbl[vexCount-1]; vexIdx++)
    {
        if ((rv = srp_vex_loader(vex_hdl, vexId[vexIdx], "vex_fw/sim_m64/jesd_tx.fw")))
            return rv;
    }

    printf("Host: vex program load - done\n");


    /* Loading the host parameters to VEX_0  Rx core*/
    //for (vexIdx = 0; vexIdx < vexCount; vexIdx++)
    for (vexIdx = vexCountStartIdxTbl[vexCount-1]; vexIdx < vexCount+vexCountStartIdxTbl[vexCount-1]; vexIdx++)
    {
        for (lc = 0; lc < ARRAY_SIZE(vex_tx_offset_val); lc++)
        {
            if ((rv = srp_dev_block_write32(srp,
                            SRP_BLOCK_VEX_CORE,
                            vexId[vexIdx],
                            dmem_offset + vex_tx_offset_val[lc],
                            &vex_tx_val_kargs_tbl[vexIdx][lc],
                            1,
                            flags)))
                return rv;
            //sleep(1);
        }   // for (lc = 0; lc < ARRAY_SIZE(offset_val); lc++) ends
    }

    printf("Host parameters loaded to Vex0\n");

    /* Input Vector Generation VEX_0*/
    for (vexIdx = vexCountStartIdxTbl[vexCount-1]; vexIdx < vexCount+vexCountStartIdxTbl[vexCount-1]; vexIdx++)
    {
        for (lc = vex_start_stop[vexIdx][0]; lc < vex_start_stop[vexIdx][1] ; lc++)
        {
			printf(" vijay -- vexIdx %d, lc = %d\n", vexIdx, lc);
            for (i = 0; i < NUM_TOTAL_VEC_PER_STREAM; i++)
            {
                for (j = 0; j < NUM_OF_ELEMENTS_PER_VEC; j++)
                {
                    val_inp[i][j] = (((((i * 2 * NUM_OF_ELEMENTS_PER_VEC) + (j * 2)) + 1) << 16) |((i * 2* NUM_OF_ELEMENTS_PER_VEC) + (j *2)));
                    val_inp[i][j] = val_inp[i][j] & 0x0FFF0FFF;
                    val_inp[i][j] = val_inp[i][j] | (lc << 28 | lc << 12);
                    //val_inp[i][j] = 0xb2b2a5a5;

                }
            }
            
            
#if 1
            if ((rv = srp_vex_memid_store(vex_hdl,
                            vexId[vexIdx],
                            SRP_VEX_VMEM,
                            vex_tx_buffer_addr[lc - vex_start_stop[vexIdx][0]],/*local_addr*/
                            val_inp[0],
                            (NUM_TOTAL_VEC_PER_STREAM * NUM_OF_ELEMENTS_PER_VEC * sizeof(int)))))
                return rv;
#endif
			//write_mem_18a((vex_tx_buffer_addr[lc - vex_start_stop[vexIdx][0]] + ), (NUM_TOTAL_VEC_PER_STREAM * NUM_OF_ELEMENTS_PER_VEC * sizeof(int)), val_inp[0], "vex_vmem" );

            printf(" vijay2 -- vexId[vexIdx] %d, addr = 0x%x , data = 0x%x\n", vexId[vexIdx], vex_tx_buffer_addr[lc - vex_start_stop[vexIdx][0]], val_inp[0][0]);
        }

    }
    
    //return;

    printf("Input vectors generated for Vex0 \n");

    for (vexIdx = vexCountStartIdxTbl[vexCount-1]; vexIdx < vexCount+vexCountStartIdxTbl[vexCount-1]; vexIdx++)
    {
        printf("Host: vex %d program start\n",vexIdx);
        srp_vex_start(vex_hdl, vexId[vexIdx], 0); // vex_0 start
    }
    configure_jesd_block();

    printf("Host: vex program start - done for vex0\n");

    /*Signal VEX_0 to start continuous flow*/

    //for (vexIdx = 0; vexIdx < vexCount; vexIdx++)
    for (vexIdx = vexCountStartIdxTbl[vexCount-1]; vexIdx < vexCount+vexCountStartIdxTbl[vexCount-1]; vexIdx++)
    {
        if ((rv = srp_dev_block_write32(srp,
                        SRP_BLOCK_VEX_CORE,
                        vexId[vexIdx],
                        dmem_offset + HIVE_ADDR_jesd_tx_g_host_indicator,
                        &host_flag,
                        1,
                        flags)))
            return rv;
    }

    //=================================
    //=================================
    uint32_t tx_gb_empty_reg = 0;
    uint32_t tx_gb_full_reg = 0;
    uint32_t rx_gb_empty_reg = 0;
    uint32_t rx_gb_full_reg = 0;
    uint32_t rx_sh_lock=0;
    uint32_t rx_emb_lock=0;
    uint32_t rx_sh_lock_loss=0;
    uint32_t rx_emb_lock_loss=0;
    i,j=0;
    uint32_t base_address_rx[] = {DLNK_JESDABC0_XIP_204C_RX_BASE,  DLNK_JESDABC1_XIP_204C_RX_BASE,  DLNK_JESDABC2_XIP_204C_RX_BASE,  DLNK_JESDABC3_XIP_204C_RX_BASE};
    uint32_t base_address_tx[] = {DLNK_JESDABC0_XIP_204C_TX_BASE,  DLNK_JESDABC1_XIP_204C_TX_BASE,  DLNK_JESDABC2_XIP_204C_TX_BASE,  DLNK_JESDABC3_XIP_204C_TX_BASE};
    uint32_t base_tx_glue[] = {DLNK_JESDABC0_TX_GLUE_BASE,  DLNK_JESDABC1_TX_GLUE_BASE,  DLNK_JESDABC2_TX_GLUE_BASE,  DLNK_JESDABC3_TX_GLUE_BASE};
    uint32_t base_address_crux_clk_csr[] = {DLNK_JESDABC0_CRUX_CLK_CSR_BASE,  DLNK_JESDABC1_CRUX_CLK_CSR_BASE,  DLNK_JESDABC2_CRUX_CLK_CSR_BASE,  DLNK_JESDABC3_CRUX_CLK_CSR_BASE};
    //uint32_t base_address_cmn[] = {DLNK_JESDABC0_CMN_CSR_BASE,  DLNK_JESDABC1_CMN_CSR_BASE,  DLNK_JESDABC2_CMN_CSR_BASE,  DLNK_JESDABC3_CMN_CSR_BASE};
    printf("\n");
    printf("\n");
    for(i=0; i<1; i++)
    {
        tx_gb_empty_reg = read_reg_18a(base_address_tx[i] + JESD_XIP_204C_TX_MEM_TX_GEARBOX_EMPTY_STATUS_OFFSET, "JL_N_TX_GB_EMPTY_REG");
        tx_gb_full_reg = read_reg_18a(base_address_tx[i] + JESD_XIP_204C_TX_MEM_TX_GEARBOX_FULL_STATUS_OFFSET, "JL_N_TX_GB_FULL_REG");
    }
    for(j=0; j<1; j++)
    {
        //using JESDABC_M1_XIP_204C_RX_BASE to configure jesd1 for rx
        rx_gb_empty_reg = read_reg_18a(base_address_rx[j] + JESD_XIP_204C_RX_MEM_RX_GEARBOX_EMPTY_STATUS_OFFSET, "JL_N_RX_GB_EMPTY_REG");
        rx_gb_full_reg = read_reg_18a(base_address_rx[j] + JESD_XIP_204C_RX_MEM_RX_GEARBOX_FULL_STATUS_OFFSET, "JL_N_RX_GB_FULL_REG");
    }

    printf(" After SYSREF value for JL_N_TX_GB_EMPTY_REG --------is 0x%x \n", tx_gb_empty_reg);
    printf(" After SYSREF value for JL_N_TX_GB_FULL_REG ---------is 0x%x \n", tx_gb_full_reg);
    printf(" After SYSREF value for JL_N_RX_GB_EMPTY_REG --------is 0x%x \n", rx_gb_empty_reg);
    printf(" After SYSREF value for JL_N_RX_GB_FULL_REG ---------is 0x%x \n", rx_gb_full_reg);
    printf("\n");
    printf("\n");

    rx_sh_lock  = read_reg_18a(base_address_rx[0] + JESD_XIP_204C_RX_MEM_RX_SH_LOCK_STATUS_OFFSET, "JESD_XIP_RX_MEM_JL_SH_LOCK_STATUS");
    rx_emb_lock  = read_reg_18a(base_address_rx[0] + JESD_XIP_204C_RX_MEM_RX_EMB_LOCK_STATUS_OFFSET, "JESD_XIP_RX_MEM_JL_EMB_LOCK_STATUS");
    rx_sh_lock_loss  = read_reg_18a(base_address_rx[0] + JESD_XIP_204C_RX_MEM_RX_SH_LOCK_LOSS_STATUS_OFFSET, "JESD_XIP_RX_MEM_JL_SH_LOCK_LOSS_STATUS");
    rx_emb_lock_loss  = read_reg_18a(base_address_rx[0] + JESD_XIP_204C_RX_MEM_RX_EMB_LOCK_LOSS_STATUS_OFFSET, "JESD_XIP_RX_MEM_JL_SH_LOCK_LOSS_STATUS");

    printf("\n\n");
    printf("After SYSREF value of SH lock of Link0 is 0x%x \n",rx_sh_lock);
    printf("After SYSREF value of EMB lock of Link0 is 0x%x \n",rx_emb_lock);
    printf("After SYSREF value of SH lock loss of Link0 is 0x%x \n",rx_sh_lock_loss);
    printf("After SYSREF value of EMB lock loss of Link0 is 0x%x \n",rx_emb_lock_loss);

    delay(2500);

    printf("\n");
    printf("dumping jesd h2b flit count\n");
    system("srpRead 0x06705314 1");
    printf("dumping jesd b2h flit count\n");
    system("srpRead 0x06705014 1");
    printf("dumping tsb write pointers \n");
    system("srpRead 0x06709300 16");
    printf("dumping vex0 flit count\n");
    system("srpRead 0x02802024 1");
    printf("dumping vex1 flit count\n");
    system("srpRead 0x02842024 1");
    
    printf("\n#######dumping capturing vex1\n\n");
    system("srpRead 0x63.1.0x29000 64");
    printf("\n");
    system("srpRead 0x63.1.0x29200 64");
    printf("\n");
    system("srpRead 0x63.1.0x29400 64");
    printf("\n");
    system("srpRead 0x63.1.0x29600 64");
    printf("\n");
    system("srpRead 0x63.1.0x29800 64");
    printf("\n");
    system("srpRead 0x63.1.0x29a00 64");
    printf("\n");
    system("srpRead 0x63.1.0x29c00 64");
    printf("\n");
    system("srpRead 0x63.1.0x29e00 64");
    printf("\n####################\n");

    printf("#######dumping streaming vex0\n\n");
    system("srpRead 0x63.0.0x28000 64");
    printf("\n");
    system("srpRead 0x63.0.0x2a000 64");
    printf("\n");
    system("srpRead 0x63.0.0x2c000 64");
    printf("\n");
    system("srpRead 0x63.0.0x2e000 64");
    printf("\n");
    system("srpRead 0x63.0.0x30000 64");
    printf("\n");
    system("srpRead 0x63.0.0x32000 64");
    printf("\n");
    system("srpRead 0x63.0.0x34000 64");
    printf("\n");
    system("srpRead 0x63.0.0x36000 64");
    return rv;
}   // main ends

